diff --git a/CMakeModules/FindSSE.cmake b/CMakeModules/FindSSE.cmake
new file mode 100644
index 0000000..6ece876
--- /dev/null
+++ b/CMakeModules/FindSSE.cmake
@@ -0,0 +1,104 @@
+# Check if SSE instructions are available on the machine where 
+# the project is compiled.
+
+IF(CMAKE_SYSTEM_NAME MATCHES "Linux")
+   EXEC_PROGRAM(cat ARGS "/proc/cpuinfo" OUTPUT_VARIABLE CPUINFO)
+
+   STRING(REGEX REPLACE "^.*(sse2).*$" "\\1" SSE_THERE ${CPUINFO})
+   STRING(COMPARE EQUAL "sse2" "${SSE_THERE}" SSE2_TRUE)
+   IF (SSE2_TRUE)
+      set(SSE2_FOUND true CACHE BOOL "SSE2 available on host")
+   ELSE (SSE2_TRUE)
+      set(SSE2_FOUND false CACHE BOOL "SSE2 available on host")
+   ENDIF (SSE2_TRUE)
+
+   # /proc/cpuinfo apparently omits sse3 :(
+   STRING(REGEX REPLACE "^.*[^s](sse3).*$" "\\1" SSE_THERE ${CPUINFO})
+   STRING(COMPARE EQUAL "sse3" "${SSE_THERE}" SSE3_TRUE)
+   IF (NOT SSE3_TRUE)
+      STRING(REGEX REPLACE "^.*(T2300).*$" "\\1" SSE_THERE ${CPUINFO})
+      STRING(COMPARE EQUAL "T2300" "${SSE_THERE}" SSE3_TRUE)
+   ENDIF (NOT SSE3_TRUE)
+
+   STRING(REGEX REPLACE "^.*(ssse3).*$" "\\1" SSE_THERE ${CPUINFO})
+   STRING(COMPARE EQUAL "ssse3" "${SSE_THERE}" SSSE3_TRUE)
+   IF (SSE3_TRUE OR SSSE3_TRUE)
+      set(SSE3_FOUND true CACHE BOOL "SSE3 available on host")
+   ELSE (SSE3_TRUE OR SSSE3_TRUE)
+      set(SSE3_FOUND false CACHE BOOL "SSE3 available on host")
+   ENDIF (SSE3_TRUE OR SSSE3_TRUE)
+   IF (SSSE3_TRUE)
+      set(SSSE3_FOUND true CACHE BOOL "SSSE3 available on host")
+   ELSE (SSSE3_TRUE)
+      set(SSSE3_FOUND false CACHE BOOL "SSSE3 available on host")
+   ENDIF (SSSE3_TRUE)
+
+   STRING(REGEX REPLACE "^.*(sse4_1).*$" "\\1" SSE_THERE ${CPUINFO})
+   STRING(COMPARE EQUAL "sse4_1" "${SSE_THERE}" SSE41_TRUE)
+   IF (SSE41_TRUE)
+      set(SSE4_1_FOUND true CACHE BOOL "SSE4.1 available on host")
+   ELSE (SSE41_TRUE)
+      set(SSE4_1_FOUND false CACHE BOOL "SSE4.1 available on host")
+   ENDIF (SSE41_TRUE)
+ELSEIF(CMAKE_SYSTEM_NAME MATCHES "Darwin")
+   EXEC_PROGRAM("/usr/sbin/sysctl -n machdep.cpu.features" OUTPUT_VARIABLE
+      CPUINFO)
+
+   STRING(REGEX REPLACE "^.*[^S](SSE2).*$" "\\1" SSE_THERE ${CPUINFO})
+   STRING(COMPARE EQUAL "SSE2" "${SSE_THERE}" SSE2_TRUE)
+   IF (SSE2_TRUE)
+      set(SSE2_FOUND true CACHE BOOL "SSE2 available on host")
+   ELSE (SSE2_TRUE)
+      set(SSE2_FOUND false CACHE BOOL "SSE2 available on host")
+   ENDIF (SSE2_TRUE)
+
+   STRING(REGEX REPLACE "^.*[^S](SSE3).*$" "\\1" SSE_THERE ${CPUINFO})
+   STRING(COMPARE EQUAL "SSE3" "${SSE_THERE}" SSE3_TRUE)
+   IF (SSE3_TRUE)
+      set(SSE3_FOUND true CACHE BOOL "SSE3 available on host")
+   ELSE (SSE3_TRUE)
+      set(SSE3_FOUND false CACHE BOOL "SSE3 available on host")
+   ENDIF (SSE3_TRUE)
+
+   STRING(REGEX REPLACE "^.*(SSSE3).*$" "\\1" SSE_THERE ${CPUINFO})
+   STRING(COMPARE EQUAL "SSSE3" "${SSE_THERE}" SSSE3_TRUE)
+   IF (SSSE3_TRUE)
+      set(SSSE3_FOUND true CACHE BOOL "SSSE3 available on host")
+   ELSE (SSSE3_TRUE)
+      set(SSSE3_FOUND false CACHE BOOL "SSSE3 available on host")
+   ENDIF (SSSE3_TRUE)
+
+   STRING(REGEX REPLACE "^.*(SSE4.1).*$" "\\1" SSE_THERE ${CPUINFO})
+   STRING(COMPARE EQUAL "SSE4.1" "${SSE_THERE}" SSE41_TRUE)
+   IF (SSE41_TRUE)
+      set(SSE4_1_FOUND true CACHE BOOL "SSE4.1 available on host")
+   ELSE (SSE41_TRUE)
+      set(SSE4_1_FOUND false CACHE BOOL "SSE4.1 available on host")
+   ENDIF (SSE41_TRUE)
+ELSEIF(CMAKE_SYSTEM_NAME MATCHES "Windows")
+   # TODO
+   set(SSE2_FOUND   true  CACHE BOOL "SSE2 available on host")
+   set(SSE3_FOUND   false CACHE BOOL "SSE3 available on host")
+   set(SSSE3_FOUND  false CACHE BOOL "SSSE3 available on host")
+   set(SSE4_1_FOUND false CACHE BOOL "SSE4.1 available on host")
+ELSE(CMAKE_SYSTEM_NAME MATCHES "Linux")
+   set(SSE2_FOUND   true  CACHE BOOL "SSE2 available on host")
+   set(SSE3_FOUND   false CACHE BOOL "SSE3 available on host")
+   set(SSSE3_FOUND  false CACHE BOOL "SSSE3 available on host")
+   set(SSE4_1_FOUND false CACHE BOOL "SSE4.1 available on host")
+ENDIF(CMAKE_SYSTEM_NAME MATCHES "Linux")
+
+if(NOT SSE2_FOUND)
+      MESSAGE(STATUS "Could not find hardware support for SSE2 on this machine.")
+endif(NOT SSE2_FOUND)
+if(NOT SSE3_FOUND)
+      MESSAGE(STATUS "Could not find hardware support for SSE3 on this machine.")
+endif(NOT SSE3_FOUND)
+if(NOT SSSE3_FOUND)
+      MESSAGE(STATUS "Could not find hardware support for SSSE3 on this machine.")
+endif(NOT SSSE3_FOUND)
+if(NOT SSE4_1_FOUND)
+      MESSAGE(STATUS "Could not find hardware support for SSE4.1 on this machine.")
+endif(NOT SSE4_1_FOUND)
+
+mark_as_advanced(SSE2_FOUND SSE3_FOUND SSSE3_FOUND SSE4_1_FOUND)
diff --git a/CMakeModules/WritePgkConfig.cmake b/CMakeModules/WritePgkConfig.cmake
new file mode 100644
index 0000000..caf9499
--- /dev/null
+++ b/CMakeModules/WritePgkConfig.cmake
@@ -0,0 +1,25 @@
+#
+# Write a pkg-config pc file for given "name" with "decription"
+# Arguments:
+#   name: a library name (without "lib" prefix and "so" suffixes
+#   desc: a desription string
+#
+macro (create_pkgconfig_file name desc)
+    set(_pkgfname "${CMAKE_CURRENT_BINARY_DIR}/${name}.pc")
+    message(STATUS "${name}: writing pkgconfig file ${_pkgfname}")
+
+    file(WRITE "${_pkgfname}" "# file generated by razor-qt cmake build
+prefix=${CMAKE_INSTALL_PREFIX}
+libdir=\${prefix}/lib${LIB_SUFFIX}
+includedir=\${prefix}/include
+
+Name: ${name}
+Description: ${desc}
+Version: ${VIDSTAB_VERSION}
+Libs: -L\${libdir} -l${name}
+Cflags: -I\${includedir}
+
+")
+
+    install(FILES ${_pkgfname} DESTINATION lib${LIB_SUFFIX}/pkgconfig)
+endmacro()
\ No newline at end of file
diff --git a/CMakeModules/create_pkgconfig_file.cmake b/CMakeModules/create_pkgconfig_file.cmake
new file mode 100644
index 0000000..c941f09
--- /dev/null
+++ b/CMakeModules/create_pkgconfig_file.cmake
@@ -0,0 +1,25 @@
+#
+# Write a pkg-config pc file for given "name" with "decription"
+# Arguments:
+#   name: a library name (without "lib" prefix and "so" suffixes
+#   desc: a desription string
+#
+macro (create_pkgconfig_file name desc)
+    set(_pkgfname "${CMAKE_CURRENT_BINARY_DIR}/${name}.pc")
+    message(STATUS "${name}: writing pkgconfig file ${_pkgfname}")
+
+    file(WRITE "${_pkgfname}" "# file generated by vid.stab cmake build
+prefix=${CMAKE_INSTALL_PREFIX}
+libdir=\${prefix}/lib${LIB_SUFFIX}
+includedir=\${prefix}/include
+
+Name: ${name}
+Description: ${desc}
+Version: ${VIDSTAB_VERSION}
+Libs: -L\${libdir} -l${name}
+Cflags: -I\${includedir}
+
+")
+
+    install(FILES ${_pkgfname} DESTINATION lib/pkgconfig)
+endmacro()
\ No newline at end of file
diff --git a/Install b/Install
new file mode 100644
index 0000000..15d5eee
--- /dev/null
+++ b/Install
@@ -0,0 +1,31 @@
+***  LIBRARY ***
+To compile the library do:
+
+cd src/cmake
+
+cmake ../
+make
+sudo make install
+
+To customize the installation prefix use
+cmake -DCMAKE_INSTALL_PREFIX:PATH=/usr/local
+
+
+*** TRANSCODE plugins ***
+
+You need to have the transcode sources installed. The best
+choice it to download the same version you have in your distribution.
+Youi don't need to compile transcode itself.
+Download from http://tcforge.berlios.de/ or
+ http://developer.berlios.de/project/showfiles.php?group_id=10094.
+Then you need to adapt the transcode/CMakeLists.txt and change
+ the variable
+> set(TRANSCODE_ROOT path/to/transcode)
+
+cd transcode/cmake
+make
+. install.sh
+
+*** FFMPEG ***
+
+You need to configure ffmpeg with --enable-vidstab
\ No newline at end of file
diff --git a/README b/README
index 467c5f3..c688a84 100644
--- a/README
+++ b/README
@@ -1,3 +1,5 @@
+Video stabilization library with plugins for transcode and ffmpeg.
+
 See Install
 
 please visit
diff --git a/Todo b/Todo
index 073dbdc..f386dd9 100644
--- a/Todo
+++ b/Todo
@@ -6,7 +6,3 @@ Some things that could be done
 
 - make transform stage work with fifo file for transforms, such that streaming is also possible with 2-stage version.
 
-- write full motion detection to file and delegate final transformation detection to snd-phase
-
-
-- frei0r plugin
\ No newline at end of file
diff --git a/libavfilter/README b/libavfilter/README
index 9dad132..fef17db 100644
--- a/libavfilter/README
+++ b/libavfilter/README
@@ -1,35 +1,7 @@
-These are filters for the libavfilter framework.
-
-Hopefully they get integrated into ffmpeg but until then you have
- to do the following to get it working:
-link the files to your
-ffmpeg/libavfilter/
-
-also link the vid.stab source directory
-ln -s ...../vid.stab/src ffmpeg/libavfilter/
-
-(for now, to find the include files
-later we have to make an own lib with header files and so on)
-
-add the following lines to the files in libavfilter/
-allfilters.c
-
-    REGISTER_FILTER (STABILIZE,   stabilize,   vf);
-    REGISTER_FILTER (TRANSFORM,   transform,   vf);
-
-Makefile
-
-to OBJS = .... optstr.o
-
-and further down
-OBJS-$(CONFIG_STABILIZE_FILTER)              += vf_stabilize.o
-OBJS-$(CONFIG_TRANSFORM_FILTER)              += vf_transform.o
-
-and
-configure ffmpeg with
-
---extra-libs="-L/path/to/vidstab/src/cmake -lvidstab"
+These files are now in the ffmpeg source tree (as of 25.04.2013). They will be removed here at some point.
 
+Make sure you configure ffmpeg with
+--enable-vidstab
 
 
 
diff --git a/libavfilter/git-workflow.txt b/libavfilter/git-workflow.txt
new file mode 100644
index 0000000..4d786f5
--- /dev/null
+++ b/libavfilter/git-workflow.txt
@@ -0,0 +1,20 @@
+
+#How to work in the ffmpeg git (or in any other one actually)
+#Create a new branch
+git branch "BRANCHNAME"
+git checkout "BRANCHNAME"
+#do you stuff
+git commit
+#rebase to master such that your changes only against the master branch and can be squashed
+git rebase -i master
+#or if merged in between then
+git log
+# or to find original branch point:
+diff -u <(git rev-list --first-parent BRANCHNAME)              <(git rev-list --first-parent master) |      sed -ne 's/^ //p' | head -1
+
+git rebase -i 39423.....
+
+git format-patch -s 3969b4b861ce8152e3195e8f8c3437abd2..
+
+
+007989c7a2215f54aeaf2393ab3aff0c208e862f
diff --git a/libavfilter/optstr.c b/libavfilter/optstr.c
deleted file mode 100644
index ddd4439..0000000
--- a/libavfilter/optstr.c
+++ /dev/null
@@ -1,145 +0,0 @@
-/*
- *  optstr.c
- *
- *  This is a shortened version of the optstr.c file from transcode
- *  Copyright (C) Tilmann Bitterberg 2003
- *
- *  Description: A general purpose option string parser
- *
- *  Usage: see optstr.h, please
- *
- *  This file is part of transcode, a video stream processing tool
- *
- *  transcode is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  transcode is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with GNU Make; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-#ifdef HAVE_CONFIG_H
-# include "config.h"
-#endif
-
-/* for vsscanf */
-#ifdef HAVE_VSSCANF
-#  define _GNU_SOURCE
-#endif
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <stdarg.h>
-#include "optstr.h"
-
-
-// take from transcode
-const char* optstr_lookup(const char *haystack, const char *needle)
-{
-    const char *ch = haystack;
-    int found = 0;
-    size_t len = strlen(needle);
-
-    while (!found) {
-        ch = strstr(ch, needle);
-
-        /* not in string */
-        if (!ch) {
-            break;
-        }
-
-        /* do we want this hit? ie is it exact? */
-        if (ch[len] == '\0' || ch[len] == '=' || ch[len] == ARG_SEP) {
-            found = 1;
-        } else {
-            /* go a little further */
-            ch++;
-        }
-    }
-
-    return ch;
-}
-
-int optstr_get(const char *options, const char *name, const char *fmt, ...)
-{
-    va_list ap;     /* points to each unnamed arg in turn */
-    int num_args = 0, n = 0;
-    size_t pos, fmt_len = strlen(fmt);
-    const char *ch = NULL;
-
-#ifndef HAVE_VSSCANF
-    void *temp[ARG_MAXIMUM];
-#endif
-
-    ch = optstr_lookup(options, name);
-    if (!ch) {
-        return -1;
-    }
-
-    /* name IS in options */
-
-    /* Find how many arguments we expect */
-    for (pos = 0; pos < fmt_len; pos++) {
-        if (fmt[pos] == '%') {
-            ++num_args;
-            /* is this one quoted  with '%%' */
-            if (pos + 1 < fmt_len && fmt[pos + 1] == '%') {
-                --num_args;
-                ++pos;
-            }
-        }
-    }
-
-#ifndef HAVE_VSSCANF
-    if (num_args > ARG_MAXIMUM) {
-        fprintf (stderr,
-            "(%s:%d) Internal Overflow; redefine ARG_MAXIMUM (%d) to something higher\n",
-            __FILE__, __LINE__, ARG_MAXIMUM);
-        return -2;
-    }
-#endif
-
-    n = num_args;
-    /* Bool argument */
-    if (num_args <= 0) {
-        return 0;
-    }
-
-    /* skip the `=' (if it is one) */
-    ch += strlen( name );
-    if( *ch == '=' )
-        ch++;
-
-    if( !*ch )
-        return 0;
-
-    va_start(ap, fmt);
-
-#ifndef HAVE_VSSCANF
-    while (--n >= 0) {
-        temp[num_args - n - 1] = va_arg(ap, void *);
-    }
-
-    n = sscanf(ch, fmt,
-            temp[0],  temp[1],  temp[2],  temp[3]);
-
-#else
-    /* this would be very nice instead of the above,
-     * but it does not seem portable
-     */
-     n = vsscanf(ch, fmt, ap);
-#endif
-
-    va_end(ap);
-
-    return n;
-}
diff --git a/libavfilter/optstr.h b/libavfilter/optstr.h
deleted file mode 100644
index 64cb483..0000000
--- a/libavfilter/optstr.h
+++ /dev/null
@@ -1,57 +0,0 @@
-#ifndef OPTSTR_H
-#define OPTSTR_H
-
-#define ARG_MAXIMUM (4)
-#define ARG_SEP ':'
-#define ARG_CONFIG_LEN 8192
-
-/*
- * optstr_lookup:
- *     Finds the _exact_ 'needle' in 'haystack' (naming intentionally 
- *     identical to the 'strstr' (3) linux man page)
- *
- * Parameters:
- *     needle: substring to be searched
- *     haystack: string which is supposed to contain the substring
- * Return Value:
- *     constant pointer to first substring found, or NULL if substring
- *     isn't found.
- * Side effects:
- *     none
- * Preconditions:
- *     none
- * Postconditions:
- *     none
- */
-const char * optstr_lookup(const char *haystack, const char *needle);
-
-/*
- * optstr_get:
- *     extract values from option string
- *
- * Parameters:
- *     options: a null terminated string of options to parse,
- *              syntax is "opt1=val1:opt_bool:opt2=val1-val2"
- *              where ':' is the seperator.
- *     name: the name to look for in options; eg "opt2"
- *     fmt: the format to scan values (printf format); eg "%d-%d"
- *     (...): variables to assign; eg &lower, &upper
- * Return value:
- *     -2 internal error
- *     -1 `name' is not in `options'
- *     0  `name' is in `options'
- *     >0 number of arguments assigned
- * Side effects:
- *     none
- * Preconditions:
- *     none
- * Postconditions:
- *     none
- */
-int optstr_get(const char *options, const char *name, const char *fmt, ...)
-#ifdef HAVE_GCC_ATTRIBUTES
-__attribute__((format(scanf,3,4)))
-#endif
-;
-
-#endif /* OPTSTR_H */
diff --git a/libavfilter/vf_stabilize.c b/libavfilter/vf_stabilize.c
deleted file mode 100644
index 6596d8d..0000000
--- a/libavfilter/vf_stabilize.c
+++ /dev/null
@@ -1,328 +0,0 @@
-/*
- *  vf_stabilize.c
- *
- *  Copyright (C) Georg Martius - Jan 2012
- *   georg dot martius at web dot de
- *
- *  This file is part of vid.stab, video deshaking lib
- *
- *  vid.stab is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  vid.stab is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with GNU Make; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-/* Typical call:
- *  ffmpeg -i input -vf stabilize=shakiness=5:show=1 dummy.avi
- *  all parameters are optional
- */
-
-
-/*
-  TODO: check AVERROR  codes
-*/
-
-#define DEFAULT_TRANS_FILE_NAME     "transforms.dat"
-#define VS_INPUT_MAXLEN 1024
-
-#include <math.h> //?
-#include <libgen.h> //?
-
-#include "libavutil/avstring.h"
-#include "libavutil/common.h"
-#include "libavutil/mem.h"
-#include "libavutil/pixdesc.h"
-#include "libavutil/pixfmt.h"
-#include "libavutil/imgutils.h"
-#include "libavcodec/dsputil.h"
-#include "avfilter.h"
-#include "formats.h"
-#include "internal.h"
-#include "video.h"
-
-
-#include "optstr.h"
-#include "vid.stab/libvidstab.h"
-
-/* private date structure of this filter*/
-typedef struct _stab_data {
-    AVClass av_class;
-
-    MotionDetect md;
-    AVFilterBufferRef *ref;    ///< Previous frame
-    char* options;
-
-    char* result;
-    FILE* f;
-
-} StabData;
-
-static PixelFormat AV2OurPixelFormat(AVFilterContext *ctx, enum AVPixelFormat pf){
-	switch(pf){
-    case AV_PIX_FMT_YUV420P:  return PF_YUV420P;
-		case AV_PIX_FMT_YUV422P:	return PF_YUV422P;
-		case AV_PIX_FMT_YUV444P:	return PF_YUV444P;
-		case AV_PIX_FMT_YUV410P:	return PF_YUV410P;
-		case AV_PIX_FMT_YUV411P:	return PF_YUV411P;
-		case AV_PIX_FMT_YUV440P:	return PF_YUV440P;
-		case AV_PIX_FMT_YUVA420P: return PF_YUVA420P;
-		case AV_PIX_FMT_GRAY8:		return PF_GRAY8;
-		case AV_PIX_FMT_RGB24:		return PF_RGB24;
-		case AV_PIX_FMT_BGR24:		return PF_BGR24;
-		case AV_PIX_FMT_RGBA:		  return PF_RGBA;
-	default:
-		av_log(ctx, AV_LOG_ERROR, "cannot deal with pixel format %i!\n", pf);
-		return PF_NONE;
-	}
-}
-
-
-/*************************************************************************/
-
-/* Module interface routines and data. */
-
-/*************************************************************************/
-
-static av_cold int init(AVFilterContext *ctx, const char *args)
-{
-
-    StabData* sd = ctx->priv;
-
-    if (!sd) {
-        av_log(ctx, AV_LOG_INFO, "init: out of memory!\n");
-        return AVERROR(EINVAL);
-    }
-
-    av_log(ctx, AV_LOG_INFO, "Stabilize: init %s\n", LIBVIDSTAB_VERSION);
-    if(args)
-        sd->options=av_strdup(args);
-    else
-        sd->options=0;
-
-
-    return 0;
-}
-
-///1
-static av_cold void uninit(AVFilterContext *ctx)
-{
-    StabData *sd = ctx->priv;
-
-    //  avfilter_unref_buffer(sd->ref);
-
-    MotionDetect* md = &(sd->md);
-    if (sd->f) {
-        fclose(sd->f);
-        sd->f = NULL;
-    }
-
-    cleanupMotionDetection(md);
-    if (sd->result) {
-        av_free(sd->result);
-        sd->result = NULL;
-    }
-    if(sd->options) av_free(sd->options);
-}
-
-// AVFILTER_DEFINE_CLASS(stabilize);
-
-static int query_formats(AVFilterContext *ctx)
-{
-    static const enum AVPixelFormat pix_fmts[] = {
-        AV_PIX_FMT_YUV444P,  AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV420P,
-        AV_PIX_FMT_YUV411P,  AV_PIX_FMT_YUV410P, AV_PIX_FMT_YUVA420P,
-        AV_PIX_FMT_YUV440P,  AV_PIX_FMT_GRAY8,
-        AV_PIX_FMT_RGB24, AV_PIX_FMT_BGR24, AV_PIX_FMT_RGBA,
-        AV_PIX_FMT_NONE
-    };
-
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-    return 0;
-}
-
-
-
-
-static int config_input(AVFilterLink *inlink)
-{
-    AVFilterContext *ctx = inlink->dst;
-    StabData *sd = ctx->priv;
-//    char* filenamecopy, *filebasename;
-
-    MotionDetect* md = &(sd->md);
-    VSFrameInfo fi;
-    const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[inlink->format];
-
-    initFrameInfo(&fi,inlink->w, inlink->h, AV2OurPixelFormat(ctx, inlink->format));
-    // check
-    if(fi.bytesPerPixel != av_get_bits_per_pixel(desc)/8)
-        av_log(ctx, AV_LOG_ERROR, "pixel-format error: wrong bits/per/pixel");
-    if(fi.log2ChromaW != desc->log2_chroma_w)
-        av_log(ctx, AV_LOG_ERROR, "pixel-format error: log2_chroma_w");
-    if(fi.log2ChromaH != desc->log2_chroma_h)
-        av_log(ctx, AV_LOG_ERROR, "pixel-format error: log2_chroma_h");
-
-    if(initMotionDetect(md, &fi, "stabilize") != VS_OK){
-        av_log(ctx, AV_LOG_ERROR, "initialization of Motion Detection failed");
-        return AVERROR(EINVAL);
-    }
-
-    /// TODO: find out input name
-    sd->result = av_malloc(VS_INPUT_MAXLEN);
-//    filenamecopy = strndup(sd->vob->video_in_file);
-//    filebasename = basename(filenamecopy);
-//    if (strlen(filebasename) < VS_INPUT_MAXLEN - 4) {
-//        snprintf(sd->result, VS_INPUT_MAXLEN, "%s.trf", filebasename);
-//} else {
-//    av_log(ctx, AV_LOG_WARN, "input name too long, using default `%s'",
-//                    DEFAULT_TRANS_FILE_NAME);
-    snprintf(sd->result, VS_INPUT_MAXLEN, DEFAULT_TRANS_FILE_NAME);
-//    }
-
-    if (sd->options != NULL) {
-        if(optstr_lookup(sd->options, "help")) {
-            av_log(ctx, AV_LOG_INFO, motiondetect_help);
-            return AVERROR(EINVAL);
-        }
-
-        optstr_get(sd->options, "result",     "%[^:]", sd->result);
-        optstr_get(sd->options, "shakiness",  "%d", &md->shakiness);
-        optstr_get(sd->options, "accuracy",   "%d", &md->accuracy);
-        optstr_get(sd->options, "stepsize",   "%d", &md->stepSize);
-        optstr_get(sd->options, "algo",       "%d", &md->algo);
-        optstr_get(sd->options, "mincontrast","%lf",&md->contrastThreshold);
-        optstr_get(sd->options, "show",       "%d", &md->show);
-    }
-
-    if(configureMotionDetect(md)!= VS_OK){
-    	av_log(ctx, AV_LOG_ERROR, "configuration of Motion Detection failed\n");
-        return AVERROR(EINVAL);
-    }
-
-    av_log(ctx, AV_LOG_INFO, "Image Stabilization Settings:\n");
-    av_log(ctx, AV_LOG_INFO, "     shakiness = %d\n", md->shakiness);
-    av_log(ctx, AV_LOG_INFO, "      accuracy = %d\n", md->accuracy);
-    av_log(ctx, AV_LOG_INFO, "      stepsize = %d\n", md->stepSize);
-    av_log(ctx, AV_LOG_INFO, "          algo = %d\n", md->algo);
-    av_log(ctx, AV_LOG_INFO, "   mincontrast = %f\n", md->contrastThreshold);
-    av_log(ctx, AV_LOG_INFO, "          show = %d\n", md->show);
-    av_log(ctx, AV_LOG_INFO, "        result = %s\n", sd->result);
-
-    sd->f = fopen(sd->result, "w");
-    if (sd->f == NULL) {
-        av_log(ctx, AV_LOG_ERROR, "cannot open transform file %s!\n", sd->result);
-        return AVERROR(EINVAL);
-    }else{
-        if(prepareFile(md, sd->f) != VS_OK){
-            av_log(ctx, AV_LOG_ERROR, "cannot write to transform file %s!\n", sd->result);
-            return AVERROR(EINVAL);
-        }
-    }
-    return 0;
-}
-
-
-static int filter_frame(AVFilterLink *inlink, AVFilterBufferRef *in)
-{
-    AVFilterContext *ctx = inlink->dst;
-    StabData *sd = ctx->priv;
-    MotionDetect* md = &(sd->md);
-    LocalMotions localmotions;
-
-
-    AVFilterLink *outlink = inlink->dst->outputs[0];
-    //const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);
-    //int hsub0 = desc->log2_chroma_w;
-    //int vsub0 = desc->log2_chroma_h;
-    int direct = 0;
-    AVFilterBufferRef *out;
-    VSFrame frame;
-    int plane;
-
-    if (in->perms & AV_PERM_WRITE) {
-        direct = 1;
-        out = in;
-    } else {
-        out = ff_get_video_buffer(outlink, AV_PERM_WRITE, outlink->w, outlink->h);
-        if (!out) {
-            avfilter_unref_bufferp(&in);
-            return AVERROR(ENOMEM);
-        }
-        avfilter_copy_buffer_ref_props(out, in);
-    }
-
-    for(plane=0; plane < md->fi.planes; plane++){
-        frame.data[plane] = in->data[plane];
-        frame.linesize[plane] = in->linesize[plane];
-    }
-    if(motionDetection(md, &localmotions, &frame) !=  VS_OK){
-        av_log(ctx, AV_LOG_ERROR, "motion detection failed");
-        return AVERROR(AVERROR_EXTERNAL);
-    } else {
-        if(writeToFile(md, sd->f, &localmotions) != VS_OK){
-            av_log(ctx, AV_LOG_ERROR, "cannot write to transform file!");
-            return AVERROR(EPERM);
-        }
-        vs_vector_del(&localmotions);
-    }
-    if(md->show>0 && !direct){
-        // copy
-        av_image_copy(out->data, out->linesize,
-                      (void*)in->data, in->linesize,
-                      in->format, in->video->w, in->video->h);
-    }
-
-    if (!direct)
-        avfilter_unref_bufferp(&in);
-
-    return ff_filter_frame(outlink, out);
-}
-
-
-AVFilter avfilter_vf_stabilize = {
-    .name      = "stabilize",
-    .description = NULL_IF_CONFIG_SMALL("extracts relative transformations of \n\
-    subsequent frames (used for stabilization together with the\n\
-    transform filter in a second pass)."),
-
-    .priv_size = sizeof(StabData),
-
-    .init   = init,
-    .uninit = uninit,
-    .query_formats = query_formats,
-
-    .inputs    = (const AVFilterPad[]) {{ .name       = "default",
-                                    .type             = AVMEDIA_TYPE_VIDEO,
-                                    .get_video_buffer = ff_null_get_video_buffer,
-                                    .filter_frame     = filter_frame,
-                                    .config_props     = config_input,
-                                    .min_perms        = AV_PERM_READ, },
-                                  { .name = NULL}},
-    .outputs   = (const AVFilterPad[]) {{ .name       = "default",
-                                    .type             = AVMEDIA_TYPE_VIDEO, },
-                                  { .name = NULL}},
-};
-
-
-
-/*************************************************************************/
-
-/*
- * Local variables:
- *   c-file-style: "stroustrup"
- *   c-file-offsets: ((case-label . *) (statement-case-intro . *))
- *   indent-tabs-mode: nil
- * End:
- *
- * vim: expandtab shiftwidth=4:
- */
diff --git a/libavfilter/vf_transform.c b/libavfilter/vf_transform.c
deleted file mode 100644
index d8a7d99..0000000
--- a/libavfilter/vf_transform.c
+++ /dev/null
@@ -1,349 +0,0 @@
-/*
- *  vf_transform.c
- *
- *  Copyright (C) Georg Martius - Jan 2012
- *   georg dot martius at web dot de
- *
- *  This file is part of vid.stab, video deshaking lib
- *
- *  vid.stab is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  vid.stab is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with GNU Make; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- */
-
-/* Typical call:
- *  ffmpeg -i inp.mpeg ffmpeg -vf transform inp_s.mpeg
- *  all parameters are optional
- */
-
-/*
-  TODO: check AVERROR  codes
-*/
-
-#define DEFAULT_TRANS_FILE_NAME     "transforms.dat"
-
-#include "libavutil/common.h"
-#include "libavutil/mem.h"
-#include "libavutil/pixdesc.h"
-#include "libavutil/pixfmt.h"
-#include "libavcodec/dsputil.h"
-#include "avfilter.h"
-#include "formats.h"
-#include "internal.h"
-#include "video.h"
-
-#include "optstr.h"
-
-#include "vid.stab/libvidstab.h"
-
-#define VS_INPUT_MAXLEN 1024
-
-/* private date structure of this filter*/
-typedef struct {
-    TransformData td;
-
-    Transformations trans; // transformations
-    char* options;
-    char input[VS_INPUT_MAXLEN];
-} FilterData;
-
-
-static PixelFormat AV2OurPixelFormat(AVFilterContext *ctx, enum AVPixelFormat pf){
-	switch(pf){
-    case AV_PIX_FMT_YUV420P: return PF_YUV420P;
-		case AV_PIX_FMT_RGB24:		return PF_RGB24;
-		case AV_PIX_FMT_BGR24:		return PF_BGR24;
-		case AV_PIX_FMT_YUV422P:	return PF_YUV422P;
-		case AV_PIX_FMT_YUV444P:	return PF_YUV444P;
-		case AV_PIX_FMT_YUV410P:	return PF_YUV410P;
-		case AV_PIX_FMT_YUV411P:	return PF_YUV411P;
-		case AV_PIX_FMT_GRAY8:		return PF_GRAY8;
-		case AV_PIX_FMT_YUVA420P:return PF_YUVA420P;
-		case AV_PIX_FMT_RGBA:		return PF_RGBA;
-	default:
-		av_log(ctx, AV_LOG_ERROR, "cannot deal with pixel format %i!\n", pf);
-		return PF_NONE;
-	}
-}
-
-
-/*************************************************************************/
-
-/* Module interface routines and data. */
-
-/*************************************************************************/
-
-static av_cold int init(AVFilterContext *ctx, const char *args)
-{
-
-    FilterData* fd = ctx->priv;
-
-    if (!fd) {
-        av_log(ctx, AV_LOG_INFO, "init: out of memory!\n");
-        return AVERROR(EINVAL);
-    }
-
-    av_log(ctx, AV_LOG_INFO, "Transform filter: init %s\n", LIBVIDSTAB_VERSION);
-
-    if(args)
-        fd->options=av_strdup(args);
-
-    return 0;
-}
-
-static av_cold void uninit(AVFilterContext *ctx)
-{
-    FilterData *fd = ctx->priv;
-
-    //  avfilter_unref_buffer(fd->ref);
-
-    cleanupTransformData(&fd->td);
-    cleanupTransformations(&fd->trans);
-
-    if(fd->options) av_free(fd->options);
-}
-
-
-static int query_formats(AVFilterContext *ctx)
-{
-    static const enum AVPixelFormat pix_fmts[] = {
-        AV_PIX_FMT_YUV444P,  AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV420P,
-        AV_PIX_FMT_YUV411P,  AV_PIX_FMT_YUV410P, AV_PIX_FMT_YUVA420P,
-        AV_PIX_FMT_YUV440P,  AV_PIX_FMT_GRAY8,
-        AV_PIX_FMT_RGB24, AV_PIX_FMT_BGR24, AV_PIX_FMT_RGBA,
-        AV_PIX_FMT_NONE
-    };
-
-    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
-    return 0;
-}
-
-
-static int config_input(AVFilterLink *inlink)
-{
-    AVFilterContext *ctx = inlink->dst;
-    FilterData *fd = ctx->priv;
-    FILE* f;
-//    char* filenamecopy, *filebasename;
-
-    const AVPixFmtDescriptor *desc = &av_pix_fmt_descriptors[inlink->format];
-
-    TransformData* td = &(fd->td);
-
-    VSFrameInfo fi_src;
-    VSFrameInfo fi_dest;
-    if(!initFrameInfo(&fi_src, inlink->w, inlink->h,
-                      AV2OurPixelFormat(ctx,inlink->format)) ||
-       !initFrameInfo(&fi_dest, inlink->w, inlink->h,
-                      AV2OurPixelFormat(ctx, inlink->format))){
-        av_log(ctx, AV_LOG_ERROR, "unknown pixel format: %i (%s)",
-               inlink->format, desc->name);
-        return AVERROR(EINVAL);
-    }
-
-    // check
-    if(fi_src.bytesPerPixel != av_get_bits_per_pixel(desc)/8 ||
-       fi_src.log2ChromaW != desc->log2_chroma_w ||
-       fi_src.log2ChromaH != desc->log2_chroma_h){
-        av_log(ctx, AV_LOG_ERROR, "pixel-format error: bpp %i<>%i  ",
-               fi_src.bytesPerPixel, av_get_bits_per_pixel(desc)/8);
-        av_log(ctx, AV_LOG_ERROR, "chroma_subsampl: w: %i<>%i  h: %i<>%i\n",
-               fi_src.log2ChromaW, desc->log2_chroma_w,
-               fi_src.log2ChromaH, desc->log2_chroma_h);
-        return AVERROR(EINVAL);
-    }
-
-    if(initTransformData(td, &fi_src, &fi_dest, "transform") != VS_OK){
-        av_log(ctx, AV_LOG_ERROR, "initialization of TransformData failed\n");
-        return AVERROR(EINVAL);
-    }
-    td->verbose=1; // TODO: get from somewhere
-
-
-    /// TODO: find out input name
-//    fd->input = (char*)av_malloc(VS_INPUT_MAXLEN);
-
-//    filenamecopy = strndup(fd->vob->video_in_file);
-//    filebasename = basename(filenamecopy);
-//    if (strlen(filebasename) < VS_INPUT_MAXLEN - 4) {
-//        snprintf(fd->result, VS_INPUT_MAXLEN, "%s.trf", filebasename);
-//} else {
-//    av_log(ctx, AV_LOG_WARN, "input name too long, using default `%s'",
-//                    DEFAULT_TRANS_FILE_NAME);
-    snprintf(fd->input, VS_INPUT_MAXLEN, DEFAULT_TRANS_FILE_NAME);
-//    }
-
-    if (fd->options != NULL) {
-        if(optstr_lookup(fd->options, "help")) {
-            av_log(ctx, AV_LOG_INFO, transform_help);
-            return AVERROR(EINVAL);
-        }
-
-        optstr_get(fd->options, "input",     "%[^:]", fd->input);
-        optstr_get(fd->options, "maxshift",  "%d", &td->maxShift);
-        optstr_get(fd->options, "maxangle",  "%lf", &td->maxAngle);
-        optstr_get(fd->options, "smoothing", "%d", &td->smoothing);
-        optstr_get(fd->options, "crop"     , "%d", &td->crop);
-        optstr_get(fd->options, "invert"   , "%d", &td->invert);
-        optstr_get(fd->options, "relative" , "%d", &td->relative);
-        optstr_get(fd->options, "zoom"     , "%lf",&td->zoom);
-        optstr_get(fd->options, "optzoom"  , "%d", &td->optZoom);
-        optstr_get(fd->options, "interpol" , "%d", (int*)(&td->interpolType));
-        optstr_get(fd->options, "sharpen"  , "%lf",&td->sharpen);
-        if(optstr_lookup(fd->options, "tripod")){
-            av_log(ctx,AV_LOG_INFO, "Virtual tripod mode: relative=False, smoothing=0");
-            td->relative=0;
-            td->smoothing=0;
-        }
-    }
-
-    if(configureTransformData(td)!= VS_OK){
-    	av_log(ctx, AV_LOG_ERROR, "configuration of Tranform failed\n");
-        return AVERROR(EINVAL);
-    }
-
-    av_log(ctx, AV_LOG_INFO, "Image Transformation/Stabilization Settings:\n");
-    av_log(ctx, AV_LOG_INFO, "    input     = %s\n", fd->input);
-    av_log(ctx, AV_LOG_INFO, "    smoothing = %d\n", td->smoothing);
-    av_log(ctx, AV_LOG_INFO, "    maxshift  = %d\n", td->maxShift);
-    av_log(ctx, AV_LOG_INFO, "    maxangle  = %f\n", td->maxAngle);
-    av_log(ctx, AV_LOG_INFO, "    crop      = %s\n", td->crop ? "Black" : "Keep");
-    av_log(ctx, AV_LOG_INFO, "    relative  = %s\n", td->relative ? "True": "False");
-    av_log(ctx, AV_LOG_INFO, "    invert    = %s\n", td->invert ? "True" : "False");
-    av_log(ctx, AV_LOG_INFO, "    zoom      = %f\n", td->zoom);
-    av_log(ctx, AV_LOG_INFO, "    optzoom   = %s\n", td->optZoom ? "On" : "Off");
-    av_log(ctx, AV_LOG_INFO, "    interpol  = %s\n", interpolTypes[td->interpolType]);
-    av_log(ctx, AV_LOG_INFO, "    sharpen   = %f\n", td->sharpen);
-
-    f = fopen(fd->input, "r");
-    if (f == NULL) {
-        av_log(ctx, AV_LOG_ERROR, "cannot open input file %s!\n", fd->input);
-    } else {
-        ManyLocalMotions mlms;
-        if(readLocalMotionsFile(f,&mlms)==VS_OK){
-            // calculate the actual transforms from the localmotions
-            if(localmotions2TransformsSimple(td, &mlms,&fd->trans)!=VS_OK)
-                av_log(ctx, AV_LOG_ERROR, "calculating transformations failed!\n");
-        }else{ // try to read old format
-            if (!readOldTransforms(td, f, &fd->trans)) { /* read input file */
-                av_log(ctx, AV_LOG_ERROR, "error parsing input file %s!\n", fd->input);
-            }
-        }
-    }
-    fclose(f);
-
-    if (preprocessTransforms(td, &fd->trans)!= VS_OK ) {
-        av_log(ctx, AV_LOG_ERROR, "error while preprocessing transforms\n");
-        return AVERROR(EINVAL);
-    }
-
-    // TODO: add sharpening
-    return 0;
-}
-
-
-static int filter_frame(AVFilterLink *inlink,  AVFilterBufferRef *in)
-{
-    AVFilterContext *ctx = inlink->dst;
-    FilterData *fd = ctx->priv;
-    TransformData* td = &(fd->td);
-
-    AVFilterLink *outlink = inlink->dst->outputs[0];
-    //const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);
-    //int hsub0 = desc->log2_chroma_w;
-    //int vsub0 = desc->log2_chroma_h;
-    int direct = 0;
-    AVFilterBufferRef *out;
-    VSFrame inframe;
-    VSFrame outframe;
-    int plane;
-
-    if (in->perms & AV_PERM_WRITE) {
-        direct = 1;
-        out = in;
-    } else {
-        out = ff_get_video_buffer(outlink, AV_PERM_WRITE, outlink->w, outlink->h);
-        if (!out) {
-            avfilter_unref_bufferp(&in);
-            return AVERROR(ENOMEM);
-        }
-        avfilter_copy_buffer_ref_props(out, in);
-    }
-
-    for(plane=0; plane < td->fiSrc.planes; plane++){
-        inframe.data[plane] = in->data[plane];
-        inframe.linesize[plane] = in->linesize[plane];
-    }
-    for(plane=0; plane < td->fiDest.planes; plane++){
-        outframe.data[plane] = out->data[plane];
-        outframe.linesize[plane] = out->linesize[plane];
-    }
-
-
-    transformPrepare(td, &inframe, &outframe);
-
-    if (fd->td.fiSrc.pFormat > PF_PACKED) {
-        transformRGB(td, getNextTransform(td, &fd->trans));
-    } else {
-        transformYUV(td, getNextTransform(td, &fd->trans));
-    }
-    transformFinish(td);
-
-    if (!direct)
-        avfilter_unref_bufferp(&in);
-
-    return ff_filter_frame(outlink, out);
-}
-
-
-AVFilter avfilter_vf_transform = {
-    .name      = "transform",
-    .description = NULL_IF_CONFIG_SMALL("transforms each frame according to transformations\n\
- given in an input file (e.g. translation, rotate) see also filter stabilize."),
-
-    .priv_size = sizeof(FilterData),
-
-    .init = init,
-    .uninit = uninit,
-    .query_formats = query_formats,
-
-    .inputs    = (const AVFilterPad[]) {
-        { .name       = "default",
-          .type             = AVMEDIA_TYPE_VIDEO,
-          .get_video_buffer = ff_null_get_video_buffer,
-          .filter_frame     = filter_frame,
-          .config_props     = config_input,
-          .min_perms        = AV_PERM_READ | AV_PERM_WRITE,
-        },
-        { .name = NULL}},
-    .outputs   = (const AVFilterPad[]) {
-        { .name             = "default",
-          .type             = AVMEDIA_TYPE_VIDEO, },
-        { .name = NULL}
-    },
-};
-
-
-
-/*************************************************************************/
-
-/*
- * Local variables:
- *   c-file-style: "stroustrup"
- *   c-file-offsets: ((case-label . *) (statement-case-intro . *))
- *   indent-tabs-mode: nil
- * End:
- *
- * vim: expandtab shiftwidth=4:
- */
diff --git a/libavfilter/vf_vidstabdetect.c b/libavfilter/vf_vidstabdetect.c
new file mode 100644
index 0000000..d96ca8e
--- /dev/null
+++ b/libavfilter/vf_vidstabdetect.c
@@ -0,0 +1,218 @@
+/*
+ * Copyright (c) 2013 Georg Martius <georg dot martius at web dot de>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#define DEFAULT_RESULT_NAME     "transforms.trf"
+
+#include <vid.stab/libvidstab.h>
+
+#include "libavutil/common.h"
+#include "libavutil/opt.h"
+#include "libavutil/imgutils.h"
+#include "avfilter.h"
+#include "internal.h"
+
+#include "vidstabutils.h"
+
+typedef struct {
+    const AVClass *class;
+
+    VSMotionDetect md;
+    VSMotionDetectConfig conf;
+
+    char *result;
+    FILE *f;
+} StabData;
+
+
+#define OFFSET(x) offsetof(StabData, x)
+#define OFFSETC(x) (offsetof(StabData, conf)+offsetof(VSMotionDetectConfig, x))
+#define FLAGS AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM
+
+static const AVOption vidstabdetect_options[] = {
+    {"result",      "path to the file used to write the transforms",                 OFFSET(result),             AV_OPT_TYPE_STRING, {.str = DEFAULT_RESULT_NAME}, .flags = FLAGS},
+    {"shakiness",   "how shaky is the video and how quick is the camera?"
+                    " 1: little (fast) 10: very strong/quick (slow)",                OFFSETC(shakiness),         AV_OPT_TYPE_INT,    {.i64 = 5},      1,  10, FLAGS},
+    {"accuracy",    "(>=shakiness) 1: low 15: high (slow)",                          OFFSETC(accuracy),          AV_OPT_TYPE_INT,    {.i64 = 9},      1,  15, FLAGS},
+    {"stepsize",    "region around minimum is scanned with 1 pixel resolution",      OFFSETC(stepSize),          AV_OPT_TYPE_INT,    {.i64 = 6},      1,  32, FLAGS},
+    {"mincontrast", "below this contrast a field is discarded (0-1)",                OFFSETC(contrastThreshold), AV_OPT_TYPE_DOUBLE, {.dbl = 0.25}, 0.0, 1.0, FLAGS},
+    {"show",        "0: draw nothing; 1,2: show fields and transforms",              OFFSETC(show),              AV_OPT_TYPE_INT,    {.i64 = 0},      0,   2, FLAGS},
+    {"tripod",      "virtual tripod mode (if >0): motion is compared to a reference"
+                    " reference frame (frame # is the value)",                       OFFSETC(virtualTripod),     AV_OPT_TYPE_INT,    {.i64 = 0}, 0, INT_MAX, FLAGS},
+    {NULL}
+};
+
+AVFILTER_DEFINE_CLASS(vidstabdetect);
+
+static av_cold int init(AVFilterContext *ctx)
+{
+    StabData *sd = ctx->priv;
+    vs_set_mem_and_log_functions();
+    sd->class = &vidstabdetect_class;
+    av_log(ctx, AV_LOG_VERBOSE, "vidstabdetect filter: init %s\n", LIBVIDSTAB_VERSION);
+    return 0;
+}
+
+static av_cold void uninit(AVFilterContext *ctx)
+{
+    StabData *sd = ctx->priv;
+    VSMotionDetect *md = &(sd->md);
+
+    if (sd->f) {
+        fclose(sd->f);
+        sd->f = NULL;
+    }
+
+    vsMotionDetectionCleanup(md);
+}
+
+static int query_formats(AVFilterContext *ctx)
+{
+    // If you add something here also add it in vidstabutils.c
+    static const enum AVPixelFormat pix_fmts[] = {
+        AV_PIX_FMT_YUV444P,  AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV420P,
+        AV_PIX_FMT_YUV411P,  AV_PIX_FMT_YUV410P, AV_PIX_FMT_YUVA420P,
+        AV_PIX_FMT_YUV440P,  AV_PIX_FMT_GRAY8,
+        AV_PIX_FMT_RGB24, AV_PIX_FMT_BGR24, AV_PIX_FMT_RGBA,
+        AV_PIX_FMT_NONE
+    };
+
+    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
+    return 0;
+}
+
+static int config_input(AVFilterLink *inlink)
+{
+    AVFilterContext *ctx = inlink->dst;
+    StabData *sd = ctx->priv;
+
+    VSMotionDetect* md = &(sd->md);
+    VSFrameInfo fi;
+    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);
+
+    vsFrameInfoInit(&fi, inlink->w, inlink->h, av_2_vs_pixel_format(ctx, inlink->format));
+    if (fi.bytesPerPixel != av_get_bits_per_pixel(desc)/8) {
+        av_log(ctx, AV_LOG_ERROR, "pixel-format error: wrong bits/per/pixel, please report a BUG");
+        return AVERROR(EINVAL);
+    }
+    if (fi.log2ChromaW != desc->log2_chroma_w) {
+        av_log(ctx, AV_LOG_ERROR, "pixel-format error: log2_chroma_w, please report a BUG");
+        return AVERROR(EINVAL);
+    }
+
+    if (fi.log2ChromaH != desc->log2_chroma_h) {
+        av_log(ctx, AV_LOG_ERROR, "pixel-format error: log2_chroma_h, please report a BUG");
+        return AVERROR(EINVAL);
+    }
+
+    // set values that are not initialized by the options
+    sd->conf.algo     = 1;
+    sd->conf.modName  = "vidstabdetect";
+    if (vsMotionDetectInit(md, &sd->conf, &fi) != VS_OK) {
+        av_log(ctx, AV_LOG_ERROR, "initialization of Motion Detection failed, please report a BUG");
+        return AVERROR(EINVAL);
+    }
+
+    vsMotionDetectGetConfig(&sd->conf, md);
+    av_log(ctx, AV_LOG_INFO, "Video stabilization settings (pass 1/2):\n");
+    av_log(ctx, AV_LOG_INFO, "     shakiness = %d\n", sd->conf.shakiness);
+    av_log(ctx, AV_LOG_INFO, "      accuracy = %d\n", sd->conf.accuracy);
+    av_log(ctx, AV_LOG_INFO, "      stepsize = %d\n", sd->conf.stepSize);
+    av_log(ctx, AV_LOG_INFO, "   mincontrast = %f\n", sd->conf.contrastThreshold);
+    av_log(ctx, AV_LOG_INFO, "          show = %d\n", sd->conf.show);
+    av_log(ctx, AV_LOG_INFO, "        result = %s\n", sd->result);
+
+    sd->f = fopen(sd->result, "w");
+    if (sd->f == NULL) {
+        av_log(ctx, AV_LOG_ERROR, "cannot open transform file %s\n", sd->result);
+        return AVERROR(EINVAL);
+    } else {
+        if (vsPrepareFile(md, sd->f) != VS_OK) {
+            av_log(ctx, AV_LOG_ERROR, "cannot write to transform file %s\n", sd->result);
+            return AVERROR(EINVAL);
+        }
+    }
+    return 0;
+}
+
+
+static int filter_frame(AVFilterLink *inlink, AVFrame *in)
+{
+    AVFilterContext *ctx = inlink->dst;
+    StabData *sd = ctx->priv;
+    VSMotionDetect *md = &(sd->md);
+    LocalMotions localmotions;
+
+    AVFilterLink *outlink = inlink->dst->outputs[0];
+    VSFrame frame;
+    int plane;
+
+    if (sd->conf.show > 0 && !av_frame_is_writable(in))
+        av_frame_make_writable(in);
+
+    for (plane = 0; plane < md->fi.planes; plane++) {
+        frame.data[plane] = in->data[plane];
+        frame.linesize[plane] = in->linesize[plane];
+    }
+    if (vsMotionDetection(md, &localmotions, &frame) != VS_OK) {
+        av_log(ctx, AV_LOG_ERROR, "motion detection failed");
+        return AVERROR(AVERROR_EXTERNAL);
+    } else {
+        if (vsWriteToFile(md, sd->f, &localmotions) != VS_OK) {
+            av_log(ctx, AV_LOG_ERROR, "cannot write to transform file");
+            return AVERROR(errno);
+        }
+        vs_vector_del(&localmotions);
+    }
+
+    return ff_filter_frame(outlink, in);
+}
+
+static const AVFilterPad avfilter_vf_vidstabdetect_inputs[] = {
+    {
+        .name             = "default",
+        .type             = AVMEDIA_TYPE_VIDEO,
+        .filter_frame     = filter_frame,
+        .config_props     = config_input,
+    },
+    { NULL }
+};
+
+static const AVFilterPad avfilter_vf_vidstabdetect_outputs[] = {
+    {
+        .name             = "default",
+        .type             = AVMEDIA_TYPE_VIDEO,
+    },
+    { NULL }
+};
+
+AVFilter avfilter_vf_vidstabdetect = {
+    .name          = "vidstabdetect",
+    .description   = NULL_IF_CONFIG_SMALL("Extract relative transformations, "
+                                          "pass 1 of 2 for stabilization "
+                                          "(see vidstabtransform for pass 2)."),
+    .priv_size     = sizeof(StabData),
+    .init          = init,
+    .uninit        = uninit,
+    .query_formats = query_formats,
+
+    .inputs        = avfilter_vf_vidstabdetect_inputs,
+    .outputs       = avfilter_vf_vidstabdetect_outputs,
+    .priv_class    = &vidstabdetect_class,
+};
diff --git a/libavfilter/vf_vidstabtransform.c b/libavfilter/vf_vidstabtransform.c
new file mode 100644
index 0000000..eee3da7
--- /dev/null
+++ b/libavfilter/vf_vidstabtransform.c
@@ -0,0 +1,292 @@
+/*
+ * Copyright (c) 2013 Georg Martius <georg dot martius at web dot de>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#define DEFAULT_INPUT_NAME     "transforms.trf"
+
+#include <vid.stab/libvidstab.h>
+
+#include "libavutil/common.h"
+#include "libavutil/opt.h"
+#include "libavutil/imgutils.h"
+#include "avfilter.h"
+#include "internal.h"
+
+#include "vidstabutils.h"
+
+typedef struct {
+    const AVClass *class;
+
+    VSTransformData td;
+    VSTransformConfig conf;
+
+    VSTransformations trans;    // transformations
+    char *input;                // name of transform file
+    int tripod;
+} TransformContext;
+
+#define OFFSET(x) offsetof(TransformContext, x)
+#define OFFSETC(x) (offsetof(TransformContext, conf)+offsetof(VSTransformConfig, x))
+#define FLAGS AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM
+
+static const AVOption vidstabtransform_options[] = {
+    {"input",     "path to the file storing the transforms",                        OFFSET(input),
+                   AV_OPT_TYPE_STRING, {.str = DEFAULT_INPUT_NAME}, .flags = FLAGS },
+    {"smoothing", "number of frames*2 + 1 used for lowpass filtering",              OFFSETC(smoothing),
+                   AV_OPT_TYPE_INT,    {.i64 = 10},       1, 1000, FLAGS},
+    {"maxshift",  "maximal number of pixels to translate image",                    OFFSETC(maxShift),
+                   AV_OPT_TYPE_INT,    {.i64 = -1},      -1, 500,  FLAGS},
+    {"maxangle",  "maximal angle in rad to rotate image",                           OFFSETC(maxAngle),
+                   AV_OPT_TYPE_DOUBLE, {.dbl = -1.0},  -1.0, 3.14, FLAGS},
+    {"crop",      "set cropping mode",                                              OFFSETC(crop),
+                   AV_OPT_TYPE_INT,    {.i64 = 0},        0, 1,    FLAGS, "crop"},
+    {  "keep",    "keep border",                                                    0,
+                   AV_OPT_TYPE_CONST,  {.i64 = VSKeepBorder }, 0, 0, FLAGS, "crop"},
+    {  "black",   "black border",                                                   0,
+                   AV_OPT_TYPE_CONST,  {.i64 = VSCropBorder }, 0, 0, FLAGS, "crop"},
+    {"invert",    "1: invert transforms",                                           OFFSETC(invert),
+                   AV_OPT_TYPE_INT,    {.i64 = 0},        0, 1,    FLAGS},
+    {"relative",  "consider transforms as 0: absolute, 1: relative",                OFFSETC(relative),
+                   AV_OPT_TYPE_INT,    {.i64 = 1},        0, 1,    FLAGS},
+    {"zoom",      "percentage to zoom >0: zoom in, <0 zoom out",                    OFFSETC(zoom),
+                   AV_OPT_TYPE_DOUBLE, {.dbl = 0},        0, 100,  FLAGS},
+    {"optzoom",   "0: nothing, 1: determine optimal zoom (added to 'zoom')",        OFFSETC(optZoom),
+                   AV_OPT_TYPE_INT,    {.i64 = 1},        0, 1,    FLAGS},
+    {"interpol",  "type of interpolation",                                          OFFSETC(interpolType),
+                   AV_OPT_TYPE_INT,    {.i64 = 2},        0, 3,    FLAGS, "interpol"},
+    {  "no",      "no interpolation",                                               0,
+                   AV_OPT_TYPE_CONST,  {.i64 = VS_Zero  },  0, 0,  FLAGS, "interpol"},
+    {  "linear",  "linear (horizontal)",                                            0,
+                   AV_OPT_TYPE_CONST,  {.i64 = VS_Linear }, 0, 0,  FLAGS, "interpol"},
+    {  "bilinear","bi-linear",                                                      0,
+                   AV_OPT_TYPE_CONST,  {.i64 = VS_BiLinear},0, 0,  FLAGS, "interpol"},
+    {  "bicubic", "bi-cubic",                                                       0,
+                   AV_OPT_TYPE_CONST,  {.i64 = VS_BiCubic },0, 0,  FLAGS, "interpol"},
+    {"tripod",    "if 1: virtual tripod mode (equiv. to relative=0:smoothing=0)",   OFFSET(tripod),
+                   AV_OPT_TYPE_INT,    {.i64 = 0},        0, 1,    FLAGS},
+    {NULL}
+};
+
+AVFILTER_DEFINE_CLASS(vidstabtransform);
+
+static av_cold int init(AVFilterContext *ctx)
+{
+    TransformContext *tc = ctx->priv;
+    vs_set_mem_and_log_functions();
+    tc->class = &vidstabtransform_class;
+    av_log(ctx, AV_LOG_VERBOSE, "vidstabtransform filter: init %s\n", LIBVIDSTAB_VERSION);
+    return 0;
+}
+
+static av_cold void uninit(AVFilterContext *ctx)
+{
+    TransformContext *tc = ctx->priv;
+
+    vsTransformDataCleanup(&tc->td);
+    vsTransformationsCleanup(&tc->trans);
+}
+
+static int query_formats(AVFilterContext *ctx)
+{
+    // If you add something here also add it in vidstabutils.c
+    static const enum AVPixelFormat pix_fmts[] = {
+        AV_PIX_FMT_YUV444P,  AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV420P,
+        AV_PIX_FMT_YUV411P,  AV_PIX_FMT_YUV410P, AV_PIX_FMT_YUVA420P,
+        AV_PIX_FMT_YUV440P,  AV_PIX_FMT_GRAY8,
+        AV_PIX_FMT_RGB24, AV_PIX_FMT_BGR24, AV_PIX_FMT_RGBA,
+        AV_PIX_FMT_NONE
+    };
+
+    ff_set_common_formats(ctx, ff_make_format_list(pix_fmts));
+    return 0;
+}
+
+
+static int config_input(AVFilterLink *inlink)
+{
+    AVFilterContext *ctx = inlink->dst;
+    TransformContext *tc = ctx->priv;
+    FILE *f;
+
+    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);
+
+    VSTransformData *td = &(tc->td);
+
+    VSFrameInfo fi_src;
+    VSFrameInfo fi_dest;
+
+    if (!vsFrameInfoInit(&fi_src, inlink->w, inlink->h,
+                         av_2_vs_pixel_format(ctx, inlink->format)) ||
+        !vsFrameInfoInit(&fi_dest, inlink->w, inlink->h,
+                         av_2_vs_pixel_format(ctx, inlink->format))) {
+        av_log(ctx, AV_LOG_ERROR, "unknown pixel format: %i (%s)",
+               inlink->format, desc->name);
+        return AVERROR(EINVAL);
+    }
+
+    if (fi_src.bytesPerPixel != av_get_bits_per_pixel(desc)/8 ||
+        fi_src.log2ChromaW != desc->log2_chroma_w ||
+        fi_src.log2ChromaH != desc->log2_chroma_h) {
+        av_log(ctx, AV_LOG_ERROR, "pixel-format error: bpp %i<>%i  ",
+               fi_src.bytesPerPixel, av_get_bits_per_pixel(desc)/8);
+        av_log(ctx, AV_LOG_ERROR, "chroma_subsampl: w: %i<>%i  h: %i<>%i\n",
+               fi_src.log2ChromaW, desc->log2_chroma_w,
+               fi_src.log2ChromaH, desc->log2_chroma_h);
+        return AVERROR(EINVAL);
+    }
+
+    // set values that are not initializes by the options
+    tc->conf.modName = "vidstabtransform";
+    tc->conf.verbose =1;
+    if (tc->tripod) {
+        av_log(ctx, AV_LOG_INFO, "Virtual tripod mode: relative=0, smoothing=0");
+        tc->conf.relative  = 0;
+        tc->conf.smoothing = 0;
+    }
+
+    if (vsTransformDataInit(td, &tc->conf, &fi_src, &fi_dest) != VS_OK) {
+        av_log(ctx, AV_LOG_ERROR, "initialization of vid.stab transform failed, please report a BUG\n");
+        return AVERROR(EINVAL);
+    }
+
+    vsTransformGetConfig(&tc->conf, td);
+    av_log(ctx, AV_LOG_INFO, "Video transformation/stabilization settings (pass 2/2):\n");
+    av_log(ctx, AV_LOG_INFO, "    input     = %s\n", tc->input);
+    av_log(ctx, AV_LOG_INFO, "    smoothing = %d\n", tc->conf.smoothing);
+    av_log(ctx, AV_LOG_INFO, "    maxshift  = %d\n", tc->conf.maxShift);
+    av_log(ctx, AV_LOG_INFO, "    maxangle  = %f\n", tc->conf.maxAngle);
+    av_log(ctx, AV_LOG_INFO, "    crop      = %s\n", tc->conf.crop ? "Black" : "Keep");
+    av_log(ctx, AV_LOG_INFO, "    relative  = %s\n", tc->conf.relative ? "True": "False");
+    av_log(ctx, AV_LOG_INFO, "    invert    = %s\n", tc->conf.invert ? "True" : "False");
+    av_log(ctx, AV_LOG_INFO, "    zoom      = %f\n", tc->conf.zoom);
+    av_log(ctx, AV_LOG_INFO, "    optzoom   = %s\n", tc->conf.optZoom ? "On" : "Off");
+    av_log(ctx, AV_LOG_INFO, "    interpol  = %s\n", getInterpolationTypeName(tc->conf.interpolType));
+
+    f = fopen(tc->input, "r");
+    if (f == NULL) {
+        av_log(ctx, AV_LOG_ERROR, "cannot open input file %s\n", tc->input);
+        return AVERROR(errno);
+    } else {
+        VSManyLocalMotions mlms;
+        if (vsReadLocalMotionsFile(f, &mlms) == VS_OK) {
+            // calculate the actual transforms from the local motions
+            if (vsLocalmotions2TransformsSimple(td, &mlms, &tc->trans) != VS_OK) {
+                av_log(ctx, AV_LOG_ERROR, "calculating transformations failed\n");
+                return AVERROR(EINVAL);
+            }
+        } else { // try to read old format
+            if (!vsReadOldTransforms(td, f, &tc->trans)) { /* read input file */
+                av_log(ctx, AV_LOG_ERROR, "error parsing input file %s\n", tc->input);
+                return AVERROR(EINVAL);
+            }
+        }
+    }
+    fclose(f);
+
+    if (vsPreprocessTransforms(td, &tc->trans) != VS_OK ) {
+        av_log(ctx, AV_LOG_ERROR, "error while preprocessing transforms\n");
+        return AVERROR(EINVAL);
+    }
+
+    // TODO: add sharpening, so far the user needs to call the unsharp filter manually
+    return 0;
+}
+
+
+static int filter_frame(AVFilterLink *inlink, AVFrame *in)
+{
+    AVFilterContext *ctx = inlink->dst;
+    TransformContext *tc = ctx->priv;
+    VSTransformData* td = &(tc->td);
+
+    AVFilterLink *outlink = inlink->dst->outputs[0];
+    int direct = 0;
+    AVFrame *out;
+    VSFrame inframe;
+    int plane;
+
+    if (av_frame_is_writable(in)) {
+        direct = 1;
+        out = in;
+    } else {
+        out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
+        if (!out) {
+            av_frame_free(&in);
+            return AVERROR(ENOMEM);
+        }
+        av_frame_copy_props(out, in);
+    }
+
+    for (plane = 0; plane < vsTransformGetSrcFrameInfo(td)->planes; plane++) {
+        inframe.data[plane] = in->data[plane];
+        inframe.linesize[plane] = in->linesize[plane];
+    }
+    if (direct) {
+        vsTransformPrepare(td, &inframe, &inframe);
+    } else { // separate frames
+        VSFrame outframe;
+        for (plane = 0; plane < vsTransformGetDestFrameInfo(td)->planes; plane++) {
+            outframe.data[plane] = out->data[plane];
+            outframe.linesize[plane] = out->linesize[plane];
+        }
+        vsTransformPrepare(td, &inframe, &outframe);
+    }
+
+    vsDoTransform(td, vsGetNextTransform(td, &tc->trans));
+
+    vsTransformFinish(td);
+
+    if (!direct)
+        av_frame_free(&in);
+
+    return ff_filter_frame(outlink, out);
+}
+
+static const AVFilterPad avfilter_vf_vidstabtransform_inputs[] = {
+    {
+        .name             = "default",
+        .type             = AVMEDIA_TYPE_VIDEO,
+        .filter_frame     = filter_frame,
+        .config_props     = config_input,
+    },
+    { NULL }
+};
+
+static const AVFilterPad avfilter_vf_vidstabtransform_outputs[] = {
+    {
+        .name             = "default",
+        .type             = AVMEDIA_TYPE_VIDEO,
+    },
+    { NULL }
+};
+
+AVFilter avfilter_vf_vidstabtransform = {
+    .name          = "vidstabtransform",
+    .description   = NULL_IF_CONFIG_SMALL("Transform the frames, "
+                                          "pass 2 of 2 for stabilization "
+                                          "(see vidstabdetect for pass 1)."),
+    .priv_size     = sizeof(TransformContext),
+    .init          = init,
+    .uninit        = uninit,
+    .query_formats = query_formats,
+
+    .inputs        = avfilter_vf_vidstabtransform_inputs,
+    .outputs       = avfilter_vf_vidstabtransform_outputs,
+    .priv_class    = &vidstabtransform_class,
+};
diff --git a/libavfilter/vidstabutils.c b/libavfilter/vidstabutils.c
new file mode 100644
index 0000000..dd6486d
--- /dev/null
+++ b/libavfilter/vidstabutils.c
@@ -0,0 +1,85 @@
+/*
+ * Copyright (c) 2013 Georg Martius <georg dot martius at web dot de>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "vidstabutils.h"
+
+/** convert AV's pixelformat to vid.stab pixelformat */
+VSPixelFormat av_2_vs_pixel_format(AVFilterContext *ctx, enum AVPixelFormat pf)
+{
+    switch (pf) {
+    case AV_PIX_FMT_YUV420P:  return PF_YUV420P;
+    case AV_PIX_FMT_YUV422P:  return PF_YUV422P;
+    case AV_PIX_FMT_YUV444P:  return PF_YUV444P;
+    case AV_PIX_FMT_YUV410P:  return PF_YUV410P;
+    case AV_PIX_FMT_YUV411P:  return PF_YUV411P;
+    case AV_PIX_FMT_YUV440P:  return PF_YUV440P;
+    case AV_PIX_FMT_YUVA420P: return PF_YUVA420P;
+    case AV_PIX_FMT_GRAY8:    return PF_GRAY8;
+    case AV_PIX_FMT_RGB24:    return PF_RGB24;
+    case AV_PIX_FMT_BGR24:    return PF_BGR24;
+    case AV_PIX_FMT_RGBA:     return PF_RGBA;
+    default:
+        av_log(ctx, AV_LOG_ERROR, "cannot deal with pixel format %i\n", pf);
+        return PF_NONE;
+    }
+}
+
+/** struct to hold a valid context for logging from within vid.stab lib */
+typedef struct {
+    const AVClass *class;
+} VS2AVLogCtx;
+
+/** wrapper to log vs_log into av_log */
+static int vs_2_av_log_wrapper(int type, const char *tag, const char *format, ...)
+{
+    va_list ap;
+    VS2AVLogCtx ctx;
+    AVClass class = {
+      .class_name = tag,
+      .item_name  = av_default_item_name,
+      .option     = 0,
+      .version    = LIBAVUTIL_VERSION_INT,
+      .category   = AV_CLASS_CATEGORY_FILTER,
+    };
+    ctx.class = &class;
+    va_start(ap, format);
+    av_vlog(&ctx, type, format, ap);
+    va_end(ap);
+    return VS_OK;
+}
+
+/** sets the memory allocation function and logging constants to av versions */
+void vs_set_mem_and_log_functions(void)
+{
+    vs_malloc  = av_malloc;
+    vs_zalloc  = av_mallocz;
+    vs_realloc = av_realloc;
+    vs_free    = av_free;
+
+    VS_ERROR_TYPE = AV_LOG_ERROR;
+    VS_WARN_TYPE  = AV_LOG_WARNING;
+    VS_INFO_TYPE  = AV_LOG_INFO;
+    VS_MSG_TYPE   = AV_LOG_VERBOSE;
+
+    vs_log   = vs_2_av_log_wrapper;
+
+    VS_ERROR = 0;
+    VS_OK    = 1;
+}
diff --git a/libavfilter/vidstabutils.h b/libavfilter/vidstabutils.h
new file mode 100644
index 0000000..f1c20e6
--- /dev/null
+++ b/libavfilter/vidstabutils.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2013 Georg Martius <georg dot martius at web dot de>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVFILTER_VIDSTABUTILS_H
+#define AVFILTER_VIDSTABUTILS_H
+
+#include <vid.stab/libvidstab.h>
+
+#include "avfilter.h"
+
+/* ** some conversions from avlib to vid.stab constants and functions *** */
+
+/** converts the pixelformat of avlib into the one of the vid.stab library */
+VSPixelFormat av_2_vs_pixel_format(AVFilterContext *ctx, enum AVPixelFormat pf);
+
+/** sets the memory allocation function and logging constants to av versions */
+void vs_set_mem_and_log_functions(void);
+
+#endif
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 819e91b..1d10db3 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -5,12 +5,20 @@ SET(CMAKE_BUILTTYPE None)
 
 set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_SOURCE_DIR}/../CMakeModules/")
 
-#add_definitions( -Wall -O3 -Wno-pointer-sign -DTESTING )
-add_definitions( -Wall -O3 -Wno-pointer-sign)
-#add_definitions(  -Wall -O0 -g -Wno-pointer-sign )
+include (FindSSE)
+
+set(MAJOR_VERSION 0)
+set(MINOR_VERSION 9)
+set(PATCH_VERSION 6)
+set(VIDSTAB_VERSION ${MAJOR_VERSION}.${MINOR_VERSION}${PATCH_VERSION})
+
+add_definitions( -Wall -O3 -g -Wno-pointer-sign -fPIC )
+# add_definitions(  -Wall -O0 -g -Wno-pointer-sign )
+
+### ORC is not used in any active code at the moment  ###
 # I tried it with 0.4.14
 #  0.4.10 did not work (not all opcode implemented)
-# find_package(Orc)  // it actually not used by any active code
+# find_package(Orc)
 if(ORC_FOUND)
 add_definitions( -DUSE_ORC ${ORC_DEFINITIONS} )
 include_directories( ${ORC_INCLUDE_DIRS} )
@@ -20,15 +28,25 @@ endif()
 
 # here we should check for SSE2
 # our  -DUSE_SSE2_ASM code does not work with fpic
-add_definitions( -fPIC -DUSE_SSE2 -msse2 -ffast-math )
+if(SSE2_FOUND)
+add_definitions( -DUSE_SSE2 -msse2 -ffast-math )
+endif()
 
-# Create the vidstab library
-add_library (vidstab STATIC
-  frameinfo.c transformtype.c libvidstab.c transform.c transformfixedpoint.c
+set(SOURCES frameinfo.c transformtype.c libvidstab.c transform.c transformfixedpoint.c
   motiondetect.c motiondetect_opt.c serialize.c
-	localmotion2transform.c
-	boxblur.c vsvector.c orc/motiondetectorc.c)
-#  orc/transformorc.c
+	localmotion2transform.c boxblur.c vsvector.c orc/motiondetectorc.c)
+
+set(HEADERS frameinfo.h transformtype.h libvidstab.h transform.h
+  motiondetect.h serialize.h localmotion2transform.h boxblur.h vsvector.h )
+
+
+# Create the vidstab library
+# add_library (vidstab STATIC ${SOURCES})
+add_library (vidstab SHARED ${SOURCES})
+
+#set version of lib
+set_target_properties(vidstab PROPERTIES SOVERSION ${MAJOR_VERSION}.${MINOR_VERSION})
+
 
 target_link_libraries(vidstab m)
 if(ORC_FOUND)
@@ -37,3 +55,18 @@ endif()
 if(USE_OMP)
 target_link_libraries(vidstab gomp)
 endif()
+
+
+#if(!NOHEADERS)
+FILE(GLOB HEADERS "${CMAKE_CURRENT_SOURCE_DIR}/*.h")
+INSTALL(FILES ${HEADERS} DESTINATION include/vid.stab)
+#endif()
+
+INSTALL(TARGETS vidstab
+  RUNTIME DESTINATION bin
+  LIBRARY DESTINATION lib
+  ARCHIVE DESTINATION lib
+)
+
+include(create_pkgconfig_file)
+create_pkgconfig_file(vidstab "Vid.Stab, a library for stabilizing video clips")
diff --git a/src/boxblur.c b/src/boxblur.c
index b7a1488..db376fe 100644
--- a/src/boxblur.c
+++ b/src/boxblur.c
@@ -27,9 +27,9 @@
 
 
 void boxblur_hori_C(unsigned char* dest, const unsigned char* src,
-										int width, int height, int dest_strive, int src_strive, int size);
+                    int width, int height, int dest_strive, int src_strive, int size);
 void boxblur_vert_C(unsigned char* dest, const unsigned char* src,
-										int width, int height, int dest_strive, int src_strive, int size);
+                    int width, int height, int dest_strive, int src_strive, int size);
 
 /*
   The algorithm:
@@ -43,74 +43,74 @@ void boxblur_vert_C(unsigned char* dest, const unsigned char* src,
   accumulator: acc = acc + new - old, pixel = acc/size
 */
 
-void boxblurYUV(VSFrame* dest, const VSFrame* src,
-		VSFrame* buffer, const VSFrameInfo* fi,
-		unsigned int size, BoxBlurColorMode colormode){
+void boxblurPlanar(VSFrame* dest, const VSFrame* src,
+    VSFrame* buffer, const VSFrameInfo* fi,
+    unsigned int size, BoxBlurColorMode colormode){
   int localbuffer=0;
   int size2;
   if(size<2){
     if(dest!=src)
-      copyFrame(dest,src,fi);
+      vsFrameCopy(dest,src,fi);
     return;
   }
-	VSFrame buf;
+  VSFrame buf;
   if(buffer==0){
-		allocateFrame(&buf,fi);
-		localbuffer=1;
+    vsFrameAllocate(&buf,fi);
+    localbuffer=1;
   }else{
-		buf = *buffer;
-	}
+    buf = *buffer;
+  }
   // odd and larger than 2 and maximally half of smaller image dimension
   size  = VS_CLAMP((size/2)*2+1,3,VS_MIN(fi->height/2,fi->width/2));
   //printf("%i\n",size);
 
   // luminance
   boxblur_hori_C(buf.data[0],  src->data[0],
-								 fi->width, fi->height, buf.linesize[0],src->linesize[0], size);
+                 fi->width, fi->height, buf.linesize[0],src->linesize[0], size);
   boxblur_vert_C(dest->data[0], buf.data[0],
-								 fi->width, fi->height, dest->linesize[0], buf.linesize[0], size);
-
-	size2 = size/2+1; 	// odd and larger than 0
-	int plane;
-	switch (colormode){
-	case BoxBlurColor:
-		// color
-		if(size2>1){
-			for(plane=1; plane<fi->planes; plane++){
-				boxblur_hori_C(buf.data[plane], src->data[plane],
-											 fi->width  >> getPlaneWidthSubS(fi,plane),
-											 fi->height >> getPlaneHeightSubS(fi,plane),
-											 buf.linesize[plane], src->linesize[plane], size2);
-				boxblur_vert_C(dest->data[plane], buf.data[plane],
-											 fi->width  >> getPlaneWidthSubS(fi,plane),
-											 fi->height >> getPlaneHeightSubS(fi,plane),
-											 dest->linesize[plane], buf.linesize[plane], size2);
-			}
-		}
-		break;
-	case BoxBlurKeepColor:
-		// copy both color channels
-		for(plane=1; plane<fi->planes; plane++){
-			copyFramePlane(dest, src, fi, plane);
-		}
-	case BoxBlurNoColor: // do nothing
-	default:
-		break;
-	}
+                 fi->width, fi->height, dest->linesize[0], buf.linesize[0], size);
+
+  size2 = size/2+1;   // odd and larger than 0
+  int plane;
+  switch (colormode){
+  case BoxBlurColor:
+    // color
+    if(size2>1){
+      for(plane=1; plane<fi->planes; plane++){
+        boxblur_hori_C(buf.data[plane], src->data[plane],
+                       fi->width  >> vsGetPlaneWidthSubS(fi,plane),
+                       fi->height >> vsGetPlaneHeightSubS(fi,plane),
+                       buf.linesize[plane], src->linesize[plane], size2);
+        boxblur_vert_C(dest->data[plane], buf.data[plane],
+                       fi->width  >> vsGetPlaneWidthSubS(fi,plane),
+                       fi->height >> vsGetPlaneHeightSubS(fi,plane),
+                       dest->linesize[plane], buf.linesize[plane], size2);
+      }
+    }
+    break;
+  case BoxBlurKeepColor:
+    // copy both color channels
+    for(plane=1; plane<fi->planes; plane++){
+      vsFrameCopyPlane(dest, src, fi, plane);
+    }
+  case BoxBlurNoColor: // do nothing
+  default:
+    break;
+  }
 
   if(localbuffer)
-    freeFrame(&buf);
+    vsFrameFree(&buf);
 }
 
 /* /\* */
 /*   The algorithm: */
-/*   see boxblurYUV but here we for RGB */
+/*   see boxblurPlanar but here we for Packed */
 
 /*   we add the 3 bytes of one pixel as if they where one number */
 /* *\/ */
-/* void boxblurRGB(const unsigned char* src, unsigned char* dest,  */
-/* 		unsigned char* buffer, const VSFrameInfo* fi,  */
-/* 		unsigned int size){ */
+/* void boxblurPacked(const unsigned char* src, unsigned char* dest,  */
+/*     unsigned char* buffer, const VSFrameInfo* fi,  */
+/*     unsigned int size){ */
 /*   int localbuffer=0; */
 /*   if(buffer==0){ */
 /*     buffer=(unsigned char*) vs_malloc(fi->framesize); */
@@ -120,7 +120,7 @@ void boxblurYUV(VSFrame* dest, const VSFrame* src,
 /*   //  (and not larger than 256, because otherwise we can get an overflow) */
 /*   size  = VS_CLAMP((size/2)*2+1,3,VS_MIN(256,VS_MIN(fi->height/2,fi->width/2)));  */
 
-/*   // we need a different version of these functions for RGB */
+/*   // we need a different version of these functions for Packed */
 /*   boxblur_hori_C(src, buffer, fi->width, fi->height, fi->strive, size);   */
 /*   boxblur_vert_C(buffer, dest, fi->width, fi->height, fi->strive, size); */
 
@@ -130,7 +130,7 @@ void boxblurYUV(VSFrame* dest, const VSFrame* src,
 
 
 void boxblur_hori_C(unsigned char* dest, const unsigned char* src,
-										int width, int height, int dest_strive, int src_strive, int size){
+                    int width, int height, int dest_strive, int src_strive, int size){
 
   int i,j,k;
   unsigned int acc;
@@ -160,7 +160,7 @@ void boxblur_hori_C(unsigned char* dest, const unsigned char* src,
 }
 
 void boxblur_vert_C(unsigned char* dest, const unsigned char* src,
-		    int width, int height, int dest_strive, int src_strive, int size){
+        int width, int height, int dest_strive, int src_strive, int size){
 
   int i,j,k;
   int acc;
diff --git a/src/boxblur.h b/src/boxblur.h
index b341589..3f8fac0 100644
--- a/src/boxblur.h
+++ b/src/boxblur.h
@@ -39,8 +39,8 @@ typedef enum _BoxBlurColorMode { BoxBlurColor, BoxBlurKeepColor, BoxBlurNoColor}
  * @param size of bluring kernel, (min 3 and it is made odd)
  * @param onlyLumincance if true color planes stay untouched
  */
-void boxblurYUV(VSFrame* dest, const VSFrame* src,
-		VSFrame* buffer, const VSFrameInfo* fi,
-		unsigned int size, BoxBlurColorMode colormode);
+void boxblurPlanar(VSFrame* dest, const VSFrame* src,
+    VSFrame* buffer, const VSFrameInfo* fi,
+    unsigned int size, BoxBlurColorMode colormode);
 
 #endif
diff --git a/src/frameinfo.c b/src/frameinfo.c
index 9580d74..36a2c44 100644
--- a/src/frameinfo.c
+++ b/src/frameinfo.c
@@ -25,8 +25,9 @@
 #include "frameinfo.h"
 #include "vidstabdefines.h"
 #include <assert.h>
+#include <string.h>
 
-int initFrameInfo(VSFrameInfo* fi, int width, int height, PixelFormat pFormat){
+int vsFrameInfoInit(VSFrameInfo* fi, int width, int height, VSPixelFormat pFormat){
   fi->pFormat=pFormat;
   fi->width = width;
   fi->height = height;
@@ -82,36 +83,36 @@ int initFrameInfo(VSFrameInfo* fi, int width, int height, PixelFormat pFormat){
   return 1;
 }
 
-int getPlaneWidthSubS(const VSFrameInfo* fi, int plane){
-	return plane == 1 || plane == 2 ? fi->log2ChromaW : 0;
+int vsGetPlaneWidthSubS(const VSFrameInfo* fi, int plane){
+  return plane == 1 || plane == 2 ? fi->log2ChromaW : 0;
 }
 
-int getPlaneHeightSubS(const VSFrameInfo* fi, int plane){
-	return  plane == 1 || plane == 2 ? fi->log2ChromaH : 0;
+int vsGetPlaneHeightSubS(const VSFrameInfo* fi, int plane){
+  return  plane == 1 || plane == 2 ? fi->log2ChromaH : 0;
 }
 
-int isNullFrame(const VSFrame* frame) {
-	return frame==0 || frame->data[0]==0;
+int vsFrameIsNull(const VSFrame* frame) {
+  return frame==0 || frame->data[0]==0;
 }
 
 
-int equalFrames(const VSFrame* frame1,const VSFrame* frame2){
-	return frame1 && frame2 && (frame1==frame2 || frame1->data[0] == frame2->data[0]);
+int vsFramesEqual(const VSFrame* frame1,const VSFrame* frame2){
+  return frame1 && frame2 && (frame1==frame2 || frame1->data[0] == frame2->data[0]);
 }
 
-void nullFrame(VSFrame* frame){
-	memset(frame->data,0,sizeof(uint8_t*)*4);
-	memset(frame->linesize,0,sizeof(int)*4);
+void vsFrameNull(VSFrame* frame){
+  memset(frame->data,0,sizeof(uint8_t*)*4);
+  memset(frame->linesize,0,sizeof(int)*4);
 }
 
-void allocateFrame(VSFrame* frame, const VSFrameInfo* fi){
-	nullFrame(frame);
+void vsFrameAllocate(VSFrame* frame, const VSFrameInfo* fi){
+  vsFrameNull(frame);
   if(fi->pFormat<PF_PACKED){
     int i;
     assert(fi->planes > 0 && fi->planes <= 4);
     for (i=0; i< fi->planes; i++){
-      int w = fi->width  >> getPlaneWidthSubS(fi, i);
-      int h = fi->height >> getPlaneHeightSubS(fi, i);
+      int w = fi->width  >> vsGetPlaneWidthSubS(fi, i);
+      int h = fi->height >> vsGetPlaneHeightSubS(fi, i);
       frame->data[i] = vs_zalloc(w * h * sizeof(uint8_t));
       frame->linesize[i] = w;
       if(frame->data[i]==0)
@@ -128,53 +129,53 @@ void allocateFrame(VSFrame* frame, const VSFrameInfo* fi){
   }
 }
 
-void copyFramePlane(VSFrame* dest, const VSFrame* src,
-										const VSFrameInfo* fi, int plane){
-	assert(src->data[plane]);
-	int h = fi->height >> getPlaneHeightSubS(fi, plane);
-	if(src->linesize[plane] == dest->linesize[plane])
-		memcpy(dest->data[plane], src->data[plane], src->linesize[plane] *  h * sizeof(uint8_t));
-	else {
-		uint8_t* d = dest->data[plane];
-		const uint8_t* s = src->data[plane];
-		int w = fi->width  >> getPlaneWidthSubS(fi, plane);
-		for (; h>0; h++) {
-			memcpy(d,s,sizeof(uint8_t) * w);
-			d += dest->linesize[plane];
-			s += src ->linesize[plane];
-		}
-	}
+void vsFrameCopyPlane(VSFrame* dest, const VSFrame* src,
+                    const VSFrameInfo* fi, int plane){
+  assert(src->data[plane]);
+  int h = fi->height >> vsGetPlaneHeightSubS(fi, plane);
+  if(src->linesize[plane] == dest->linesize[plane])
+    memcpy(dest->data[plane], src->data[plane], src->linesize[plane] *  h * sizeof(uint8_t));
+  else {
+    uint8_t* d = dest->data[plane];
+    const uint8_t* s = src->data[plane];
+    int w = fi->width  >> vsGetPlaneWidthSubS(fi, plane);
+    for (; h>0; h--) {
+      memcpy(d,s,sizeof(uint8_t) * w);
+      d += dest->linesize[plane];
+      s += src ->linesize[plane];
+    }
+  }
 }
 
-void copyFrame(VSFrame* dest, const VSFrame* src, const VSFrameInfo* fi){
-	int plane;
-	assert(fi->planes > 0 && fi->planes <= 4);
-	for (plane=0; plane< fi->planes; plane++){
-		copyFramePlane(dest,src,fi,plane);
-	}
+void vsFrameCopy(VSFrame* dest, const VSFrame* src, const VSFrameInfo* fi){
+  int plane;
+  assert(fi->planes > 0 && fi->planes <= 4);
+  for (plane=0; plane< fi->planes; plane++){
+    vsFrameCopyPlane(dest,src,fi,plane);
+  }
 }
 
-void fillFrameFromBuffer(VSFrame* frame, uint8_t* img, const VSFrameInfo* fi){
+void vsFrameFillFromBuffer(VSFrame* frame, uint8_t* img, const VSFrameInfo* fi){
   assert(fi->planes > 0 && fi->planes <= 4);
-  nullFrame(frame);
+  vsFrameNull(frame);
   long int offset = 0;
   int i;
   for (i=0; i< fi->planes; i++){
-    int w = fi->width  >> getPlaneWidthSubS(fi, i);
-    int h = fi->height >> getPlaneHeightSubS(fi, i);
+    int w = fi->width  >> vsGetPlaneWidthSubS(fi, i);
+    int h = fi->height >> vsGetPlaneHeightSubS(fi, i);
     frame->data[i] = img + offset;
     frame->linesize[i] = w*fi->bytesPerPixel;
     offset += h * w*fi->bytesPerPixel;
   }
 }
 
-void freeFrame(VSFrame* frame){
-	int plane;
-	for (plane=0; plane< 4; plane++){
-		if(frame->data[plane]) vs_free(frame->data[plane]);
-		frame->data[plane]=0;
-		frame->linesize[plane]=0;
-	}
+void vsFrameFree(VSFrame* frame){
+  int plane;
+  for (plane=0; plane< 4; plane++){
+    if(frame->data[plane]) vs_free(frame->data[plane]);
+    frame->data[plane]=0;
+    frame->linesize[plane]=0;
+  }
 }
 
 
diff --git a/src/frameinfo.h b/src/frameinfo.h
index 76a2d61..f48e92e 100644
--- a/src/frameinfo.h
+++ b/src/frameinfo.h
@@ -43,7 +43,7 @@ typedef enum {PF_NONE = -1,
               PF_BGR24,     ///< packed RGB 8:8:8, 24bpp, BGRBGR...
               PF_RGBA,      ///< packed RGBA 8:8:8:8, 32bpp, RGBARGBA...
               PF_NUMBER     ///< number of pixel formats
-} PixelFormat;
+} VSPixelFormat;
 
 /** frame information for deshaking lib
     This only works for planar image formats
@@ -53,7 +53,7 @@ typedef struct vsframeinfo {
   int planes;        // number of planes (1 luma, 2,3 chroma, 4 alpha)
   int log2ChromaW; // subsampling of width in chroma planes
   int log2ChromaH; // subsampling of height in chroma planes
-  PixelFormat pFormat;
+  VSPixelFormat pFormat;
   int bytesPerPixel; // number of bytes per pixel (for packed formats)
 } VSFrameInfo;
 
@@ -68,43 +68,43 @@ typedef struct vsframe {
 #define CHROMA_SIZE(width,log2sub)  (-(-(width) >> (log2sub)))
 
 /// initializes the frameinfo for the given format
-int initFrameInfo(VSFrameInfo* fi, int width, int height, PixelFormat pFormat);
+int vsFrameInfoInit(VSFrameInfo* fi, int width, int height, VSPixelFormat pFormat);
 
 
 /// returns the subsampling shift amount, horizonatally for the given plane
-int getPlaneWidthSubS(const VSFrameInfo* fi, int plane);
+int vsGetPlaneWidthSubS(const VSFrameInfo* fi, int plane);
 
 /// returns the subsampling shift amount, vertically for the given plane
-int getPlaneHeightSubS(const VSFrameInfo* fi, int plane);
+int vsGetPlaneHeightSubS(const VSFrameInfo* fi, int plane);
 
 /// zero initialization
-void nullFrame(VSFrame* frame);
+void vsFrameNull(VSFrame* frame);
 
 /// returns true if frame is null (data[0]==0)
-int isNullFrame(const VSFrame* frame);
+int vsFrameIsNull(const VSFrame* frame);
 
 /// compares two frames for identity (based in data[0])
-int equalFrames(const VSFrame* frame1,const VSFrame* frame2);
+int vsFramesEqual(const VSFrame* frame1,const VSFrame* frame2);
 
 /// allocates memory for a frame
-void allocateFrame(VSFrame* frame, const VSFrameInfo* fi);
+void vsFrameAllocate(VSFrame* frame, const VSFrameInfo* fi);
 
 
 /// copies the given plane number from src to dest
-void copyFramePlane(VSFrame* dest, const VSFrame* src,
-										const VSFrameInfo* fi, int plane);
+void vsFrameCopyPlane(VSFrame* dest, const VSFrame* src,
+                    const VSFrameInfo* fi, int plane);
 
 /// copies src to dest
-void copyFrame(VSFrame* dest, const VSFrame* src, const VSFrameInfo* fi);
+void vsFrameCopy(VSFrame* dest, const VSFrame* src, const VSFrameInfo* fi);
 
 /** fills the data pointer so that it corresponds to the img saved in the linear buffer.
     No copying is performed.
-    Do not call freeFrame() on it.
+    Do not call vsFrameFree() on it.
  */
-void fillFrameFromBuffer(VSFrame* frame, uint8_t* img, const VSFrameInfo* fi);
+void vsFrameFillFromBuffer(VSFrame* frame, uint8_t* img, const VSFrameInfo* fi);
 
 /// frees memory
-void freeFrame(VSFrame* frame);
+void vsFrameFree(VSFrame* frame);
 
 #endif  /* FRAMEINFO_H */
 
diff --git a/src/libvidstab.c b/src/libvidstab.c
index b804f3a..263093b 100644
--- a/src/libvidstab.c
+++ b/src/libvidstab.c
@@ -24,6 +24,50 @@
 
 #include "libvidstab.h"
 
+#include <string.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+/**** default values for memory and logging ****/
+
+/// memory allocation with zero initialization
+void* _zalloc(size_t size){
+    return memset(malloc(size),0,size);
+}
+
+/// logging function
+int _vs_log(int type, const char* tag, const char* format, ...){
+    fprintf(stderr,"%s (%s):",
+            type == VS_ERROR_TYPE ? "Error: " :
+            type == VS_WARN_TYPE  ? "Warn:  " :
+            type == VS_INFO_TYPE  ? "Info:  " :
+            type == VS_MSG_TYPE   ? "Msg:   " : "Unknown",
+            tag);
+    va_list ap;
+    va_start (ap, format);
+    vfprintf (stderr, format, ap);
+    va_end (ap);
+    fprintf(stderr,"\n");
+    return 0;
+}
+
+
+vs_malloc_t vs_malloc   = malloc;
+vs_realloc_t vs_realloc = realloc;
+vs_free_t vs_free       = free;
+vs_zalloc_t vs_zalloc   = _zalloc;
+
+vs_strdup_t vs_strdup   = strdup;
+vs_strndup_t vs_strndup = strndup;
+
+vs_log_t vs_log         = _vs_log;
+int VS_ERROR_TYPE = 0;
+int VS_WARN_TYPE  = 1;
+int VS_INFO_TYPE  = 2;
+int VS_MSG_TYPE   = 3;
+
+int VS_ERROR     = -1;
+int VS_OK        = 0;
 
 /*
  * Local variables:
diff --git a/src/libvidstab.h b/src/libvidstab.h
index 88d960f..8debdf0 100644
--- a/src/libvidstab.h
+++ b/src/libvidstab.h
@@ -25,21 +25,15 @@
 #ifndef LIBVIDSTAB_H
 #define LIBVIDSTAB_H
 
-#define LIBVIDSTAB_VERSION "v0.96 (2013-02-19)"
+#define LIBVIDSTAB_VERSION "v0.961 (2013-04-16)"
 
 #include "frameinfo.h"
 #include "motiondetect.h"
 #include "transform.h"
-#include "boxblur.h"
 #include "vsvector.h"
 #include "serialize.h"
 #include "localmotion2transform.h"
 
-#include "transformfixedpoint.h"
-#ifdef TESTING
-#include "transformfloat.h"
-#endif
-
 #endif  /* LIBVIDSTAB_H_ */
 
 /*
@@ -47,6 +41,8 @@
  *   c-file-style: "stroustrup"
  *   c-file-offsets: ((case-label . *) (statement-case-intro . *))
  *   indent-tabs-mode: nil
+ *   c-basic-offset: 2 t
  * End:
  *
+ * vim: expandtab shiftwidth=2:
  */
diff --git a/src/localmotion2transform.c b/src/localmotion2transform.c
index 601e1ad..4637235 100644
--- a/src/localmotion2transform.c
+++ b/src/localmotion2transform.c
@@ -23,29 +23,30 @@
  */
 
 #include "localmotion2transform.h"
+#include "transformtype_operations.h"
 #include <assert.h>
 
-int localmotions2TransformsSimple(TransformData* td,
-																	const ManyLocalMotions* motions,
-																	Transformations* trans ){
-	int i;
-	int len = vs_vector_size(motions);
-	assert(trans->len==0 && trans->ts == 0);
-	trans->ts = vs_malloc(sizeof(Transform)*len );
-	for(i=0; i< vs_vector_size(motions); i++) {
-		trans->ts[i]=simpleMotionsToTransform(td,MLMGet(motions,i));
-		//    storeLocalmotions(stderr,MLMGet(motions,i));
-		//		storeTransform(stderr,&trans->ts[i]);
-	}
-	trans->len=len;
-	return VS_OK;
+int vsLocalmotions2TransformsSimple(VSTransformData* td,
+                                  const VSManyLocalMotions* motions,
+                                  VSTransformations* trans ){
+  int i;
+  int len = vs_vector_size(motions);
+  assert(trans->len==0 && trans->ts == 0);
+  trans->ts = vs_malloc(sizeof(VSTransform)*len );
+  for(i=0; i< vs_vector_size(motions); i++) {
+    trans->ts[i]=vsSimpleMotionsToTransform(td,VSMLMGet(motions,i));
+    //    vsStoreLocalmotions(stderr,VSMLMGet(motions,i));
+    //    storeTransform(stderr,&trans->ts[i]);
+  }
+  trans->len=len;
+  return VS_OK;
 }
 
 
 /* calculates rotation angle for the given transform and
  * field with respect to the given center-point
  */
-double calcAngle(const LocalMotion* lm, int center_x, int center_y){
+double vsCalcAngle(const LocalMotion* lm, int center_x, int center_y){
   // we better ignore fields that are to close to the rotation center
   if (abs(lm->f.x - center_x) + abs(lm->f.y - center_y) < lm->f.size*2) {
     return 0;
@@ -56,16 +57,16 @@ double calcAngle(const LocalMotion* lm, int center_x, int center_y){
                       lm->f.x - center_x + lm->v.x);
     double diff = a2 - a1;
     return (diff > M_PI) ? diff - 2 * M_PI : ((diff < -M_PI) ? diff + 2
-					      * M_PI : diff);
+                * M_PI : diff);
   }
 }
 
 
-Transform simpleMotionsToTransform(TransformData* td,
+VSTransform vsSimpleMotionsToTransform(VSTransformData* td,
                                    const LocalMotions* motions){
   int center_x = 0;
   int center_y = 0;
-	Transform t = null_transform();
+  VSTransform t = null_transform();
   if(motions==0) return t;
   int num_motions=vs_vector_size(motions);
   double *angles = (double*) vs_malloc(sizeof(double) * num_motions);
@@ -93,14 +94,14 @@ Transform simpleMotionsToTransform(TransformData* td,
     for (i = 0; i < num_motions; i++) {
       // substract avg and calc angle
       LocalMotion m = sub_localmotion(LMGet(motions,i),&meanmotion);
-      angles[i] = calcAngle(&m, center_x, center_y);
+      angles[i] = vsCalcAngle(&m, center_x, center_y);
     }
     double min, max;
     t.alpha = -cleanmean(angles, num_motions, &min, &max);
     if (max - min > td->maxAngleVariation) {
       t.alpha = 0;
-      vs_log_info(td->modName, "too large variation in angle(%f)\n",
-		  max-min);
+      vs_log_info(td->conf.modName, "too large variation in angle(%f)\n",
+      max-min);
     }
   }
   vs_free(angles);
diff --git a/src/localmotion2transform.h b/src/localmotion2transform.h
index cd6b173..6a41e30 100644
--- a/src/localmotion2transform.h
+++ b/src/localmotion2transform.h
@@ -33,21 +33,21 @@
 
 /** converts for each frame the localmotions into a transform
  */
-int localmotions2TransformsSimple(TransformData* td,
-																	const ManyLocalMotions* motions,
-																	Transformations* trans );
+int vsLocalmotions2TransformsSimple(VSTransformData* td,
+                                  const VSManyLocalMotions* motions,
+                                  VSTransformations* trans );
 
 
 /** calculates rotation angle for the given transform and
  * field with respect to the given center-point
  */
-double calcAngle(const LocalMotion* lm, int center_x, int center_y);
+double vsCalcAngle(const LocalMotion* lm, int center_x, int center_y);
 
 /** calculates the transformation that caused the observed motions.
     Using a simple cleaned-means approach to eliminate outliers.
     translation and rotation is calculated.
 */
-Transform simpleMotionsToTransform(TransformData* td,
+VSTransform vsSimpleMotionsToTransform(VSTransformData* td,
                                    const LocalMotions* motions);
 
 #endif
diff --git a/src/motiondetect.c b/src/motiondetect.c
index 749a93e..921230a 100644
--- a/src/motiondetect.c
+++ b/src/motiondetect.c
@@ -25,6 +25,7 @@
  *
  */
 #include "motiondetect.h"
+#include "motiondetect_internal.h"
 #include "motiondetect_opt.h"
 #include <math.h>
 #include <limits.h>
@@ -39,6 +40,10 @@
 #include "boxblur.h"
 #include "vidstabdefines.h"
 #include "localmotion2transform.h"
+#include "transformtype_operations.h"
+
+#define USE_SPIRAL_FIELD_CALC
+
 
 /* internal data structures */
 
@@ -48,104 +53,111 @@ typedef struct _contrast_idx {
   int index;
 } contrast_idx;
 
-int initMotionDetect(MotionDetect* md, const VSFrameInfo* fi,
-		     const char* modName) {
+
+VSMotionDetectConfig vsMotionDetectGetDefaulfConfig(const char* modName){
+  VSMotionDetectConfig conf;
+  conf.stepSize          = 6;
+  conf.algo              = 1;
+  conf.accuracy          = 9;
+  conf.shakiness         = 5;
+  conf.virtualTripod     = 0;
+  conf.contrastThreshold = 0.25;
+  conf.show              = 0;
+  conf.modName           = modName;
+  return conf;
+}
+
+void vsMotionDetectGetConfig(VSMotionDetectConfig* conf, const VSMotionDetect* md){
+  if(md && conf)
+    *conf = md->conf;
+}
+
+const VSFrameInfo* vsMotionDetectGetFrameInfo(const VSMotionDetect* md){
+  return &md->fi;
+}
+
+
+int vsMotionDetectInit(VSMotionDetect* md, const VSMotionDetectConfig* conf, const VSFrameInfo* fi){
   assert(md && fi);
+  md->conf = *conf;
   md->fi = *fi;
-  md->modName = modName;
 
   if(fi->pFormat<=PF_NONE ||  fi->pFormat==PF_PACKED || fi->pFormat>=PF_NUMBER) {
-    vs_log_warn(md->modName, "unsupported Pixel Format (%i)\n",
+    vs_log_warn(md->conf.modName, "unsupported Pixel Format (%i)\n",
                 md->fi.pFormat);
     return VS_ERROR;
   }
 
-  allocateFrame(&md->prev, &md->fi);
-  if (isNullFrame(&md->prev)) {
-    vs_log_error(md->modName, "malloc failed");
+  vsFrameAllocate(&md->prev, &md->fi);
+  if (vsFrameIsNull(&md->prev)) {
+    vs_log_error(md->conf.modName, "malloc failed");
     return VS_ERROR;
   }
 
-  nullFrame(&md->curr);
-  nullFrame(&md->currorig);
-  nullFrame(&md->currtmp);
+  vsFrameNull(&md->curr);
+  vsFrameNull(&md->currorig);
+  vsFrameNull(&md->currtmp);
   md->hasSeenOneFrame = 0;
   md->frameNum = 0;
 
-  // Options
-  md->stepSize  = 6;
-  md->allowMax  = 0;
-  md->algo      = 1;
-  md->accuracy  = 9;
-  md->shakiness = 5;
   md->fieldSize = VS_MIN(md->fi.width, md->fi.height) / 12;
-  md->virtualTripod = 0;
-  md->show = 0;
-  md->contrastThreshold = 0.25;
-  md->initialized = 1;
-  return VS_OK;
-}
-
-int configureMotionDetect(MotionDetect* md) {
-  if (md->initialized != 1)
-    return VS_ERROR;
+  md->allowMax  = 0;
+  md->fieldNum  = 0; // will be set in initFields()
 
-  md->shakiness = VS_MIN(10,VS_MAX(1,md->shakiness));
-  md->accuracy = VS_MIN(15,VS_MAX(1,md->accuracy));
-  if (md->accuracy < md->shakiness / 2) {
-    vs_log_info(md->modName, "Accuracy should not be lower than shakiness/2 -- fixed");
-    md->accuracy = md->shakiness / 2;
+  md->conf.shakiness = VS_MIN(10,VS_MAX(1,md->conf.shakiness));
+  md->conf.accuracy = VS_MIN(15,VS_MAX(1,md->conf.accuracy));
+  if (md->conf.accuracy < md->conf.shakiness / 2) {
+    vs_log_info(md->conf.modName, "Accuracy should not be lower than shakiness/2 -- fixed");
+    md->conf.accuracy = md->conf.shakiness / 2;
   }
-  if (md->accuracy > 9 && md->stepSize > 6) {
-    vs_log_info(md->modName, "For high accuracy use lower stepsize  -- set to 6 now");
-    md->stepSize = 6; // maybe 4
+  if (md->conf.accuracy > 9 && md->conf.stepSize > 6) {
+    vs_log_info(md->conf.modName, "For high accuracy use lower stepsize  -- set to 6 now");
+    md->conf.stepSize = 6; // maybe 4
   }
 
   // shift: shakiness 1: height/40; 10: height/4
   int minDimension = VS_MIN(md->fi.width, md->fi.height);
-  md->maxShift
-    = VS_MAX(4,(minDimension*md->shakiness)/40);
+  md->maxShift = VS_MAX(4,(minDimension*md->conf.shakiness)/40);
   // size: shakiness 1: height/40; 10: height/6 (clipped)
-  md->fieldSize
-    = VS_MAX(4,VS_MIN(minDimension/6, (minDimension*md->shakiness)/40));
+  md->fieldSize = VS_MAX(4,VS_MIN(minDimension/6, (minDimension*md->conf.shakiness)/40));
 
 #if defined(USE_SSE2) || defined(USE_SSE2_ASM)
   md->fieldSize = (md->fieldSize / 16 + 1) * 16;
 #endif
 
-  vs_log_info(md->modName, "Fieldsize: %i, Maximal translation: %i pixel",
-	      md->fieldSize, md->maxShift);
-  if (md->algo == 1) {
+  vs_log_info(md->conf.modName, "Fieldsize: %i, Maximal translation: %i pixel\n",
+              md->fieldSize, md->maxShift);
+  if (md->conf.algo == 1) {
     // initialize measurement fields. field_num is set here.
     if (!initFields(md)) {
       return VS_ERROR;
     }
-    md->maxFields = (md->accuracy) * md->fieldNum / 15;
-    vs_log_info(md->modName, "Number of used measurement fields: %i out of %i",
-		md->maxFields, md->fieldNum);
+    md->maxFields = (md->conf.accuracy) * md->fieldNum / 15;
+    vs_log_info(md->conf.modName, "Number of used measurement fields: %i out of %i\n",
+    md->maxFields, md->fieldNum);
   }
   //  if (md->show)
-  allocateFrame(&md->curr,&md->fi);
-  allocateFrame(&md->currtmp, &md->fi);
+  vsFrameAllocate(&md->curr,&md->fi);
+  vsFrameAllocate(&md->currtmp, &md->fi);
 
   md->initialized = 2;
   return VS_OK;
 }
 
-void cleanupMotionDetection(MotionDetect* md) {
+void vsMotionDetectionCleanup(VSMotionDetect* md) {
   if(md->fields) {
     vs_free(md->fields);
     md->fields=0;
   }
-  freeFrame(&md->prev);
-  freeFrame(&md->curr);
-  freeFrame(&md->currtmp);
+  vsFrameFree(&md->prev);
+  vsFrameFree(&md->curr);
+  vsFrameFree(&md->currtmp);
 
   md->initialized = 0;
 }
 
 
-int motionDetection(MotionDetect* md, LocalMotions* motions, VSFrame *frame) {
+int vsMotionDetection(VSMotionDetect* md, LocalMotions* motions, VSFrame *frame) {
   assert(md->initialized==2);
 
   md->currorig = *frame;
@@ -154,38 +166,38 @@ int motionDetection(MotionDetect* md, LocalMotions* motions, VSFrame *frame) {
   if (md->fi.pFormat > PF_PACKED) {
     // we could calculate a grayscale version and use the PLANAR stuff afterwards
     // so far smoothing is only implemented for PLANAR
-    copyFrame(&md->curr, frame, &md->fi);
+    vsFrameCopy(&md->curr, frame, &md->fi);
   } else {
     // box-kernel smoothing (plain average of pixels), which is fine for us
-    boxblurYUV(&md->curr, frame, &md->currtmp, &md->fi, md->stepSize*1/*1.4*/,
+    boxblurPlanar(&md->curr, frame, &md->currtmp, &md->fi, md->conf.stepSize*1/*1.4*/,
                BoxBlurNoColor);
     // two times yields tent-kernel smoothing, which may be better, but I don't
     //  think we need it
-    //boxblurYUV(md->curr, md->curr, md->currtmp, &md->fi, md->stepSize*1,
+    //boxblurPlanar(md->curr, md->curr, md->currtmp, &md->fi, md->stepSize*1,
     // BoxBlurNoColor);
   }
 
   if (md->hasSeenOneFrame) {
     //    md->curr = frame;
     if (md->fi.pFormat > PF_PACKED) {
-      if (md->algo == 0)
-        *motions = calcShiftRGBSimple(md);
-      else if (md->algo == 1)
-        *motions = calcTransFields(md, calcFieldTransRGB, contrastSubImgRGB);
+      if (md->conf.algo == 0)
+        *motions = calcShiftPackedSimple(md);
+      else if (md->conf.algo == 1)
+        *motions = calcTransFields(md, calcFieldTransPacked, contrastSubImgPacked);
     } else { // PLANAR
-      if (md->algo == 0)
-        *motions = calcShiftYUVSimple(md);
-      else if (md->algo == 1)
-        *motions = calcTransFields(md, calcFieldTransYUV, contrastSubImgYUV);
+      if (md->conf.algo == 0)
+        *motions = calcShiftPlanarSimple(md);
+      else if (md->conf.algo == 1)
+        *motions = calcTransFields(md, calcFieldTransPlanar, contrastSubImgPlanar);
     }
   } else {
     vs_vector_init(motions,md->maxFields);
     md->hasSeenOneFrame = 1;
   }
 
-  if(md->virtualTripod < 1 || md->frameNum < md->virtualTripod)
-  // copy current frame (smoothed) to prev for next frame comparison
-  copyFrame(&md->prev, &md->curr, &md->fi);
+  if(md->conf.virtualTripod < 1 || md->frameNum < md->conf.virtualTripod)
+    // copy current frame (smoothed) to prev for next frame comparison
+    vsFrameCopy(&md->prev, &md->curr, &md->fi);
   md->frameNum++;
   return VS_OK;
 }
@@ -195,7 +207,7 @@ int motionDetection(MotionDetect* md, LocalMotions* motions, VSFrame *frame) {
     The size of the fields and the maxshift is used to
     calculate an optimal distribution in the frame.
 */
-int initFields(MotionDetect* md) {
+int initFields(VSMotionDetect* md) {
   int size = md->fieldSize;
   int rows = VS_MAX(3,(md->fi.height - md->maxShift*2)/size-1);
   int cols = VS_MAX(3,(md->fi.width - md->maxShift*2)/size-1);
@@ -206,14 +218,14 @@ int initFields(MotionDetect* md) {
   //            rows, cols, md->field_num);
 
   if (!(md->fields = (Field*) vs_malloc(sizeof(Field) * md->fieldNum))) {
-    vs_log_error(md->modName, "malloc failed!\n");
+    vs_log_error(md->conf.modName, "malloc failed!\n");
     return 0;
   } else {
     int i, j;
     // the border is the amount by which the field centers
     // have to be away from the image boundary
     // (stepsize is added in case shift is increased through stepsize)
-    int border = size / 2 + md->maxShift + md->stepSize;
+    int border = size / 2 + md->maxShift + md->conf.stepSize;
     int step_x = (md->fi.width - 2 * border) / VS_MAX(cols-1,1);
     int step_y = (md->fi.height - 2 * border) / VS_MAX(rows-1,1);
     for (j = 0; j < rows; j++) {
@@ -289,7 +301,7 @@ unsigned int compareImg(unsigned char* I1, unsigned char* I2, int width, int hei
 
 
 /** \see contrastSubImg*/
-double contrastSubImgYUV(MotionDetect* md, const Field* field) {
+double contrastSubImgPlanar(VSMotionDetect* md, const Field* field) {
 #ifdef USE_SSE2
   return contrastSubImg1_SSE(md->curr.data[0], field, md->curr.linesize[0],md->fi.height);
 #else
@@ -302,7 +314,7 @@ double contrastSubImgYUV(MotionDetect* md, const Field* field) {
    \see contrastSubImg_Michelson three times called with bytesPerPixel=3
    for all channels
 */
-double contrastSubImgRGB(MotionDetect* md, const Field* field) {
+double contrastSubImgPacked(VSMotionDetect* md, const Field* field) {
   unsigned char* const I = md->curr.data[0];
   int linesize2 = md->curr.linesize[0]/3; // linesize in pixels
   return (contrastSubImg(I, field, linesize2, md->fi.height, 3)
@@ -346,7 +358,7 @@ double contrastSubImg(unsigned char* const I, const Field* field, int width,
     shift images to all possible positions and calc summed error
     Shift with minimal error is selected.
 */
-LocalMotions calcShiftRGBSimple(MotionDetect* md) {
+LocalMotions calcShiftPackedSimple(VSMotionDetect* md) {
   LocalMotions localmotions;
   vs_vector_init(&localmotions,1);
   LocalMotion lm;
@@ -380,7 +392,7 @@ LocalMotions calcShiftRGBSimple(MotionDetect* md) {
     shift images to all possible positions and calc summed error
     Shift with minimal error is selected.
 */
-LocalMotions calcShiftYUVSimple(MotionDetect* md) {
+LocalMotions calcShiftPlanarSimple(VSMotionDetect* md) {
   LocalMotions localmotions;
   vs_vector_init(&localmotions,1);
   LocalMotion lm;
@@ -424,17 +436,17 @@ LocalMotions calcShiftYUVSimple(MotionDetect* md) {
   return localmotions;
 }
 
-/* calculates the optimal transformation for one field in YUV frames
+/* calculates the optimal transformation for one field in Planar frames
  * (only luminance)
  */
-LocalMotion calcFieldTransYUV(MotionDetect* md, const Field* field, int fieldnum) {
+LocalMotion calcFieldTransPlanar(VSMotionDetect* md, const Field* field, int fieldnum) {
   int tx = 0;
   int ty = 0;
   uint8_t *Y_c = md->curr.data[0], *Y_p = md->prev.data[0];
   int linesize_c = md->curr.linesize[0], linesize_p = md->prev.linesize[0];
   // we only use the luminance part of the image
   int i, j;
-  int stepSize = md->stepSize;
+  int stepSize = md->conf.stepSize;
 
 #ifdef STABVERBOSE
   // printf("%i %i %f\n", md->frameNum, fieldnum, contr);
@@ -552,13 +564,13 @@ LocalMotion calcFieldTransYUV(MotionDetect* md, const Field* field, int fieldnum
   vs_log_msg(md->modName, "Minerror: %f\n", minerror);
 #endif
 
-  if (!md->allowMax && fabs(tx) >= md->maxShift + md->stepSize) {
+  if (!md->allowMax && fabs(tx) >= md->maxShift + md->conf.stepSize) {
 #ifdef STABVERBOSE
     vs_log_msg(md->modName, "maximal x shift ");
 #endif
     tx = 0;
   }
-  if (!md->allowMax && fabs(ty) == md->maxShift + md->stepSize) {
+  if (!md->allowMax && fabs(ty) == md->maxShift + md->conf.stepSize) {
 #ifdef STABVERBOSE
     vs_log_msg(md->modName, "maximal y shift ");
 #endif
@@ -572,10 +584,10 @@ LocalMotion calcFieldTransYUV(MotionDetect* md, const Field* field, int fieldnum
   return lm;
 }
 
-/* calculates the optimal transformation for one field in RGB
- *   slower than the YUV version because it uses all three color channels
+/* calculates the optimal transformation for one field in Packed
+ *   slower than the Planar version because it uses all three color channels
  */
-LocalMotion calcFieldTransRGB(MotionDetect* md, const Field* field,
+LocalMotion calcFieldTransPacked(VSMotionDetect* md, const Field* field,
                               int fieldnum) {
   int tx = 0;
   int ty = 0;
@@ -583,6 +595,7 @@ LocalMotion calcFieldTransRGB(MotionDetect* md, const Field* field,
   int width1 = md->curr.linesize[0]/3; // linesize in pixels
   int width2 = md->prev.linesize[0]/3; // linesize in pixels
   int i, j;
+  int stepSize = md->conf.stepSize;
 
   /* Here we improve speed by checking first the most probable position
      then the search paths are most effectively cut. (0,0) is a simple start
@@ -590,8 +603,8 @@ LocalMotion calcFieldTransRGB(MotionDetect* md, const Field* field,
   unsigned int minerror = compareSubImg(I_c, I_p, field, width1, width2, md->fi.height,
                                         3, 0, 0, UINT_MAX);
   // check all positions...
-  for (i = -md->maxShift; i <= md->maxShift; i += md->stepSize) {
-    for (j = -md->maxShift; j <= md->maxShift; j += md->stepSize) {
+  for (i = -md->maxShift; i <= md->maxShift; i += stepSize) {
+    for (j = -md->maxShift; j <= md->maxShift; j += stepSize) {
       if( i==0 && j==0 )
         continue; //no need to check this since already done
       unsigned int error = compareSubImg(I_c, I_p, field, width1, width2,
@@ -603,10 +616,10 @@ LocalMotion calcFieldTransRGB(MotionDetect* md, const Field* field,
       }
     }
   }
-  if (md->stepSize > 1) { // make fine grain check around the best match
+  if (stepSize > 1) { // make fine grain check around the best match
     int txc = tx; // save the shifts
     int tyc = ty;
-    int r = md->stepSize - 1;
+    int r = stepSize - 1;
     for (i = txc - r; i <= txc + r; i += 1) {
       for (j = tyc - r; j <= tyc + r; j += 1) {
         if (i == txc && j == tyc)
@@ -622,13 +635,13 @@ LocalMotion calcFieldTransRGB(MotionDetect* md, const Field* field,
     }
   }
 
-  if (!md->allowMax && fabs(tx) >= md->maxShift + md->stepSize) {
+  if (!md->allowMax && fabs(tx) >= md->maxShift + stepSize - 1) {
 #ifdef STABVERBOSE
     vs_log_msg(md->modName, "maximal x shift ");
 #endif
     tx = 0;
   }
-  if (!md->allowMax && fabs(ty) == md->maxShift + md->stepSize) {
+  if (!md->allowMax && fabs(ty) >= md->maxShift + stepSize - 1) {
 #ifdef STABVERBOSE
     vs_log_msg(md->modName, "maximal y shift ");
 #endif
@@ -655,7 +668,7 @@ int cmp_contrast_idx(const void *ci1, const void* ci2) {
    first calc contrasts then select from each part of the
    frame a some fields
 */
-VSVector selectfields(MotionDetect* md, contrastSubImgFunc contrastfunc) {
+VSVector selectfields(VSMotionDetect* md, contrastSubImgFunc contrastfunc) {
   int i, j;
   VSVector goodflds;
   contrast_idx *ci =
@@ -675,7 +688,7 @@ VSVector selectfields(MotionDetect* md, contrastSubImgFunc contrastfunc) {
   for (i = 0; i < md->fieldNum; i++) {
     ci[i].contrast = contrastfunc(md, &md->fields[i]);
     ci[i].index = i;
-    if (ci[i].contrast < md->contrastThreshold)
+    if (ci[i].contrast < md->conf.contrastThreshold)
       ci[i].contrast = 0;
     // else printf("%i %lf\n", ci[i].index, ci[i].contrast);
   }
@@ -735,7 +748,7 @@ VSVector selectfields(MotionDetect* md, contrastSubImgFunc contrastfunc) {
  *   calculate rotation angle as cleaned mean of all angles
  *   compensate for possibly off-center rotation
  */
-LocalMotions calcTransFields(MotionDetect* md,
+LocalMotions calcTransFields(VSMotionDetect* md,
                              calcFieldTransFunc fieldfunc,
                              contrastSubImgFunc contrastfunc) {
   LocalMotions localmotions;
@@ -758,7 +771,7 @@ LocalMotions calcTransFields(MotionDetect* md,
   for(index=0; index < vs_vector_size(&goodflds); index++){
     int i = ((contrast_idx*)vs_vector_get(&goodflds,index))->index;
     LocalMotion m;
-    m = fieldfunc(md, &md->fields[i], i); // e.g. calcFieldTransYUV
+    m = fieldfunc(md, &md->fields[i], i); // e.g. calcFieldTransPlanar
     m.contrast = ((contrast_idx*)vs_vector_get(&goodflds,index))->contrast;
 #ifdef STABVERBOSE
     fprintf(file, "%i %i\n%f %f %f %f\n \n\n", m.f.x, m.f.y,
@@ -772,13 +785,13 @@ LocalMotions calcTransFields(MotionDetect* md,
   num_motions = vs_vector_size(&localmotions); // amount of transforms we actually have
   vs_vector_del(&goodflds);
   if (num_motions < 1) {
-    vs_log_warn(md->modName, "too low contrast! No field remains.\n \
+    vs_log_warn(md->conf.modName, "too low contrast! No field remains.\n \
                     (no translations are detected in frame %i)", md->frameNum);
   }
 
-  if (md->show) { // draw fields and transforms into frame.
+  if (md->conf.show) { // draw fields and transforms into frame.
     // this has to be done one after another to handle possible overlap
-    if (md->show > 1) {
+    if (md->conf.show > 1) {
       for (i = 0; i < num_motions; i++)
         drawFieldScanArea(md, LMGet(&localmotions,i));
     }
@@ -798,7 +811,7 @@ LocalMotions calcTransFields(MotionDetect* md,
 
 
 /** draws the field scanning area */
-void drawFieldScanArea(MotionDetect* md, const LocalMotion* lm) {
+void drawFieldScanArea(VSMotionDetect* md, const LocalMotion* lm) {
   if (md->fi.pFormat > PF_PACKED)
     return;
   drawBox(md->currorig.data[0], md->currorig.linesize[0], md->fi.height, 1, lm->f.x, lm->f.y,
@@ -806,7 +819,7 @@ void drawFieldScanArea(MotionDetect* md, const LocalMotion* lm) {
 }
 
 /** draws the field */
-void drawField(MotionDetect* md, const LocalMotion* lm) {
+void drawField(VSMotionDetect* md, const LocalMotion* lm) {
   if (md->fi.pFormat > PF_PACKED)
     return;
   drawBox(md->currorig.data[0], md->currorig.linesize[0], md->fi.height, 1, lm->f.x, lm->f.y,
@@ -814,7 +827,7 @@ void drawField(MotionDetect* md, const LocalMotion* lm) {
 }
 
 /** draws the transform data of this field */
-void drawFieldTrans(MotionDetect* md, const LocalMotion* lm) {
+void drawFieldTrans(VSMotionDetect* md, const LocalMotion* lm) {
   if (md->fi.pFormat > PF_PACKED)
     return;
   drawBox(md->currorig.data[0], md->currorig.linesize[0], md->fi.height, 1,
@@ -828,7 +841,7 @@ void drawFieldTrans(MotionDetect* md, const LocalMotion* lm) {
  (the same for all channels)
 */
 void drawBox(unsigned char* I, int width, int height, int bytesPerPixel, int x,
-	     int y, int sizex, int sizey, unsigned char color) {
+       int y, int sizex, int sizey, unsigned char color) {
 
   unsigned char* p = NULL;
   int j, k;
@@ -842,18 +855,18 @@ void drawBox(unsigned char* I, int width, int height, int bytesPerPixel, int x,
   }
 }
 
-// void addTrans(MotionDetect* md, Transform sl) {
+// void addTrans(VSMotionDetect* md, VSTransform sl) {
 //   if (!md->transs) {
 //     md->transs = vs_list_new(0);
 //   }
 //   vs_list_append_dup(md->transs, &sl, sizeof(sl));
 // }
 
-// Transform getLastTransform(MotionDetect* md){
+// VSTransform getLastVSTransform(VSMotionDetect* md){
 //   if (!md->transs || !md->transs->head) {
 //     return null_transform();
 //   }
-//   return *((Transform*)md->transs->tail);
+//   return *((VSTransform*)md->transs->tail);
 // }
 
 
@@ -861,8 +874,8 @@ void drawBox(unsigned char* I, int width, int height, int bytesPerPixel, int x,
 /// plain C implementation of compareSubImg (without ORC)
 unsigned int compareSubImg_thr(unsigned char* const I1, unsigned char* const I2,
                                const Field* field, int width1, int width2, int height,
-			     int bytesPerPixel, int d_x, int d_y,
-			     unsigned int threshold) {
+           int bytesPerPixel, int d_x, int d_y,
+           unsigned int threshold) {
   int k, j;
   unsigned char* p1 = NULL;
   unsigned char* p2 = NULL;
diff --git a/src/motiondetect.h b/src/motiondetect.h
index ac225f8..1fabb34 100644
--- a/src/motiondetect.h
+++ b/src/motiondetect.h
@@ -36,58 +36,51 @@
 #include "vsvector.h"
 #include "frameinfo.h"
 
-#define USE_SPIRAL_FIELD_CALC
+typedef struct _vsmotiondetectconfig {
+  /* meta parameter for maxshift and fieldsize between 1 and 15 */
+  int         shakiness;
+  int         accuracy;         // meta parameter for number of fields between 1 and 10
+  int         stepSize;         // stepsize of field transformation detection
+  int         algo;             // algorithm to use
+  /* if >0 then all the frames are compared with the given frame (1 for first) */
+  int         virtualTripod;
+  /* if 1 and 2 then the fields and transforms are shown in the frames */
+  int         show;
+  /* measurement fields with lower contrast are discarded */
+  double      contrastThreshold;
+  const char* modName;          // module name (used for logging)
+} VSMotionDetectConfig;
 
 
 /** data structure for motion detection part of deshaking*/
-typedef struct motiondetect {
+typedef struct _vsmotiondetect {
   VSFrameInfo fi;
 
-  VSFrame curr;     // blurred version of current frame buffer
-  VSFrame currorig; // current frame buffer (original) (only pointer)
-  VSFrame currtmp;  // temporary buffer for blurring
-  VSFrame prev;     // frame buffer for last frame (copied)
-  short hasSeenOneFrame;   // true if we have a valid previous frame
+  VSMotionDetectConfig conf;
 
-  const char* modName;
-
-  Field* fields;
-
-  /* Options */
   /* maximum number of pixels we expect the shift of subsequent frames */
   int maxShift;
-  int stepSize; // stepsize of field transformation detection
-  int allowMax; // 1 if maximal shift is allowed
-  int algo;     // algorithm to use
-  int fieldNum;  // number of measurement fields
-  int maxFields;  // maximum number of fields used (selected by contrast)
-  int fieldSize; // size    = min(md->width, md->height)/10;
-  int fieldRows; // number of rows
-  /* if >0 then all the frames are compared with the given frame (1 for first) */
-  int virtualTripod;
-  /* if 1 and 2 then the fields and transforms are shown in the frames */
-  int show;
-  /* measurement fields with lower contrast are discarded */
-  double contrastThreshold;
-  /* meta parameter for maxshift and fieldsize between 1 and 15 */
-  int shakiness;
-  int accuracy;   // meta parameter for number of fields between 1 and 10
-
-  int initialized; // 1 if initialized and 2 if configured
+  int allowMax;                 // 1 if maximal shift is allowed
+  int fieldNum;                 // number of measurement fields
+  int maxFields;                // maximum number of fields used (selected by contrast)
+  int fieldSize;                // size = min(md->width, md->height)/10;
+  int fieldRows;                // number of rows
+
+  VSFrame curr;                 // blurred version of current frame buffer
+  VSFrame currorig;             // current frame buffer (original) (only pointer)
+  VSFrame currtmp;              // temporary buffer for blurring
+  VSFrame prev;                 // frame buffer for last frame (copied)
+  short hasSeenOneFrame;        // true if we have a valid previous frame
 
-  int frameNum;
-} MotionDetect;
+  Field* fields;
 
-/* type for a function that calculates the transformation of a certain field
- */
-typedef LocalMotion (*calcFieldTransFunc)(MotionDetect*, const Field*, int);
+  int initialized;              // 1 if initialized and 2 if configured
 
-/* type for a function that calculates the contrast of a certain field
- */
-typedef double (*contrastSubImgFunc)(MotionDetect*, const Field*);
+  int frameNum;
+} VSMotionDetect;
 
 
-static const char motiondetect_help[] = ""
+static const char vs_motiondetect_help[] = ""
     "Overview:\n"
     "    Generates a file with relative transform information\n"
     "     (translation, rotation) about subsequent frames."
@@ -96,9 +89,9 @@ static const char motiondetect_help[] = ""
     "    'result'      path to the file used to write the transforms\n"
     "                  (def:inputfile.stab)\n"
     "    'shakiness'   how shaky is the video and how quick is the camera?\n"
-    "                  1: little (fast) 10: very strong/quick (slow) (def: 4)\n"
+    "                  1: little (fast) 10: very strong/quick (slow) (def: 5)\n"
     "    'accuracy'    accuracy of detection process (>=shakiness)\n"
-    "                  1: low (fast) 15: high (slow) (def: 4)\n"
+    "                  1: low (fast) 15: high (slow) (def: 9)\n"
     "    'stepsize'    stepsize of search process, region around minimum \n"
     "                  is scanned with 1 pixel resolution (def: 6)\n"
     "    'algo'        0: brute force (translation only);\n"
@@ -111,16 +104,16 @@ static const char motiondetect_help[] = ""
     "    'help'        print this help message\n";
 
 
-/** initialized the MotionDetect structure and allocates memory
- *  for the frames and stuff
- *  @return VS_OK on success otherwise VS_ERROR
+/** returns the default config
  */
-int initMotionDetect(MotionDetect* md, const VSFrameInfo* fi, const char* modName);
+VSMotionDetectConfig vsMotionDetectGetDefaulfConfig(const char* modName);
 
-/** configures MotionDetect structure and checks ranges, initializes fields and so on.
+/** initialized the VSMotionDetect structure and allocates memory
+ *  for the frames and stuff
  *  @return VS_OK on success otherwise VS_ERROR
  */
-int configureMotionDetect(MotionDetect* md);
+int vsMotionDetectInit(VSMotionDetect* md, const VSMotionDetectConfig* conf,
+                       const VSFrameInfo* fi);
 
 /**
  *  Performs a motion detection step
@@ -128,49 +121,18 @@ int configureMotionDetect(MotionDetect* md);
  *  is stored internally
  *  @param motions: calculated local motions. (must be deleted manually)
  * */
-int motionDetection(MotionDetect* md, LocalMotions* motions, VSFrame *frame);
+int vsMotionDetection(VSMotionDetect* md, LocalMotions* motions, VSFrame *frame);
 
 /** Deletes internal data structures.
- * In order to use the MotionDetect again, you have to call initMotionDetect
+ * In order to use the VSMotionDetect again, you have to call vsMotionDetectInit
  */
-void cleanupMotionDetection(MotionDetect* md);
-
-
-int initFields(MotionDetect* md);
-unsigned int compareImg(unsigned char* I1, unsigned char* I2, int width, int height,
-                        int bytesPerPixel, int strive1, int strive2, int d_x, int d_y);
-
-double contrastSubImgYUV(MotionDetect* md, const Field* field);
-double contrastSubImgRGB(MotionDetect* md, const Field* field);
-double contrastSubImg(unsigned char* const I, const Field* field,
-                      int width, int height, int bytesPerPixel);
-
-
-int cmp_contrast_idx(const void *ci1, const void* ci2);
-VSVector selectfields(MotionDetect* md, contrastSubImgFunc contrastfunc);
-
-LocalMotions calcShiftRGBSimple(MotionDetect* md);
-LocalMotions calcShiftYUVSimple(MotionDetect* md);
-
-LocalMotion calcFieldTransYUV(MotionDetect* md, const Field* field,
-                            int fieldnum);
-LocalMotion calcFieldTransRGB(MotionDetect* md, const Field* field,
-                            int fieldnum);
-LocalMotions calcTransFields(MotionDetect* md, calcFieldTransFunc fieldfunc,
-                             contrastSubImgFunc contrastfunc);
-
-
-void drawFieldScanArea(MotionDetect* md, const LocalMotion* motion);
-void drawField(MotionDetect* md, const LocalMotion* motion);
-void drawFieldTrans(MotionDetect* md, const LocalMotion* motion);
-void drawBox(unsigned char* I, int width, int height, int bytesPerPixel,
-             int x, int y, int sizex, int sizey, unsigned char color);
+void vsMotionDetectionCleanup(VSMotionDetect* md);
 
+/// returns the current config
+void vsMotionDetectGetConfig(VSMotionDetectConfig* conf, const VSMotionDetect* md);
 
-unsigned int compareSubImg_thr(unsigned char* const I1, unsigned char* const I2,
-                               const Field* field, int width1, int width2, int height,
-                               int bytesPerPixel,
-                               int d_x, int d_y, unsigned int threshold);
+/// returns the frame info
+const VSFrameInfo* vsMotionDetectGetFrameInfo(const VSMotionDetect* md);
 
 #endif  /* MOTIONDETECT_H */
 
@@ -179,7 +141,8 @@ unsigned int compareSubImg_thr(unsigned char* const I1, unsigned char* const I2,
  *   c-file-style: "stroustrup"
  *   c-file-offsets: ((case-label . *) (statement-case-intro . *))
  *   indent-tabs-mode: nil
+ *   c-basic-offset: 2 t
  * End:
  *
- * vim: expandtab shiftwidth=4:
+ * vim: expandtab shiftwidth=2:
  */
diff --git a/src/motiondetect_internal.h b/src/motiondetect_internal.h
new file mode 100644
index 0000000..3b71ef4
--- /dev/null
+++ b/src/motiondetect_internal.h
@@ -0,0 +1,89 @@
+/*
+ *  motiondetect_internal.h
+ *
+ *  Copyright (C) Georg Martius - February 2011
+ *   georg dot martius at web dot de
+ *  Copyright (C) Alexey Osipov - Jule 2011
+ *   simba at lerlan dot ru
+ *   speed optimizations (threshold, spiral, SSE, asm)
+ *
+ *  This file is part of vid.stab video stabilization library
+ *
+ *  vid.stab is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License,
+ *  as published by the Free Software Foundation; either version 2, or
+ *  (at your option) any later version.
+ *
+ *  vid.stab is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GNU Make; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+#ifndef MOTIONDETECT_INTERNAL_H
+#define MOTIONDETECT_INTERNAL_H
+
+#include "motiondetect.h"
+
+/* type for a function that calculates the transformation of a certain field
+ */
+typedef LocalMotion (*calcFieldTransFunc)(VSMotionDetect*, const Field*, int);
+
+/* type for a function that calculates the contrast of a certain field
+ */
+typedef double (*contrastSubImgFunc)(VSMotionDetect*, const Field*);
+
+
+int initFields(VSMotionDetect* md);
+unsigned int compareImg(unsigned char* I1, unsigned char* I2, int width, int height,
+                        int bytesPerPixel, int strive1, int strive2, int d_x, int d_y);
+
+double contrastSubImgPlanar(VSMotionDetect* md, const Field* field);
+double contrastSubImgPacked(VSMotionDetect* md, const Field* field);
+double contrastSubImg(unsigned char* const I, const Field* field,
+                      int width, int height, int bytesPerPixel);
+
+
+int cmp_contrast_idx(const void *ci1, const void* ci2);
+VSVector selectfields(VSMotionDetect* md, contrastSubImgFunc contrastfunc);
+
+LocalMotions calcShiftPackedSimple(VSMotionDetect* md);
+LocalMotions calcShiftPlanarSimple(VSMotionDetect* md);
+
+LocalMotion calcFieldTransPlanar(VSMotionDetect* md, const Field* field,
+                            int fieldnum);
+LocalMotion calcFieldTransPacked(VSMotionDetect* md, const Field* field,
+                            int fieldnum);
+LocalMotions calcTransFields(VSMotionDetect* md, calcFieldTransFunc fieldfunc,
+                             contrastSubImgFunc contrastfunc);
+
+
+void drawFieldScanArea(VSMotionDetect* md, const LocalMotion* motion);
+void drawField(VSMotionDetect* md, const LocalMotion* motion);
+void drawFieldTrans(VSMotionDetect* md, const LocalMotion* motion);
+void drawBox(unsigned char* I, int width, int height, int bytesPerPixel,
+             int x, int y, int sizex, int sizey, unsigned char color);
+
+
+unsigned int compareSubImg_thr(unsigned char* const I1, unsigned char* const I2,
+                               const Field* field, int width1, int width2, int height,
+                               int bytesPerPixel,
+                               int d_x, int d_y, unsigned int threshold);
+
+#endif  /* MOTIONDETECT_INTERNAL_H */
+
+/*
+ * Local variables:
+ *   c-file-style: "stroustrup"
+ *   c-file-offsets: ((case-label . *) (statement-case-intro . *))
+ *   indent-tabs-mode: nil
+ *   c-basic-offset: 2 t
+ * End:
+ *
+ * vim: expandtab shiftwidth=2:
+ */
diff --git a/src/motiondetect_opt.c b/src/motiondetect_opt.c
index 5510c84..de63e3b 100644
--- a/src/motiondetect_opt.c
+++ b/src/motiondetect_opt.c
@@ -39,7 +39,7 @@
 
 #ifdef USE_SSE2
 /**
-   \see contrastSubImg using SSE2 optimization, YUV (1 byte per channel) only
+   \see contrastSubImg using SSE2 optimization, Planar (1 byte per channel) only
 */
 double contrastSubImg1_SSE(unsigned char* const I, const Field* field,
                            int width, int height)
@@ -171,9 +171,9 @@ double contrastSubImg_variance_C(unsigned char* const I,
    \param d_y shift in y direction
 */
 unsigned int compareSubImg_thr_orc(unsigned char* const I1, unsigned char* const I2,
-																	 const Field* field, int width1, int width2, int height,
-																	 int bytesPerPixel, int d_x, int d_y,
-																	 unsigned int threshold) {
+                                   const Field* field, int width1, int width2, int height,
+                                   int bytesPerPixel, int d_x, int d_y,
+                                   unsigned int threshold) {
   unsigned char* p1 = NULL;
   unsigned char* p2 = NULL;
   int s2 = field->size / 2;
@@ -198,9 +198,9 @@ unsigned int compareSubImg_thr_orc(unsigned char* const I1, unsigned char* const
 
 // implementation with 1 orc function, but no threshold
 unsigned int compareSubImg_orc(unsigned char* const I1, unsigned char* const I2,
-															 const Field* field, int width1, int width2, int height,
-															 int bytesPerPixel, int d_x, int d_y,
-															 unsigned int threshold) {
+                               const Field* field, int width1, int width2, int height,
+                               int bytesPerPixel, int d_x, int d_y,
+                               unsigned int threshold) {
   unsigned char* p1 = NULL;
   unsigned char* p2 = NULL;
   int s2 = field->size / 2;
@@ -217,12 +217,12 @@ unsigned int compareSubImg_orc(unsigned char* const I1, unsigned char* const I2,
 
 #ifdef USE_SSE2
 unsigned int compareSubImg_thr_sse2(unsigned char* const I1, unsigned char* const I2,
-																		const Field* field,
-																		int width1, int width2, int height,
-																		int bytesPerPixel, int d_x, int d_y,
-																		unsigned int treshold) {
-	int k, j;
-	unsigned char* p1 = NULL;
+                                    const Field* field,
+                                    int width1, int width2, int height,
+                                    int bytesPerPixel, int d_x, int d_y,
+                                    unsigned int treshold) {
+  int k, j;
+  unsigned char* p1 = NULL;
   unsigned char* p2 = NULL;
   int s2 = field->size / 2;
   unsigned int sum = 0;
diff --git a/src/serialize.c b/src/serialize.c
index 603774e..cf167bc 100644
--- a/src/serialize.c
+++ b/src/serialize.c
@@ -23,9 +23,11 @@
  */
 
 #include <assert.h>
+#include <string.h>
 
 #include "serialize.h"
 #include "transformtype.h"
+#include "transformtype_operations.h"
 #include "motiondetect.h"
 
 const char* modname = "vid.stab - serialization";
@@ -53,7 +55,7 @@ LocalMotion restoreLocalmotion(FILE* f){
   return lm;
 }
 
-int storeLocalmotions(FILE* f, const LocalMotions* lms){
+int vsStoreLocalmotions(FILE* f, const LocalMotions* lms){
   int len = vs_vector_size(lms);
   int i;
   fprintf(f,"List %i [",len);
@@ -66,7 +68,7 @@ int storeLocalmotions(FILE* f, const LocalMotions* lms){
 }
 
 /// restores local motions from file
-LocalMotions restoreLocalmotions(FILE* f){
+LocalMotions vsRestoreLocalmotions(FILE* f){
   LocalMotions lms;
   int i;
   char c;
@@ -96,99 +98,98 @@ LocalMotions restoreLocalmotions(FILE* f){
   return lms;
 }
 
-int prepareFile(const MotionDetect* md, FILE* f){
+int vsPrepareFile(const VSMotionDetect* md, FILE* f){
     if(!f) return VS_ERROR;
     fprintf(f, "VID.STAB 1\n");
-		//    fprintf(f, "#      accuracy = %d\n", md->accuracy);
-    fprintf(f, "#      accuracy = %d\n", md->accuracy);
-    fprintf(f, "#     shakiness = %d\n", md->shakiness);
-    fprintf(f, "#      stepsize = %d\n", md->stepSize);
-    fprintf(f, "#          algo = %d\n", md->algo);
-    fprintf(f, "#   mincontrast = %f\n", md->contrastThreshold);
+    fprintf(f, "#      accuracy = %d\n", md->conf.accuracy);
+    fprintf(f, "#     shakiness = %d\n", md->conf.shakiness);
+    fprintf(f, "#      stepsize = %d\n", md->conf.stepSize);
+    fprintf(f, "#          algo = %d\n", md->conf.algo);
+    fprintf(f, "#   mincontrast = %f\n", md->conf.contrastThreshold);
     return VS_OK;
 }
 
-int writeToFile(const MotionDetect* md, FILE* f, const LocalMotions* lms){
-	if(!f || !lms) return VS_ERROR;
+int vsWriteToFile(const VSMotionDetect* md, FILE* f, const LocalMotions* lms){
+  if(!f || !lms) return VS_ERROR;
 
-	if(fprintf(f, "Frame %i (", md->frameNum)>0
-		 && storeLocalmotions(f,lms)>0 && fprintf(f, ")\n"))
-		return VS_OK;
-	else
-		return VS_ERROR;
+  if(fprintf(f, "Frame %i (", md->frameNum)>0
+     && vsStoreLocalmotions(f,lms)>0 && fprintf(f, ")\n"))
+    return VS_OK;
+  else
+    return VS_ERROR;
 }
 
 /// reads the header of the file and return the version number
-int readFileVersion(FILE* f){
-	if(!f) return VS_ERROR;
-	int version;
-	if(fscanf(f, "VID.STAB %i\n", &version)!=1)
-		return VS_ERROR;
-	else return version;
+int vsReadFileVersion(FILE* f){
+  if(!f) return VS_ERROR;
+  int version;
+  if(fscanf(f, "VID.STAB %i\n", &version)!=1)
+    return VS_ERROR;
+  else return version;
 }
 
-int readFromFile(FILE* f, LocalMotions* lms){
-	char c = fgetc(f);
-	if(c=='F') {
-		int num;
-		if(fscanf(f,"rame %i (", &num)!=1) {
-			vs_log_error(modname,"cannot read file, expect 'Frame num (...'");
-			return VS_ERROR;
-		}
-		*lms = restoreLocalmotions(f);
-		if(fscanf(f,")\n")<0) {
-			vs_log_error(modname,"cannot read file, expect '...)'");
-			return VS_ERROR;
-		}
-		return num;
-	} else if(c=='#') {
-		char l[1024];
+int vsReadFromFile(FILE* f, LocalMotions* lms){
+  char c = fgetc(f);
+  if(c=='F') {
+    int num;
+    if(fscanf(f,"rame %i (", &num)!=1) {
+      vs_log_error(modname,"cannot read file, expect 'Frame num (...'");
+      return VS_ERROR;
+    }
+    *lms = vsRestoreLocalmotions(f);
+    if(fscanf(f,")\n")<0) {
+      vs_log_error(modname,"cannot read file, expect '...)'");
+      return VS_ERROR;
+    }
+    return num;
+  } else if(c=='#') {
+    char l[1024];
     if(fgets(l, sizeof(l), f)==0) return VS_ERROR;
-		return readFromFile(f,lms);
-	} else if(c=='\n' || c==' ') {
-		return readFromFile(f,lms);
-	} else if(c==EOF) {
-		return VS_ERROR;
-	} else {
-		vs_log_error(modname,"cannot read frame local motions from file, got %c (%i)",
-								 c, (int) c);
-		return VS_ERROR;
-	}
+    return vsReadFromFile(f,lms);
+  } else if(c=='\n' || c==' ') {
+    return vsReadFromFile(f,lms);
+  } else if(c==EOF) {
+    return VS_ERROR;
+  } else {
+    vs_log_error(modname,"cannot read frame local motions from file, got %c (%i)",
+                 c, (int) c);
+    return VS_ERROR;
+  }
 }
 
-int readLocalMotionsFile(FILE* f, ManyLocalMotions* mlms){
-	int version = readFileVersion(f);
-	if(version<1) // old format or unknown
-		return VS_ERROR;
-	if(version>1){
-		vs_log_error(modname,"Version of VID.STAB file too large: got %i, expect <= 1",
-								 version);
-		return VS_ERROR;
-	}
-	assert(mlms);
-	// initial number of frames, but it will automatically be increaseed
-	vs_vector_init(mlms,1024);
-	int index;
-	int oldindex = 0;
-	LocalMotions lms;
-	while((index = readFromFile(f,&lms)) != VS_ERROR){
-		if(index > oldindex+1){
-			vs_log_info(modname,"VID.STAB file: index of frames is not continuous %i -< %i",
-									oldindex, index);
-		}
-		if(index<1){
-			vs_log_info(modname,"VID.STAB file: Frame number < 1 (%i)", index);
-		} else {
-			vs_vector_set_dup(mlms,index-1,&lms, sizeof(LocalMotions));
-		}
-		oldindex=index;
-	}
-	return VS_OK;
+int vsReadLocalMotionsFile(FILE* f, VSManyLocalMotions* mlms){
+  int version = vsReadFileVersion(f);
+  if(version<1) // old format or unknown
+    return VS_ERROR;
+  if(version>1){
+    vs_log_error(modname,"Version of VID.STAB file too large: got %i, expect <= 1",
+                 version);
+    return VS_ERROR;
+  }
+  assert(mlms);
+  // initial number of frames, but it will automatically be increaseed
+  vs_vector_init(mlms,1024);
+  int index;
+  int oldindex = 0;
+  LocalMotions lms;
+  while((index = vsReadFromFile(f,&lms)) != VS_ERROR){
+    if(index > oldindex+1){
+      vs_log_info(modname,"VID.STAB file: index of frames is not continuous %i -< %i",
+                  oldindex, index);
+    }
+    if(index<1){
+      vs_log_info(modname,"VID.STAB file: Frame number < 1 (%i)", index);
+    } else {
+      vs_vector_set_dup(mlms,index-1,&lms, sizeof(LocalMotions));
+    }
+    oldindex=index;
+  }
+  return VS_OK;
 }
 
 
 /**
- * readOldTransforms: read transforms file (Deprecated format)
+ * vsReadOldTransforms: read transforms file (Deprecated format)
  *  The format is as follows:
  *   Lines with # at the beginning are comments and will be ignored
  *   Data lines have 5 columns seperated by space or tab containing
@@ -203,53 +204,54 @@ int readLocalMotionsFile(FILE* f, ManyLocalMotions* mlms){
  *         number of transforms read
  * Preconditions: f is opened
  */
-int readOldTransforms(const TransformData* td, FILE* f , Transformations* trans)
+int vsReadOldTransforms(const VSTransformData* td, FILE* f , VSTransformations* trans)
 {
-    char l[1024];
-    int s = 0;
-    int i = 0;
-    int ti; // time (ignored)
-    Transform t;
+  char l[1024];
+  int s = 0;
+  int i = 0;
+  int ti; // time (ignored)
+  VSTransform t;
 
-    while (fgets(l, sizeof(l), f)) {
-        if (l[0] == '#')
-            continue;    //  ignore comments
-        if (strlen(l) == 0)
-            continue; //  ignore empty lines
-        // try new format
-        if (sscanf(l, "%i %lf %lf %lf %lf %i", &ti, &t.x, &t.y, &t.alpha,
-                   &t.zoom, &t.extra) != 6) {
-            if (sscanf(l, "%i %lf %lf %lf %i", &ti, &t.x, &t.y, &t.alpha,
-                       &t.extra) != 5) {
-                vs_log_error(td->modName, "Cannot parse line: %s", l);
-                return 0;
-            }
-            t.zoom=0;
-        }
+  while (fgets(l, sizeof(l), f)) {
+    t = null_transform();
+    if (l[0] == '#')
+      continue;    //  ignore comments
+    if (strlen(l) == 0)
+      continue; //  ignore empty lines
+    // try new format
+    if (sscanf(l, "%i %lf %lf %lf %lf %i", &ti, &t.x, &t.y, &t.alpha,
+               &t.zoom, &t.extra) != 6) {
+      if (sscanf(l, "%i %lf %lf %lf %i", &ti, &t.x, &t.y, &t.alpha,
+                 &t.extra) != 5) {
+        vs_log_error(td->conf.modName, "Cannot parse line: %s", l);
+        return 0;
+      }
+      t.zoom=0;
+    }
 
-        if (i>=s) { // resize transform array
-            if (s == 0)
-                s = 256;
-            else
-                s*=2;
-            /* vs_log_info(td->modName, "resize: %i\n", s); */
-            trans->ts = vs_realloc(trans->ts, sizeof(Transform)* s);
-            if (!trans->ts) {
-                vs_log_error(td->modName, "Cannot allocate memory"
-                                       " for transformations: %i\n", s);
-                return 0;
-            }
-        }
-        trans->ts[i] = t;
-        i++;
+    if (i>=s) { // resize transform array
+      if (s == 0)
+        s = 256;
+      else
+        s*=2;
+      /* vs_log_info(td->modName, "resize: %i\n", s); */
+      trans->ts = vs_realloc(trans->ts, sizeof(VSTransform)* s);
+      if (!trans->ts) {
+        vs_log_error(td->conf.modName, "Cannot allocate memory"
+                     " for transformations: %i\n", s);
+        return 0;
+      }
     }
-    trans->len = i;
+    trans->ts[i] = t;
+    i++;
+  }
+  trans->len = i;
 
-    return i;
+  return i;
 }
 
 
-//     t = simpleMotionsToTransform(md, &localmotions);
+//     t = vsSimpleMotionsToTransform(md, &localmotions);
 
 
 /*
diff --git a/src/serialize.h b/src/serialize.h
index 9018306..2142a7d 100644
--- a/src/serialize.h
+++ b/src/serialize.h
@@ -31,33 +31,33 @@
 
 
 /// Vector of LocalMotions
-typedef VSVector ManyLocalMotions;
+typedef VSVector VSManyLocalMotions;
 /// helper macro to access a localmotions vector in the VSVector of all Frames
-#define MLMGet(manylocalmotions,index) \
+#define VSMLMGet(manylocalmotions,index) \
     ((LocalMotions*)vs_vector_get(manylocalmotions,index))
 
 
 /// stores local motions to file
-int storeLocalmotions(FILE* f, const LocalMotions* lms);
+int vsStoreLocalmotions(FILE* f, const LocalMotions* lms);
 
 /// restores local motions from file
-LocalMotions restoreLocalmotions(FILE* f);
+LocalMotions vsRestoreLocalmotions(FILE* f);
 
 
 /// writes the header to the file that is to be holding the local motions
-int prepareFile(const MotionDetect* td, FILE* f);
+int vsPrepareFile(const VSMotionDetect* td, FILE* f);
 
 /// appends the given localmotions to the file
-int writeToFile(const MotionDetect* td, FILE* f, const LocalMotions* lms);
+int vsWriteToFile(const VSMotionDetect* td, FILE* f, const LocalMotions* lms);
 
 /// reads the header of the file and return the version number (used by readLocalmotionsFile)
-int readFileVersion(FILE* f);
+int vsReadFileVersion(FILE* f);
 
 /*
  * reads the next set of localmotions from the file, return VS_ERROR on error or
  * if nothing is read (used by readLocalmotionsFile)
  */
-int readFromFile(FILE* f, LocalMotions* lms);
+int vsReadFromFile(FILE* f, LocalMotions* lms);
 
 /*
  * reads the entire file of localmotions, return VS_ERROR on error or if nothing is read
@@ -68,10 +68,10 @@ int readFromFile(FILE* f, LocalMotions* lms);
  *   Data lines have the structure: Frame NUM (<LocalMotions>)
  *   where LocalMotions ::= List [(LM v.x v.y f.x f.y f.size contrast match),...]
  */
-int readLocalMotionsFile(FILE* f, ManyLocalMotions* lms);
+int vsReadLocalMotionsFile(FILE* f, VSManyLocalMotions* lms);
 
 // read the transformations from the given file (Deprecated format)
-int readOldTransforms(const TransformData* td, FILE* f , Transformations* trans);
+int vsReadOldTransforms(const VSTransformData* td, FILE* f , VSTransformations* trans);
 
 
 #endif
diff --git a/src/transform.c b/src/transform.c
index 7e7a9e0..bb02f53 100644
--- a/src/transform.c
+++ b/src/transform.c
@@ -23,6 +23,8 @@
  */
 
 #include "transform.h"
+#include "transform_internal.h"
+#include "transformtype_operations.h"
 
 #include "transformfixedpoint.h"
 #ifdef TESTING
@@ -31,159 +33,185 @@
 
 #include <math.h>
 #include <libgen.h>
+#include <string.h>
 
-const char* interpolTypes[5] = {"No (0)", "Linear (1)", "Bi-Linear (2)",
-                                "Bi-Cubic (3)"};
+const char* interpol_type_names[5] = {"No (0)", "Linear (1)", "Bi-Linear (2)",
+                                      "Bi-Cubic (3)"};
 
+const char* getInterpolationTypeName(VSInterpolType type){
+  if (type >= VS_Zero && type < VS_NBInterPolTypes)
+    return interpol_type_names[(int) type];
+  else
+    return "unknown";
+}
 
-int initTransformData(TransformData* td, const VSFrameInfo* fi_src,
-                      const VSFrameInfo* fi_dest , const char* modName){
-    td->modName = modName;
+VSTransformConfig vsTransformGetDefaulfConfig(const char* modName){
+  VSTransformConfig conf;
+  /* Options */
+  conf.maxShift           = -1;
+  conf.maxAngle           = -1;
+  conf.crop               = VSKeepBorder;
+  conf.relative           = 1;
+  conf.invert             = 0;
+  conf.smoothing          = 10;
+  conf.zoom               = 0;
+  conf.optZoom            = 1;
+  conf.interpolType       = VS_BiLinear;
+  conf.verbose            = 0;
+  conf.modName            = modName;
+  return conf;
+}
 
-    td->fiSrc = *fi_src;
-    td->fiDest = *fi_dest;
+void vsTransformGetConfig(VSTransformConfig* conf, const VSTransformData* td){
+  if(td && conf)
+    *conf = td->conf;
+}
 
-    nullFrame(&td->src);
-    td->srcMalloced = 0;
+const VSFrameInfo* vsTransformGetSrcFrameInfo(const VSTransformData* td){
+  return &td->fiSrc;
+}
 
-    nullFrame(&td->destbuf);
-    nullFrame(&td->dest);
+const VSFrameInfo* vsTransformGetDestFrameInfo(const VSTransformData* td){
+  return &td->fiDest;
+}
 
-    /* Options */
-    td->maxShift = -1;
-    td->maxAngle = -1;
-    td->maxAngleVariation = 1;
 
+int vsTransformDataInit(VSTransformData* td, const VSTransformConfig* conf,
+                        const VSFrameInfo* fi_src, const VSFrameInfo* fi_dest){
+  td->conf = *conf;
 
-    td->crop = KeepBorder;
-    td->relative = 1;
-    td->invert = 0;
-    td->smoothing = 10;
+  td->fiSrc = *fi_src;
+  td->fiDest = *fi_dest;
 
-    td->rotationThreshhold = 0.25/(180/M_PI);
+  vsFrameNull(&td->src);
+  td->srcMalloced = 0;
 
-    td->zoom    = 0;
-    td->optZoom = 1;
-    td->interpolType = BiLinear;
-    td->sharpen = 0.8;
+  vsFrameNull(&td->destbuf);
+  vsFrameNull(&td->dest);
 
-    td->verbose = 0;
-    return VS_OK;
-}
+  td->maxAngleVariation  = 1;
+  td->rotationThreshhold = 0.25/(180/M_PI);
 
-int configureTransformData(TransformData* td){
-    if (td->maxShift > td->fiDest.width/2)
-        td->maxShift = td->fiDest.width/2;
-    if (td->maxShift > td->fiDest.height/2)
-        td->maxShift = td->fiDest.height/2;
+  if (td->conf.maxShift > td->fiDest.width/2)
+    td->conf.maxShift = td->fiDest.width/2;
+  if (td->conf.maxShift > td->fiDest.height/2)
+    td->conf.maxShift = td->fiDest.height/2;
 
-    td->interpolType = VS_MAX(VS_MIN(td->interpolType,BiCubic),Zero);
+  td->conf.interpolType = VS_MAX(VS_MIN(td->conf.interpolType,VS_BiCubic),VS_Zero);
 
-    switch(td->interpolType){
-      case Zero:     td->interpolate = &interpolateZero; break;
-      case Linear:   td->interpolate = &interpolateLin; break;
-      case BiLinear: td->interpolate = &interpolateBiLin; break;
-      case BiCubic:  td->interpolate = &interpolateBiCub; break;
-      default: td->interpolate = &interpolateBiLin;
-    }
+  switch(td->conf.interpolType){
+   case VS_Zero:     td->interpolate = &interpolateZero; break;
+   case VS_Linear:   td->interpolate = &interpolateLin; break;
+   case VS_BiLinear: td->interpolate = &interpolateBiLin; break;
+   case VS_BiCubic:  td->interpolate = &interpolateBiCub; break;
+   default: td->interpolate = &interpolateBiLin;
+  }
 #ifdef TESTING
-    switch(td->interpolType){
-      case Zero:     td->_FLT(interpolate) = &_FLT(interpolateZero); break;
-      case Linear:   td->_FLT(interpolate) = &_FLT(interpolateLin); break;
-      case BiLinear: td->_FLT(interpolate) = &_FLT(interpolateBiLin); break;
-      case BiCubic:  td->_FLT(interpolate) = &_FLT(interpolateBiCub); break;
-      default: td->_FLT(interpolate)	   = &_FLT(interpolateBiLin);
-    }
+  switch(td->conf.interpolType){
+   case VS_Zero:     td->_FLT(interpolate) = &_FLT(interpolateZero); break;
+   case VS_Linear:   td->_FLT(interpolate) = &_FLT(interpolateLin); break;
+   case VS_BiLinear: td->_FLT(interpolate) = &_FLT(interpolateBiLin); break;
+   case VS_BiCubic:  td->_FLT(interpolate) = &_FLT(interpolateBiCub); break;
+   default: td->_FLT(interpolate)          = &_FLT(interpolateBiLin);
+  }
 
 #endif
-    return VS_OK;
+  return VS_OK;
 }
 
-void cleanupTransformData(TransformData* td){
-    if (td->srcMalloced && !isNullFrame(&td->src)) {
-        freeFrame(&td->src);
-    }
-    if (td->crop == KeepBorder && !isNullFrame(&td->destbuf)) {
-        freeFrame(&td->destbuf);
-    }
+void vsTransformDataCleanup(VSTransformData* td){
+  if (td->srcMalloced && !vsFrameIsNull(&td->src)) {
+    vsFrameFree(&td->src);
+  }
+  if (td->conf.crop == VSKeepBorder && !vsFrameIsNull(&td->destbuf)) {
+    vsFrameFree(&td->destbuf);
+  }
 }
 
-int transformPrepare(TransformData* td, const VSFrame* src, VSFrame* dest){
-    // we first copy the frame to td->src and then overwrite the destination
-    // with the transformed version
-    td->dest = *dest;
-    if(src==dest || td->srcMalloced){ // in place operation: we have to copy the src first
-        if(isNullFrame(&td->src)) {
-            allocateFrame(&td->src,&td->fiSrc);
-            td->srcMalloced = 1;
-        }
-        if (isNullFrame(&td->src)) {
-            vs_log_error(td->modName, "vs_malloc failed\n");
-            return VS_ERROR;
-        }
-        copyFrame(&td->src, src, &td->fiSrc);
-    }else{ // otherwise no copy needed
-        td->src=*src;
+int vsTransformPrepare(VSTransformData* td, const VSFrame* src, VSFrame* dest){
+  // we first copy the frame to td->src and then overwrite the destination
+  // with the transformed version
+  td->dest = *dest;
+  if(src==dest || td->srcMalloced){ // in place operation: we have to copy the src first
+    if(vsFrameIsNull(&td->src)) {
+      vsFrameAllocate(&td->src,&td->fiSrc);
+      td->srcMalloced = 1;
+    }
+    if (vsFrameIsNull(&td->src)) {
+      vs_log_error(td->conf.modName, "vs_malloc failed\n");
+      return VS_ERROR;
     }
-    if (td->crop == KeepBorder) {
-      if(isNullFrame(&td->destbuf)) {
-        // if we keep the borders, we need a second buffer to store
-        //  the previous stabilized frame, so we use destbuf
-        allocateFrame(&td->destbuf,&td->fiDest);
-        if (isNullFrame(&td->destbuf)) {
-          vs_log_error(td->modName, "vs_malloc failed\n");
-          return VS_ERROR;
-        }
-        // if we keep borders, save first frame into the background buffer (destbuf)
-        copyFrame(&td->destbuf, src, &td->fiSrc);
+    vsFrameCopy(&td->src, src, &td->fiSrc);
+  }else{ // otherwise no copy needed
+    td->src=*src;
+  }
+  if (td->conf.crop == VSKeepBorder) {
+    if(vsFrameIsNull(&td->destbuf)) {
+      // if we keep the borders, we need a second buffer to store
+      //  the previous stabilized frame, so we use destbuf
+      vsFrameAllocate(&td->destbuf,&td->fiDest);
+      if (vsFrameIsNull(&td->destbuf)) {
+        vs_log_error(td->conf.modName, "vs_malloc failed\n");
+        return VS_ERROR;
       }
-    }else{ // otherwise we directly operate on the destination
-        td->destbuf = *dest;
+      // if we keep borders, save first frame into the background buffer (destbuf)
+      vsFrameCopy(&td->destbuf, src, &td->fiSrc);
     }
-    return VS_OK;
+  }else{ // otherwise we directly operate on the destination
+    td->destbuf = *dest;
+  }
+  return VS_OK;
 }
 
-int transformFinish(TransformData* td){
-  if(td->crop == KeepBorder){
+int vsDoTransform(VSTransformData* td, VSTransform t){
+  if (td->fiSrc.pFormat < PF_PACKED)
+    return transformPlanar(td, t);
+  else
+    return transformPacked(td, t);
+}
+
+
+int vsTransformFinish(VSTransformData* td){
+  if(td->conf.crop == VSKeepBorder){
     // we have to store our result to video buffer
     // note: destbuf stores stabilized frame to be the default for next frame
-    copyFrame(&td->dest, &td->destbuf, &td->fiSrc);
+    vsFrameCopy(&td->dest, &td->destbuf, &td->fiSrc);
   }
   return VS_OK;
 }
 
 
-Transform getNextTransform(const TransformData* td, Transformations* trans){
-    if(trans->len <=0 ) return null_transform();
-    if (trans->current >= trans->len) {
-        trans->current = trans->len;
-        if(!trans->warned_end)
-            vs_log_warn(td->modName, "not enough transforms found, use last transformation!\n");
-        trans->warned_end = 1;
-    }else{
-        trans->current++;
-    }
-    return trans->ts[trans->current-1];
+VSTransform vsGetNextTransform(const VSTransformData* td, VSTransformations* trans){
+  if(trans->len <=0 ) return null_transform();
+  if (trans->current >= trans->len) {
+    trans->current = trans->len;
+    if(!trans->warned_end)
+      vs_log_warn(td->conf.modName, "not enough transforms found, use last transformation!\n");
+    trans->warned_end = 1;
+  }else{
+    trans->current++;
+  }
+  return trans->ts[trans->current-1];
 }
 
-void initTransformations(Transformations* trans){
-    trans->ts = 0;
-    trans->len = 0;
-    trans->current = 0;
-    trans->warned_end = 0;
+void vsTransformationsInit(VSTransformations* trans){
+  trans->ts = 0;
+  trans->len = 0;
+  trans->current = 0;
+  trans->warned_end = 0;
 }
 
-void cleanupTransformations(Transformations* trans){
-    if (trans->ts) {
-        vs_free(trans->ts);
-        trans->ts = NULL;
-    }
-    trans->len=0;
+void vsTransformationsCleanup(VSTransformations* trans){
+  if (trans->ts) {
+    vs_free(trans->ts);
+    trans->ts = NULL;
+  }
+  trans->len=0;
 }
 
 
 /**
- * preprocessTransforms: does smoothing, relative to absolute conversion,
+ * vsPreprocessTransforms: does smoothing, relative to absolute conversion,
  *  and cropping of too large transforms.
  *  This is actually the core algorithm for canceling the jiggle in the
  *  movie. We perform a low-pass filter in terms of transformation size.
@@ -199,140 +227,140 @@ void cleanupTransformations(Transformations* trans){
  * Side effects:
  *     td->trans will be modified
  */
-int preprocessTransforms(TransformData* td, Transformations* trans)
+int vsPreprocessTransforms(VSTransformData* td, VSTransformations* trans)
 {
-    Transform* ts = trans->ts;
-    int i;
+  VSTransform* ts = trans->ts;
+  int i;
 
-    if (trans->len < 1)
-        return 0;
-    if (td->verbose & VS_DEBUG) {
-        vs_log_msg(td->modName, "Preprocess transforms:");
+  if (trans->len < 1)
+    return 0;
+  if (td->conf.verbose & VS_DEBUG) {
+    vs_log_msg(td->conf.modName, "Preprocess transforms:");
+  }
+  if (td->conf.smoothing>0) {
+    /* smoothing */
+    VSTransform* ts2 = vs_malloc(sizeof(VSTransform) * trans->len);
+    memcpy(ts2, ts, sizeof(VSTransform) * trans->len);
+
+    /*  we will do a sliding average with minimal update
+     *   \hat x_{n/2} = x_1+x_2 + .. + x_n
+     *   \hat x_{n/2+1} = x_2+x_3 + .. + x_{n+1} = x_{n/2} - x_1 + x_{n+1}
+     *   avg = \hat x / n
+     */
+    int s = td->conf.smoothing * 2 + 1;
+    VSTransform null = null_transform();
+    /* avg is the average over [-smoothing, smoothing] transforms
+       around the current point */
+    VSTransform avg;
+    /* avg2 is a sliding average over the filtered signal! (only to past)
+     *  with smoothing * 10 horizont to kill offsets */
+    VSTransform avg2 = null_transform();
+    double tau = 1.0/(3 * s);
+    /* initialise sliding sum with hypothetic sum centered around
+     * -1st element. We have two choices:
+     * a) assume the camera is not moving at the beginning
+     * b) assume that the camera moves and we use the first transforms
+     */
+    VSTransform s_sum = null;
+    for (i = 0; i < td->conf.smoothing; i++){
+      s_sum = add_transforms(&s_sum, i < trans->len ? &ts2[i]:&null);
     }
-    if (td->smoothing>0) {
-        /* smoothing */
-        Transform* ts2 = vs_malloc(sizeof(Transform) * trans->len);
-        memcpy(ts2, ts, sizeof(Transform) * trans->len);
-
-        /*  we will do a sliding average with minimal update
-         *   \hat x_{n/2} = x_1+x_2 + .. + x_n
-         *   \hat x_{n/2+1} = x_2+x_3 + .. + x_{n+1} = x_{n/2} - x_1 + x_{n+1}
-         *   avg = \hat x / n
-         */
-        int s = td->smoothing * 2 + 1;
-        Transform null = null_transform();
-        /* avg is the average over [-smoothing, smoothing] transforms
-           around the current point */
-        Transform avg;
-        /* avg2 is a sliding average over the filtered signal! (only to past)
-         *  with smoothing * 10 horizont to kill offsets */
-        Transform avg2 = null_transform();
-        double tau = 1.0/(3 * s);
-        /* initialise sliding sum with hypothetic sum centered around
-         * -1st element. We have two choices:
-         * a) assume the camera is not moving at the beginning
-         * b) assume that the camera moves and we use the first transforms
-         */
-        Transform s_sum = null;
-        for (i = 0; i < td->smoothing; i++){
-            s_sum = add_transforms(&s_sum, i < trans->len ? &ts2[i]:&null);
-        }
-        mult_transform(&s_sum, 2); // choice b (comment out for choice a)
-
-        for (i = 0; i < trans->len; i++) {
-            Transform* old = ((i - td->smoothing - 1) < 0)
-                ? &null : &ts2[(i - td->smoothing - 1)];
-            Transform* new = ((i + td->smoothing) >= trans->len)
-                ? &null : &ts2[(i + td->smoothing)];
-            s_sum = sub_transforms(&s_sum, old);
-            s_sum = add_transforms(&s_sum, new);
-
-            avg = mult_transform(&s_sum, 1.0/s);
-
-            /* lowpass filter:
-             * meaning high frequency must be transformed away
-             */
-            ts[i] = sub_transforms(&ts2[i], &avg);
-            /* kill accumulating offset in the filtered signal*/
-            avg2 = add_transforms_(mult_transform(&avg2, 1 - tau),
-                                   mult_transform(&ts[i], tau));
-            ts[i] = sub_transforms(&ts[i], &avg2);
-
-            if (td->verbose & VS_DEBUG) {
-                vs_log_msg(td->modName,
-                           "s_sum: %5lf %5lf %5lf, ts: %5lf, %5lf, %5lf\n",
-                           s_sum.x, s_sum.y, s_sum.alpha,
-                           ts[i].x, ts[i].y, ts[i].alpha);
-                vs_log_msg(td->modName,
-                           "  avg: %5lf, %5lf, %5lf avg2: %5lf, %5lf, %5lf",
-                           avg.x, avg.y, avg.alpha,
-                           avg2.x, avg2.y, avg2.alpha);
-            }
-        }
-        vs_free(ts2);
+    mult_transform(&s_sum, 2); // choice b (comment out for choice a)
+
+    for (i = 0; i < trans->len; i++) {
+      VSTransform* old = ((i - td->conf.smoothing - 1) < 0)
+        ? &null : &ts2[(i - td->conf.smoothing - 1)];
+      VSTransform* new = ((i + td->conf.smoothing) >= trans->len)
+        ? &null : &ts2[(i + td->conf.smoothing)];
+      s_sum = sub_transforms(&s_sum, old);
+      s_sum = add_transforms(&s_sum, new);
+
+      avg = mult_transform(&s_sum, 1.0/s);
+
+      /* lowpass filter:
+       * meaning high frequency must be transformed away
+       */
+      ts[i] = sub_transforms(&ts2[i], &avg);
+      /* kill accumulating offset in the filtered signal*/
+      avg2 = add_transforms_(mult_transform(&avg2, 1 - tau),
+                             mult_transform(&ts[i], tau));
+      ts[i] = sub_transforms(&ts[i], &avg2);
+
+      if (td->conf.verbose & VS_DEBUG) {
+        vs_log_msg(td->conf.modName,
+                   "s_sum: %5lf %5lf %5lf, ts: %5lf, %5lf, %5lf\n",
+                   s_sum.x, s_sum.y, s_sum.alpha,
+                   ts[i].x, ts[i].y, ts[i].alpha);
+        vs_log_msg(td->conf.modName,
+                   "  avg: %5lf, %5lf, %5lf avg2: %5lf, %5lf, %5lf",
+                   avg.x, avg.y, avg.alpha,
+                   avg2.x, avg2.y, avg2.alpha);
+      }
     }
+    vs_free(ts2);
+  }
 
 
-    /*  invert? */
-    if (td->invert) {
-        for (i = 0; i < trans->len; i++) {
-            ts[i] = mult_transform(&ts[i], -1);
-        }
+  /*  invert? */
+  if (td->conf.invert) {
+    for (i = 0; i < trans->len; i++) {
+      ts[i] = mult_transform(&ts[i], -1);
     }
+  }
 
-    /* relative to absolute */
-    if (td->relative) {
-        Transform t = ts[0];
-        for (i = 1; i < trans->len; i++) {
-            if (td->verbose  & VS_DEBUG) {
-                vs_log_msg(td->modName, "shift: %5lf   %5lf   %lf \n",
-                           t.x, t.y, t.alpha *180/M_PI);
-            }
-            ts[i] = add_transforms(&ts[i], &t);
-            t = ts[i];
-        }
+  /* relative to absolute */
+  if (td->conf.relative) {
+    VSTransform t = ts[0];
+    for (i = 1; i < trans->len; i++) {
+      if (td->conf.verbose  & VS_DEBUG) {
+        vs_log_msg(td->conf.modName, "shift: %5lf   %5lf   %lf \n",
+                   t.x, t.y, t.alpha *180/M_PI);
+      }
+      ts[i] = add_transforms(&ts[i], &t);
+      t = ts[i];
     }
-    /* crop at maximal shift */
-    if (td->maxShift != -1)
-        for (i = 0; i < trans->len; i++) {
-            ts[i].x     = VS_CLAMP(ts[i].x, -td->maxShift, td->maxShift);
-            ts[i].y     = VS_CLAMP(ts[i].y, -td->maxShift, td->maxShift);
-        }
-    if (td->maxAngle != - 1.0)
-        for (i = 0; i < trans->len; i++)
-            ts[i].alpha = VS_CLAMP(ts[i].alpha, -td->maxAngle, td->maxAngle);
-
-    /* Calc optimal zoom
-     *  cheap algo is to only consider translations
-     *  uses cleaned max and min
-     * Todo: use sliding average to zoom only as much as needed.
-     *       use also rotation angles (transform all four corners)
-     *       optzoom=2?
-     */
-    if (td->optZoom != 0 && trans->len > 1){
-        Transform min_t, max_t;
-        cleanmaxmin_xy_transform(ts, trans->len, 10, &min_t, &max_t);
-        // the zoom value only for x
-        double zx = 2*VS_MAX(max_t.x,fabs(min_t.x))/td->fiSrc.width;
-        // the zoom value only for y
-        double zy = 2*VS_MAX(max_t.y,fabs(min_t.y))/td->fiSrc.height;
-        td->zoom += 100* VS_MAX(zx,zy); // use maximum
-        vs_log_info(td->modName, "Final zoom: %lf\n", td->zoom);
+  }
+  /* crop at maximal shift */
+  if (td->conf.maxShift != -1)
+    for (i = 0; i < trans->len; i++) {
+      ts[i].x     = VS_CLAMP(ts[i].x, -td->conf.maxShift, td->conf.maxShift);
+      ts[i].y     = VS_CLAMP(ts[i].y, -td->conf.maxShift, td->conf.maxShift);
     }
+  if (td->conf.maxAngle != - 1.0)
+    for (i = 0; i < trans->len; i++)
+      ts[i].alpha = VS_CLAMP(ts[i].alpha, -td->conf.maxAngle, td->conf.maxAngle);
+
+  /* Calc optimal zoom
+   *  cheap algo is to only consider translations
+   *  uses cleaned max and min
+   * Todo: use sliding average to zoom only as much as needed.
+   *       use also rotation angles (transform all four corners)
+   *       optzoom=2?
+   */
+  if (td->conf.optZoom != 0 && trans->len > 1){
+    VSTransform min_t, max_t;
+    cleanmaxmin_xy_transform(ts, trans->len, 10, &min_t, &max_t);
+    // the zoom value only for x
+    double zx = 2*VS_MAX(max_t.x,fabs(min_t.x))/td->fiSrc.width;
+    // the zoom value only for y
+    double zy = 2*VS_MAX(max_t.y,fabs(min_t.y))/td->fiSrc.height;
+    td->conf.zoom += 100* VS_MAX(zx,zy); // use maximum
+    vs_log_info(td->conf.modName, "Final zoom: %lf\n", td->conf.zoom);
+  }
 
-    /* apply global zoom */
-    if (td->zoom != 0){
-        for (i = 0; i < trans->len; i++)
-            ts[i].zoom += td->zoom;
-    }
+  /* apply global zoom */
+  if (td->conf.zoom != 0){
+    for (i = 0; i < trans->len; i++)
+      ts[i].zoom += td->conf.zoom;
+  }
 
-    return VS_OK;
+  return VS_OK;
 }
 
 
 /**
- * lowPassTransforms: single step smoothing of transforms, using only the past.
- *  see also preprocessTransforms. Here only relative transformations are
+ * vsLowPassTransforms: single step smoothing of transforms, using only the past.
+ *  see also vsPreprocessTransforms. Here only relative transformations are
  *  considered (produced by motiondetection). Also cropping of too large transforms.
  *
  * Parameters:
@@ -344,8 +372,8 @@ int preprocessTransforms(TransformData* td, Transformations* trans)
  * Preconditions:
  *     None
  */
-Transform lowPassTransforms(TransformData* td, SlidingAvgTrans* mem,
-                            const Transform* trans)
+VSTransform vsLowPassTransforms(VSTransformData* td, VSSlidingAvgTrans* mem,
+                                const VSTransform* trans)
 {
 
   if (!mem->initialized){
@@ -356,12 +384,12 @@ Transform lowPassTransforms(TransformData* td, SlidingAvgTrans* mem,
     mem->accum = null_transform();
     return mem->accum;
   }else{
-    double s = 1.0/(td->smoothing + 1);
-    double tau = 1.0/(3.0 * (td->smoothing + 1));
-    if(td->smoothing>0){
+    double s = 1.0/(td->conf.smoothing + 1);
+    double tau = 1.0/(3.0 * (td->conf.smoothing + 1));
+    if(td->conf.smoothing>0){
       // otherwise do the sliding window
       mem->avg = add_transforms_(mult_transform(&mem->avg, 1 - s),
-				 mult_transform(trans, s));
+                                 mult_transform(trans, s));
     }else{
       mem->avg = *trans;
     }
@@ -369,30 +397,30 @@ Transform lowPassTransforms(TransformData* td, SlidingAvgTrans* mem,
     /* lowpass filter:
      * meaning high frequency must be transformed away
      */
-    Transform newtrans = sub_transforms(trans, &mem->avg);
+    VSTransform newtrans = sub_transforms(trans, &mem->avg);
 
     /* relative to absolute */
-    if (td->relative) {
+    if (td->conf.relative) {
       newtrans = add_transforms(&newtrans, &mem->accum);
       mem->accum = newtrans;
-      if(td->smoothing>0){
-	// kill accumulating effects
-	mem->accum = mult_transform(&mem->accum, 1.0 - tau);
+      if(td->conf.smoothing>0){
+        // kill accumulating effects
+        mem->accum = mult_transform(&mem->accum, 1.0 - tau);
       }
     }
 
     /* crop at maximal shift */
-    if (td->maxShift != -1){
-      newtrans.x     = VS_CLAMP(newtrans.x, -td->maxShift, td->maxShift);
-      newtrans.y     = VS_CLAMP(newtrans.y, -td->maxShift, td->maxShift);
+    if (td->conf.maxShift != -1){
+      newtrans.x     = VS_CLAMP(newtrans.x, -td->conf.maxShift, td->conf.maxShift);
+      newtrans.y     = VS_CLAMP(newtrans.y, -td->conf.maxShift, td->conf.maxShift);
     }
-    if (td->maxAngle != - 1.0)
-      newtrans.alpha = VS_CLAMP(newtrans.alpha, -td->maxAngle, td->maxAngle);
+    if (td->conf.maxAngle != - 1.0)
+      newtrans.alpha = VS_CLAMP(newtrans.alpha, -td->conf.maxAngle, td->conf.maxAngle);
 
     /* Calc sliding optimal zoom
      *  cheap algo is to only consider translations and to sliding avg
      */
-    if (td->optZoom != 0 && td->smoothing > 0){
+    if (td->conf.optZoom != 0 && td->conf.smoothing > 0){
       // the zoom value only for x
       double zx = 2*newtrans.x/td->fiSrc.width;
       // the zoom value only for y
@@ -403,8 +431,8 @@ Transform lowPassTransforms(TransformData* td, SlidingAvgTrans* mem,
       //  and zoom a little in any case (so set td->zoom to 2 or so)
       newtrans.zoom = mem->zoomavg;
     }
-    if (td->zoom != 0){
-      newtrans.zoom += td->zoom;
+    if (td->conf.zoom != 0){
+      newtrans.zoom += td->conf.zoom;
     }
     return newtrans;
   }
diff --git a/src/transform.h b/src/transform.h
index 5b5242d..503684d 100644
--- a/src/transform.h
+++ b/src/transform.h
@@ -29,34 +29,72 @@
 #include "transformtype.h"
 #include "frameinfo.h"
 #include "vidstabdefines.h"
-#include "transformfixedpoint.h"
 #ifdef TESTING
 #include "transformfloat.h"
 #endif
 
-typedef struct transformations {
-    Transform* ts; // array of transformations
+
+typedef struct _vstransformations {
+    VSTransform* ts; // array of transformations
     int current;   // index to current transformation
     int len;       // length of trans array
     short warned_end; // whether we warned that there is no transform left
-} Transformations;
+} VSTransformations;
 
-typedef struct slidingavgtrans {
-    Transform avg; // average transformation
-    Transform accum; // accumulator for relative to absolute conversion
+typedef struct _vsslidingavgtrans {
+    VSTransform avg; // average transformation
+    VSTransform accum; // accumulator for relative to absolute conversion
     double zoomavg;     // average zoom value
     short initialized; // whether it was initialized or not
-} SlidingAvgTrans;
+} VSSlidingAvgTrans;
 
 
 /// interpolation types
-typedef enum { Zero, Linear, BiLinear, BiCubic} InterpolType;
-/// name of the interpolation type
-extern const char* interpolTypes[5];
+typedef enum { VS_Zero, VS_Linear, VS_BiLinear, VS_BiCubic, VS_NBInterPolTypes} VSInterpolType;
+
+/// returns a name for the interpolation type
+const char* getInterpolationTypeName(VSInterpolType type);
 
-typedef enum { KeepBorder = 0, CropBorder } BorderType;
+typedef enum { VSKeepBorder = 0, VSCropBorder } VSBorderType;
 
-typedef struct _TransformData {
+/**
+ * interpolate: general interpolation function pointer for one channel image data
+ *              for fixed point numbers/calculations
+ * Parameters:
+ *             rv: destination pixel (call by reference)
+ *            x,y: the source coordinates in the image img. Note this
+ *                 are real-value coordinates (in fixed point format 24.8),
+ *                 that's why we interpolate
+ *            img: source image
+ *   width,height: dimension of image
+ *            def: default value if coordinates are out of range
+ * Return value:  None
+ */
+typedef void (*vsInterpolateFun)(unsigned char *rv, int32_t x, int32_t y,
+                               unsigned char* img, int width, int height,
+                               unsigned char def);
+
+typedef struct _VSTransformConfig {
+
+    /* whether to consider transforms as relative (to previous frame)
+     * or absolute transforms
+     */
+    int            relative;
+    /* number of frames (forward and backward)
+     * to use for smoothing transforms */
+    int            smoothing;
+    VSBorderType   crop;        // 1: black bg, 0: keep border from last frame(s)
+    int            invert;      // 1: invert transforms, 0: nothing
+    double         zoom;        // percentage to zoom: 0->no zooming 10:zoom in 10%
+    int            optZoom;     // 1: determine optimal zoom, 0: nothing
+    VSInterpolType interpolType; // type of interpolation: 0->Zero,1->Lin,2->BiLin,3->Sqr
+    int            maxShift;    // maximum number of pixels we will shift
+    double         maxAngle;    // maximum angle in rad
+    const char*    modName;     // module name (used for logging)
+    int            verbose;     // level of logging
+} VSTransformConfig;
+
+typedef struct _VSTransformData {
     VSFrameInfo fiSrc;
     VSFrameInfo fiDest;
 
@@ -66,50 +104,31 @@ typedef struct _TransformData {
     VSFrame dest;        // pointer to the destination buffer
 
     short srcMalloced;   // 1 if the source buffer was internally malloced
-    const char* modName;
 
-    interpolateFun interpolate; // pointer to interpolation function
+    vsInterpolateFun interpolate; // pointer to interpolation function
 #ifdef TESTING
-    _FLT(interpolateFun) _FLT(interpolate);
+    _FLT(vsInterpolateFun) _FLT(interpolate);
 #endif
 
     /* Options */
-    int maxShift;        // maximum number of pixels we will shift
-    double maxAngle;     // maximum angle in rad
+    VSTransformConfig conf;
+
     /* maximal difference in angles of fields */
     double maxAngleVariation;
-
-
-    /* whether to consider transforms as relative (to previous frame)
-     * or absolute transforms
-     */
-    int relative;
-    /* number of frames (forward and backward)
-     * to use for smoothing transforms */
-    int smoothing;
-    BorderType crop;  // 1: black bg, 0: keep border from last frame(s)
-    int invert;       // 1: invert transforms, 0: nothing
-    /* constants */
     /* threshhold below which no rotation is performed */
-    double rotationThreshhold;
-    double zoom;      // percentage to zoom: 0->no zooming 10:zoom in 10%
-    int optZoom;      // 1: determine optimal zoom, 0: nothing
-    InterpolType interpolType; // type of interpolation: 0->Zero,1->Lin,2->BiLin,3->Sqr
-    double sharpen;   // amount of sharpening
-
-    int verbose;     // level of logging
+    double         rotationThreshhold;
 
     int initialized; // 1 if initialized and 2 if configured
-} TransformData;
+} VSTransformData;
 
 
-static const char transform_help[] = ""
+static const char vs_transform_help[] = ""
     "Overview\n"
     "    Reads a file with transform information for each frame\n"
     "     and applies them. See also filter stabilize.\n"
     "Options\n"
     "    'input'     path to the file used to read the transforms\n"
-    "                (def: inputfile.stab)\n"
+    "                (def: inputfile.trf)\n"
     "    'smoothing' number of frames*2 + 1 used for lowpass filtering \n"
     "                used for stabilizing (def: 10)\n"
     "    'maxshift'  maximal number of pixels to translate image\n"
@@ -131,51 +150,63 @@ static const char transform_help[] = ""
     "    'tripod'    virtual tripod mode (=relative=0:smoothing=0)\n"
     "    'help'      print this help message\n";
 
-/** initialized the TransformData structure and allocates memory
- *  for the frames and stuff
- *  @return VS_OK on success otherwise VS_ERROR
+/** returns the default config
  */
-int initTransformData(TransformData* td, const VSFrameInfo* fi_src,
-                      const VSFrameInfo* fi_dest , const char* modName);
+VSTransformConfig vsTransformGetDefaulfConfig(const char* modName);
 
-/** configures TransformData structure and checks ranges, initializes fields and so on.
+/** initialized the VSTransformData structure using the config and allocates memory
+ *  for the frames and stuff
  *  @return VS_OK on success otherwise VS_ERROR
  */
-int configureTransformData(TransformData* td);
+int vsTransformDataInit(VSTransformData* td, const VSTransformConfig* conf,
+                        const VSFrameInfo* fi_src, const VSFrameInfo* fi_dest);
+
 
 /** Deletes internal data structures.
- * In order to use the TransformData again, you have to call initTransformData
+ * In order to use the VSTransformData again, you have to call vsTransformDataInit
  */
-void cleanupTransformData(TransformData* td);
+void vsTransformDataCleanup(VSTransformData* td);
+
+/// returns the current config
+void vsTransformGetConfig(VSTransformConfig* conf, const VSTransformData* td);
 
+/// returns the frame info for the src
+const VSFrameInfo* vsTransformGetSrcFrameInfo(const VSTransformData* td);
+/// returns the frame info for the dest
+const VSFrameInfo* vsTransformGetDestFrameInfo(const VSTransformData* td);
 
-/// initializes Transformations structure
-void initTransformations(Transformations* trans);
-/// deletes Transformations internal memory
-void cleanupTransformations(Transformations* trans);
+
+/// initializes VSTransformations structure
+void vsTransformationsInit(VSTransformations* trans);
+/// deletes VSTransformations internal memory
+void vsTransformationsCleanup(VSTransformations* trans);
 
 /// return next Transform and increases internal counter
-Transform getNextTransform(const TransformData* td, Transformations* trans);
+VSTransform vsGetNextTransform(const VSTransformData* td, VSTransformations* trans);
 
 /** preprocesses the list of transforms all at once. Here the deshaking is calculated!
  */
-int preprocessTransforms(TransformData* td, Transformations* trans);
+int vsPreprocessTransforms(VSTransformData* td, VSTransformations* trans);
 
 /**
- * lowPassTransforms: single step smoothing of transforms, using only the past.
- *  see also preprocessTransforms. */
-Transform lowPassTransforms(TransformData* td, SlidingAvgTrans* mem,
-                            const Transform* trans);
+ * vsLowPassTransforms: single step smoothing of transforms, using only the past.
+ *  see also vsPreprocessTransforms. */
+VSTransform vsLowPassTransforms(VSTransformData* td, VSSlidingAvgTrans* mem,
+                            const VSTransform* trans);
 
-/** call this function to prepare for a next transformation (transformRGB/transformYUV)
+/** call this function to prepare for a next transformation (transformPacked/transformPlanar)
     and supply the src frame buffer and the frame to write to. These can be the same pointer
     for an inplace operation (working on framebuffer directly)
  */
-int transformPrepare(TransformData* td, const VSFrame* src, VSFrame* dest);
+int vsTransformPrepare(VSTransformData* td, const VSFrame* src, VSFrame* dest);
+
+/// does the actual transformation
+int vsDoTransform(VSTransformData* td, VSTransform t);
+
 
-/** call this function to finish the transformation of a frame (transformRGB/transformYUV)
+/** call this function to finish the transformation of a frame (transformPacked/transformPlanar)
  */
-int transformFinish(TransformData* td);
+int vsTransformFinish(VSTransformData* td);
 
 
 #endif
diff --git a/src/transform_internal.h b/src/transform_internal.h
new file mode 100644
index 0000000..6afd413
--- /dev/null
+++ b/src/transform_internal.h
@@ -0,0 +1,48 @@
+/*
+ *  transform_internal.h
+ *
+ *  Copyright (C) Georg Martius - June 2007 - 2011
+ *   georg dot martius at web dot de
+ *
+ *  This file is part of vid.stab video stabilization library
+ *
+ *  vid.stab is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License,
+ *  as published by the Free Software Foundation; either version 2, or
+ *  (at your option) any later version.
+ *
+ *  vid.stab is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GNU Make; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#ifndef __TRANSFORM_INTERNAL_H
+#define __TRANSFORM_INTERNAL_H
+
+#include "transform.h"
+
+#include "transformfixedpoint.h"
+#ifdef TESTING
+#include "transformfloat.h"
+#endif
+
+/// name of the interpolation type
+const char* getInterpolationTypeName(VSInterpolType type);
+
+#endif
+
+/*
+ * Local variables:
+ *   c-file-style: "stroustrup"
+ *   c-file-offsets: ((case-label . *) (statement-case-intro . *))
+ *   indent-tabs-mode: nil
+ *   c-basic-offset: 2 t
+ * End:
+ *
+ * vim: expandtab shiftwidth=2:
+ */
diff --git a/src/transformfixedpoint.c b/src/transformfixedpoint.c
index 67596e4..c5f6dbd 100644
--- a/src/transformfixedpoint.c
+++ b/src/transformfixedpoint.c
@@ -26,6 +26,8 @@
  */
 #include "transformfixedpoint.h"
 #include "transform.h"
+#include "transformtype_operations.h"
+
 
 // the orc code does not work at the moment (BUG in ORC?)
 // #include "orc/transformorc.h"
@@ -59,25 +61,25 @@ inline void interpolateBiLinBorder(unsigned char *rv, fp16 x, fp16 y,
                                    unsigned char* img, int32_t width, int32_t height,
                                    unsigned char def)
 {
-	int32_t ix_f = fp16ToI(x);
-	int32_t iy_f = fp16ToI(y);
-	int32_t ix_c = ix_f + 1;
-	int32_t iy_c = iy_f + 1;
-	if (ix_f < -1 || ix_c > width || iy_f < -1 || iy_c > height) {
-		*rv=def;
-	}else{
-		short v1 = PIXEL(img, ix_c, iy_c, width, height,def);
-		short v2 = PIXEL(img, ix_c, iy_f, width, height,def);
-		short v3 = PIXEL(img, ix_f, iy_c, width, height,def);
-		short v4 = PIXEL(img, ix_f, iy_f, width, height,def);
-		fp16 x_f = iToFp16(ix_f);
-		fp16 x_c = iToFp16(ix_c);
-		fp16 y_f = iToFp16(iy_f);
-		fp16 y_c = iToFp16(iy_c);
-		fp16 s   = fp16To8(v1*(x - x_f)+v3*(x_c - x))*fp16To8(y - y_f) +
-			fp16To8(v2*(x - x_f) + v4*(x_c - x))*fp16To8(y_c - y) + 1;
-		*rv = fp16ToIRound(s);
-	}
+  int32_t ix_f = fp16ToI(x);
+  int32_t iy_f = fp16ToI(y);
+  int32_t ix_c = ix_f + 1;
+  int32_t iy_c = iy_f + 1;
+  if (ix_f < -1 || ix_c > width || iy_f < -1 || iy_c > height) {
+    *rv=def;
+  }else{
+    short v1 = PIXEL(img, ix_c, iy_c, width, height,def);
+    short v2 = PIXEL(img, ix_c, iy_f, width, height,def);
+    short v3 = PIXEL(img, ix_f, iy_c, width, height,def);
+    short v4 = PIXEL(img, ix_f, iy_f, width, height,def);
+    fp16 x_f = iToFp16(ix_f);
+    fp16 x_c = iToFp16(ix_c);
+    fp16 y_f = iToFp16(iy_f);
+    fp16 y_c = iToFp16(iy_c);
+    fp16 s   = fp16To8(v1*(x - x_f)+v3*(x_c - x))*fp16To8(y - y_f) +
+      fp16To8(v2*(x - x_f) + v4*(x_c - x))*fp16To8(y_c - y) + 1;
+    *rv = fp16ToIRound(s);
+  }
 }
 
 /** taken from http://en.wikipedia.org/wiki/Bicubic_interpolation for alpha=-0.5
@@ -92,57 +94,56 @@ inline void interpolateBiLinBorder(unsigned char *rv, fp16 x, fp16 y,
 /* inline static short bicub_kernel(fp16 t, short a0, short a1, short a2, short a3){ */
 /*   // (2*a1 + t*((-a0+a2) + t*((2*a0-5*a1+4*a2-a3) + t*(-a0+3*a1-3*a2+a3) )) ) / 2; */
 /*   return ((iToFp16(2*a1) + t*(-a0+a2 */
-/* 			      + fp16ToI(t*((2*a0-5*a1+4*a2-a3) */
-/* 					   + fp16ToI(t*(-a0+3*a1-3*a2+a3)) )) ) */
-/* 	   ) ) >> 17; */
+/*             + fp16ToI(t*((2*a0-5*a1+4*a2-a3) */
+/*              + fp16ToI(t*(-a0+3*a1-3*a2+a3)) )) ) */
+/*      ) ) >> 17; */
 /* } */
 
 inline static short bicub_kernel(fp16 t, short a0, short a1, short a2, short a3){
-	// (2*a1 + t*((-a0+a2) + t*((2*a0-5*a1+4*a2-a3) + t*(-a0+3*a1-3*a2+a3) )) ) / 2;
-	// we add 1/2 because of truncation errors
-	return fp16ToIRound((iToFp16(2*a1) + t*(-a0+a2
-																					+ fp16ToIRound(t*((2*a0-5*a1+4*a2-a3)
-																														+ fp16ToIRound(t*(-a0+3*a1-3*a2+a3)) )) )
-											 ) >> 1);
+  // (2*a1 + t*((-a0+a2) + t*((2*a0-5*a1+4*a2-a3) + t*(-a0+3*a1-3*a2+a3) )) ) / 2;
+  // we add 1/2 because of truncation errors
+  return fp16ToIRound((iToFp16(2*a1) + t*(-a0+a2
+                                          + fp16ToIRound(t*((2*a0-5*a1+4*a2-a3)
+                                                            + fp16ToIRound(t*(-a0+3*a1-3*a2+a3)) )) )
+                       ) >> 1);
 }
 
 /** interpolateBiCub: bi-cubic interpolation function using 4x4 pixel, see interpolate */
 inline void interpolateBiCub(unsigned char *rv, fp16 x, fp16 y,
                              unsigned char* img, int width, int height, unsigned char def)
 {
-	// do a simple linear interpolation at the border
-	int32_t ix_f = fp16ToI(x);
-	int32_t iy_f = fp16ToI(y);
-	if (ix_f < 1 || ix_f > width - 3 || iy_f < 1 || iy_f > height - 3) {
-		interpolateBiLinBorder(rv, x, y, img, width, height, def);
-	} else {
-		fp16 x_f = iToFp16(ix_f);
-		fp16 y_f = iToFp16(iy_f);
-		fp16 tx  = x-x_f;
-		short v1 = bicub_kernel(tx,
-														PIX(img, ix_f-1, iy_f-1, width, height),
-														PIX(img, ix_f,   iy_f-1, width, height),
-														PIX(img, ix_f+1, iy_f-1, width, height),
-														PIX(img, ix_f+2, iy_f-1, width, height));
-		short v2 = bicub_kernel(tx,
-														PIX(img, ix_f-1, iy_f, width, height),
-														PIX(img, ix_f,   iy_f, width, height),
-														PIX(img, ix_f+1, iy_f, width, height),
-														PIX(img, ix_f+2, iy_f, width, height));
-		short v3 = bicub_kernel(tx,
-														PIX(img, ix_f-1, iy_f+1, width, height),
-														PIX(img, ix_f,   iy_f+1, width, height),
-														PIX(img, ix_f+1, iy_f+1, width, height),
-														PIX(img, ix_f+2, iy_f+1, width, height));
-		short v4 = bicub_kernel(tx,
-														PIX(img, ix_f-1, iy_f+2, width, height),
-														PIX(img, ix_f,   iy_f+2, width, height),
-														PIX(img, ix_f+1, iy_f+2, width, height),
-														PIX(img, ix_f+2, iy_f+2, width, height));
-		*rv = (unsigned char)bicub_kernel(y-y_f, v1, v2, v3, v4);
-		//	printf("%f,%f: \t%i %i %i %i -> %i\n", fp16ToF(x),fp16ToF(y),
-		//	       v1,v2,v3,v4, *rv);
-	}
+  // do a simple linear interpolation at the border
+  int32_t ix_f = fp16ToI(x);
+  int32_t iy_f = fp16ToI(y);
+  if (ix_f < 1 || ix_f > width - 3 || iy_f < 1 || iy_f > height - 3) {
+    interpolateBiLinBorder(rv, x, y, img, width, height, def);
+  } else {
+    fp16 x_f = iToFp16(ix_f);
+    fp16 y_f = iToFp16(iy_f);
+    fp16 tx  = x-x_f;
+    short v1 = bicub_kernel(tx,
+                            PIX(img, ix_f-1, iy_f-1, width, height),
+                            PIX(img, ix_f,   iy_f-1, width, height),
+                            PIX(img, ix_f+1, iy_f-1, width, height),
+                            PIX(img, ix_f+2, iy_f-1, width, height));
+    short v2 = bicub_kernel(tx,
+                            PIX(img, ix_f-1, iy_f, width, height),
+                            PIX(img, ix_f,   iy_f, width, height),
+                            PIX(img, ix_f+1, iy_f, width, height),
+                            PIX(img, ix_f+2, iy_f, width, height));
+    short v3 = bicub_kernel(tx,
+                            PIX(img, ix_f-1, iy_f+1, width, height),
+                            PIX(img, ix_f,   iy_f+1, width, height),
+                            PIX(img, ix_f+1, iy_f+1, width, height),
+                            PIX(img, ix_f+2, iy_f+1, width, height));
+    short v4 = bicub_kernel(tx,
+                            PIX(img, ix_f-1, iy_f+2, width, height),
+                            PIX(img, ix_f,   iy_f+2, width, height),
+                            PIX(img, ix_f+1, iy_f+2, width, height),
+                            PIX(img, ix_f+2, iy_f+2, width, height));
+    short res = bicub_kernel(y-y_f, v1, v2, v3, v4);
+    *rv = res < 255 ? res : 255;
+  }
 }
 
 
@@ -151,26 +152,27 @@ inline void interpolateBiLin(unsigned char *rv, fp16 x, fp16 y,
                              unsigned char* img, int32_t width, int32_t height,
                              unsigned char def)
 {
-	int32_t ix_f = fp16ToI(x);
-	int32_t iy_f = fp16ToI(y);
-	if (ix_f < 0 || ix_f > width - 2 || iy_f < 0 || iy_f > height - 2) {
-		interpolateBiLinBorder(rv, x, y, img, width, height, def);
-	} else {
-		int32_t ix_c = ix_f + 1;
-		int32_t iy_c = iy_f + 1;
-		short v1 = PIX(img, ix_c, iy_c, width, height);
-		short v2 = PIX(img, ix_c, iy_f, width, height);
-		short v3 = PIX(img, ix_f, iy_c, width, height);
-		short v4 = PIX(img, ix_f, iy_f, width, height);
-		fp16 x_f = iToFp16(ix_f);
-		fp16 x_c = iToFp16(ix_c);
-		fp16 y_f = iToFp16(iy_f);
-		fp16 y_c = iToFp16(iy_c);
-		fp16 s  = fp16To8(v1*(x - x_f) + v3*(x_c - x))*fp16To8(y - y_f) +
-			fp16To8(v2*(x - x_f) + v4*(x_c - x))*fp16To8(y_c - y);
-		// it is underestimated due to truncation, so we add one
-		*rv = fp16ToI(s)+1;
-	}
+  int32_t ix_f = fp16ToI(x);
+  int32_t iy_f = fp16ToI(y);
+  if (ix_f < 0 || ix_f > width - 2 || iy_f < 0 || iy_f > height - 2) {
+    interpolateBiLinBorder(rv, x, y, img, width, height, def);
+  } else {
+    int32_t ix_c = ix_f + 1;
+    int32_t iy_c = iy_f + 1;
+    short v1 = PIX(img, ix_c, iy_c, width, height);
+    short v2 = PIX(img, ix_c, iy_f, width, height);
+    short v3 = PIX(img, ix_f, iy_c, width, height);
+    short v4 = PIX(img, ix_f, iy_f, width, height);
+    fp16 x_f = iToFp16(ix_f);
+    fp16 x_c = iToFp16(ix_c);
+    fp16 y_f = iToFp16(iy_f);
+    fp16 y_c = iToFp16(iy_c);
+    fp16 s  = fp16To8(v1*(x - x_f) + v3*(x_c - x))*fp16To8(y - y_f) +
+      fp16To8(v2*(x - x_f) + v4*(x_c - x))*fp16To8(y_c - y);
+    // it is underestimated due to truncation, so we add one
+    short res = fp16ToI(s);
+    *rv = res < 255 ? res+1 : 255;
+  }
 }
 
 /** interpolateLin: linear (only x) interpolation function, see interpolate */
@@ -178,25 +180,26 @@ inline void interpolateLin(unsigned char *rv, fp16 x, fp16 y,
                            unsigned char* img, int width, int height,
                            unsigned char def)
 {
-	int32_t ix_f = fp16ToI(x);
-	int32_t ix_c = ix_f + 1;
-	fp16    x_c  = iToFp16(ix_c);
-	fp16    x_f  = iToFp16(ix_f);
-	int     y_n  = fp16ToIRound(y);
-
-	short v1 = PIXEL(img, ix_c, y_n, width, height, def);
-	short v2 = PIXEL(img, ix_f, y_n, width, height, def);
-	fp16 s   = v1*(x - x_f) + v2*(x_c - x);
-	*rv = fp16ToI(s);
+  int32_t ix_f = fp16ToI(x);
+  int32_t ix_c = ix_f + 1;
+  fp16    x_c  = iToFp16(ix_c);
+  fp16    x_f  = iToFp16(ix_f);
+  int     y_n  = fp16ToIRound(y);
+
+  short v1 = PIXEL(img, ix_c, y_n, width, height, def);
+  short v2 = PIXEL(img, ix_f, y_n, width, height, def);
+  fp16 s   = v1*(x - x_f) + v2*(x_c - x);
+  short res = fp16ToI(s);
+  *rv =   res < 255 ? res : 255;
 }
 
 /** interpolateZero: nearest neighbor interpolation function, see interpolate */
 inline void interpolateZero(unsigned char *rv, fp16 x, fp16 y,
                             unsigned char* img, int width, int height, unsigned char def)
 {
-	int32_t ix_n = fp16ToIRound(x);
-	int32_t iy_n = fp16ToIRound(y);
-	*rv = (unsigned char) PIXEL(img, ix_n, iy_n, width, height, def);
+  int32_t ix_n = fp16ToIRound(x);
+  int32_t iy_n = fp16ToIRound(y);
+  *rv = (unsigned char) PIXEL(img, ix_n, iy_n, width, height, def);
 }
 
 
@@ -219,179 +222,179 @@ inline void interpolateN(unsigned char *rv, fp16 x, fp16 y,
                          unsigned char N, unsigned char channel,
                          unsigned char def)
 {
-	int32_t ix_f = fp16ToI(x);
-	int32_t iy_f = fp16ToI(y);
-	if (ix_f < 0 || ix_f > width-1 || iy_f < 0 || iy_f > height - 1) {
-		*rv = def;
-	} else {
-		int32_t ix_c = ix_f + 1;
-		int32_t iy_c = iy_f + 1;
-		short v1 = PIXN(img, ix_c, iy_c, width, height, N, channel);
-		short v2 = PIXN(img, ix_c, iy_f, width, height, N, channel);
-		short v3 = PIXN(img, ix_f, iy_c, width, height, N, channel);
-		short v4 = PIXN(img, ix_f, iy_f, width, height, N, channel);
-		fp16 x_f = iToFp16(ix_f);
-		fp16 x_c = iToFp16(ix_c);
-		fp16 y_f = iToFp16(iy_f);
-		fp16 y_c = iToFp16(iy_c);
-		fp16 s  = fp16To8(v1*(x - x_f)+v3*(x_c - x))*fp16To8(y - y_f) +
-			fp16To8(v2*(x - x_f) + v4*(x_c - x))*fp16To8(y_c - y);
-		*rv = fp16ToIRound(s);
-	}
+  int32_t ix_f = fp16ToI(x);
+  int32_t iy_f = fp16ToI(y);
+  if (ix_f < 0 || ix_f > width-1 || iy_f < 0 || iy_f > height - 1) {
+    *rv = def;
+  } else {
+    int32_t ix_c = ix_f + 1;
+    int32_t iy_c = iy_f + 1;
+    short v1 = PIXN(img, ix_c, iy_c, width, height, N, channel);
+    short v2 = PIXN(img, ix_c, iy_f, width, height, N, channel);
+    short v3 = PIXN(img, ix_f, iy_c, width, height, N, channel);
+    short v4 = PIXN(img, ix_f, iy_f, width, height, N, channel);
+    fp16 x_f = iToFp16(ix_f);
+    fp16 x_c = iToFp16(ix_c);
+    fp16 y_f = iToFp16(iy_f);
+    fp16 y_c = iToFp16(iy_c);
+    fp16 s  = fp16To8(v1*(x - x_f)+v3*(x_c - x))*fp16To8(y - y_f) +
+      fp16To8(v2*(x - x_f) + v4*(x_c - x))*fp16To8(y_c - y);
+    *rv = fp16ToIRound(s);
+  }
 }
 
 
 /**
- * transformRGB: applies current transformation to frame
+ * transformPacked: applies current transformation to frame
  * Parameters:
  *         td: private data structure of this filter
  * Return value:
  *         0 for failture, 1 for success
  * Preconditions:
- *  The frame must be in RGB format
+ *  The frame must be in Packed format
  */
-int transformRGB(TransformData* td, Transform t)
+int transformPacked(VSTransformData* td, VSTransform t)
 {
-	int x = 0, y = 0, k = 0;
-	uint8_t *D_1, *D_2;
-
-	D_1  = td->src.data[0];
-	D_2  = td->destbuf.data[0];
-	fp16 c_s_x = iToFp16(td->fiSrc.width/2);
-	fp16 c_s_y = iToFp16(td->fiSrc.height/2);
-	int32_t c_d_x = td->fiDest.width/2;
-	int32_t c_d_y = td->fiDest.height/2;
-
-	/* for each pixel in the destination image we calc the source
-	 * coordinate and make an interpolation:
-	 *      p_d = c_d + M(p_s - c_s) + t
-	 * where p are the points, c the center coordinate,
-	 *  _s source and _d destination,
-	 *  t the translation, and M the rotation matrix
-	 *      p_s = M^{-1}(p_d - c_d - t) + c_s
-	 */
-	float z     = 1.0-t.zoom/100.0;
-	fp16 zcos_a = fToFp16(z*cos(-t.alpha)); // scaled cos
-	fp16 zsin_a = fToFp16(z*sin(-t.alpha)); // scaled sin
-	fp16  c_tx    = c_s_x - fToFp16(t.x);
-	fp16  c_ty    = c_s_y - fToFp16(t.y);
-	int channels = td->fiSrc.bytesPerPixel;
-	/* All channels */
-	for (y = 0; y < td->fiDest.height; y++) {
-		int32_t y_d1 = (y - c_d_y);
-		for (x = 0; x < td->fiDest.width; x++) {
-			int32_t x_d1 = (x - c_d_x);
-			fp16 x_s  =  zcos_a * x_d1 + zsin_a * y_d1 + c_tx;
-			fp16 y_s  = -zsin_a * x_d1 + zcos_a * y_d1 + c_ty;
-
-			for (k = 0; k < channels; k++) { // iterate over colors
-				unsigned char* dest = &D_2[x + y * td->destbuf.linesize[0]+k];
-				interpolateN(dest, x_s, y_s, D_1,
-										 td->fiSrc.width, td->fiSrc.height,
-										 channels, k, td->crop ? 16 : *dest);
-			}
-		}
-	}
-	return VS_OK;
+  int x = 0, y = 0, k = 0;
+  uint8_t *D_1, *D_2;
+
+  D_1  = td->src.data[0];
+  D_2  = td->destbuf.data[0];
+  fp16 c_s_x = iToFp16(td->fiSrc.width/2);
+  fp16 c_s_y = iToFp16(td->fiSrc.height/2);
+  int32_t c_d_x = td->fiDest.width/2;
+  int32_t c_d_y = td->fiDest.height/2;
+
+  /* for each pixel in the destination image we calc the source
+   * coordinate and make an interpolation:
+   *      p_d = c_d + M(p_s - c_s) + t
+   * where p are the points, c the center coordinate,
+   *  _s source and _d destination,
+   *  t the translation, and M the rotation matrix
+   *      p_s = M^{-1}(p_d - c_d - t) + c_s
+   */
+  float z     = 1.0-t.zoom/100.0;
+  fp16 zcos_a = fToFp16(z*cos(-t.alpha)); // scaled cos
+  fp16 zsin_a = fToFp16(z*sin(-t.alpha)); // scaled sin
+  fp16  c_tx    = c_s_x - fToFp16(t.x);
+  fp16  c_ty    = c_s_y - fToFp16(t.y);
+  int channels = td->fiSrc.bytesPerPixel;
+  /* All channels */
+  for (y = 0; y < td->fiDest.height; y++) {
+    int32_t y_d1 = (y - c_d_y);
+    for (x = 0; x < td->fiDest.width; x++) {
+      int32_t x_d1 = (x - c_d_x);
+      fp16 x_s  =  zcos_a * x_d1 + zsin_a * y_d1 + c_tx;
+      fp16 y_s  = -zsin_a * x_d1 + zcos_a * y_d1 + c_ty;
+
+      for (k = 0; k < channels; k++) { // iterate over colors
+        unsigned char* dest = &D_2[x + y * td->destbuf.linesize[0]+k];
+        interpolateN(dest, x_s, y_s, D_1,
+                     td->fiSrc.width, td->fiSrc.height,
+                     channels, k, td->conf.crop ? 16 : *dest);
+      }
+    }
+  }
+  return VS_OK;
 }
 
 /**
- * transformYUV: applies current transformation to frame
+ * transformPlanar: applies current transformation to frame
  *
  * Parameters:
  *         td: private data structure of this filter
  * Return value:
  *         0 for failture, 1 for success
  * Preconditions:
- *  The frame must be in YUV format
+ *  The frame must be in Planar format
  *
  * Fixed-point format 32 bit integer:
  *  for image coords we use val<<8
  *  for angle and zoom we use val<<16
  *
  */
-int transformYUV(TransformData* td, Transform t)
+int transformPlanar(VSTransformData* td, VSTransform t)
 {
-	int32_t x = 0, y = 0;
-	uint8_t *dat_1, *dat_2;
+  int32_t x = 0, y = 0;
+  uint8_t *dat_1, *dat_2;
 
   if (t.alpha==0 && t.x==0 && t.y==0 && t.zoom == 0){
-    if(equalFrames(&td->src,&td->destbuf))
+    if(vsFramesEqual(&td->src,&td->destbuf))
       return VS_OK; // noop
     else {
-      copyFrame(&td->destbuf, &td->src, &td->fiSrc);
+      vsFrameCopy(&td->destbuf, &td->src, &td->fiSrc);
       return VS_OK;
     }
   }
 
   int plane;
   for(plane=0; plane< td->fiSrc.planes; plane++){
-		dat_1  = td->src.data[plane];
+    dat_1  = td->src.data[plane];
     dat_2  = td->destbuf.data[plane];
-    int wsub = getPlaneWidthSubS(&td->fiSrc,plane);
-    int hsub = getPlaneHeightSubS(&td->fiSrc,plane);
-		int dw = CHROMA_SIZE(td->fiDest.width , wsub);
-		int dh = CHROMA_SIZE(td->fiDest.height, hsub);
-		int sw = CHROMA_SIZE(td->fiSrc.width  , wsub);
-		int sh = CHROMA_SIZE(td->fiSrc.height , hsub);
-
-		fp16 c_s_x = iToFp16(sw / 2);
-		fp16 c_s_y = iToFp16(sh / 2);
-		int32_t c_d_x = dw / 2;
-		int32_t c_d_y = dh / 2;
-
-		float z     = 1.0-t.zoom/100.0;
-		fp16 zcos_a = fToFp16(z*cos(-t.alpha)); // scaled cos
-		fp16 zsin_a = fToFp16(z*sin(-t.alpha)); // scaled sin
-		fp16  c_tx    = c_s_x - (fToFp16(t.x) >> wsub);
-		fp16  c_ty    = c_s_y - (fToFp16(t.y) >> hsub);
-
-		/* for each pixel in the destination image we calc the source
-		 * coordinate and make an interpolation:
-		 *      p_d = c_d + M(p_s - c_s) + t
-		 * where p are the points, c the center coordinate,
-		 *  _s source and _d destination,
-		 *  t the translation, and M the rotation and scaling matrix
-		 *      p_s = M^{-1}(p_d - c_d - t) + c_s
-		 */
-		for (y = 0; y < dh; y++) {
-			// swapping of the loops brought 15% performace gain
-			int32_t y_d1 = (y - c_d_y);
-			for (x = 0; x < dw; x++) {
-				int32_t x_d1 = (x - c_d_x);
-				fp16 x_s  =  zcos_a * x_d1 + zsin_a * y_d1 + c_tx;
-				fp16 y_s  = -zsin_a * x_d1 + zcos_a * y_d1 + c_ty;
-				unsigned char* dest = &dat_2[x + y * td->destbuf.linesize[plane]];
-				// inlining the interpolation function would bring 10%
-				//  (but then we cannot use the function pointer anymore...)
-				td->interpolate(dest, x_s, y_s, dat_1,
-												td->src.linesize[plane], sh,
-												td->crop ? 16 : *dest);
-			}
-		}
-	}
-
-	return VS_OK;
+    int wsub = vsGetPlaneWidthSubS(&td->fiSrc,plane);
+    int hsub = vsGetPlaneHeightSubS(&td->fiSrc,plane);
+    int dw = CHROMA_SIZE(td->fiDest.width , wsub);
+    int dh = CHROMA_SIZE(td->fiDest.height, hsub);
+    int sw = CHROMA_SIZE(td->fiSrc.width  , wsub);
+    int sh = CHROMA_SIZE(td->fiSrc.height , hsub);
+
+    fp16 c_s_x = iToFp16(sw / 2);
+    fp16 c_s_y = iToFp16(sh / 2);
+    int32_t c_d_x = dw / 2;
+    int32_t c_d_y = dh / 2;
+
+    float z     = 1.0-t.zoom/100.0;
+    fp16 zcos_a = fToFp16(z*cos(-t.alpha)); // scaled cos
+    fp16 zsin_a = fToFp16(z*sin(-t.alpha)); // scaled sin
+    fp16  c_tx    = c_s_x - (fToFp16(t.x) >> wsub);
+    fp16  c_ty    = c_s_y - (fToFp16(t.y) >> hsub);
+
+    /* for each pixel in the destination image we calc the source
+     * coordinate and make an interpolation:
+     *      p_d = c_d + M(p_s - c_s) + t
+     * where p are the points, c the center coordinate,
+     *  _s source and _d destination,
+     *  t the translation, and M the rotation and scaling matrix
+     *      p_s = M^{-1}(p_d - c_d - t) + c_s
+     */
+    for (y = 0; y < dh; y++) {
+      // swapping of the loops brought 15% performace gain
+      int32_t y_d1 = (y - c_d_y);
+      for (x = 0; x < dw; x++) {
+        int32_t x_d1 = (x - c_d_x);
+        fp16 x_s  =  zcos_a * x_d1 + zsin_a * y_d1 + c_tx;
+        fp16 y_s  = -zsin_a * x_d1 + zcos_a * y_d1 + c_ty;
+        unsigned char* dest = &dat_2[x + y * td->destbuf.linesize[plane]];
+        // inlining the interpolation function would bring 10%
+        //  (but then we cannot use the function pointer anymore...)
+        td->interpolate(dest, x_s, y_s, dat_1,
+                        td->src.linesize[plane], sh,
+                        td->conf.crop ? 16 : *dest);
+      }
+    }
+  }
+
+  return VS_OK;
 }
 
 
 
 /* /\** TESTING */
-/*  * transformYUV_orc: applies current transformation to frame */
+/*  * transformPlanar_orc: applies current transformation to frame */
 /*  * */
 /*  * Parameters: */
 /*  *         td: private data structure of this filter */
 /*  * Return value:  */
 /*  *         0 for failture, 1 for success */
 /*  * Preconditions: */
-/*  *  The frame must be in YUV format */
+/*  *  The frame must be in Planar format */
 /*  * */
 /*  * Fixed-point format 32 bit integer: */
 /*  *  for image coords we use val<<8 */
 /*  *  for angle and zoom we use val<<16 */
 /*  * */
 /*  *\/ */
-/* int transformYUV_orc(TransformData* td, Transform t) */
+/* int transformPlanar_orc(VSTransformData* td, VSTransform t) */
 /* { */
 /*     int32_t x = 0, y = 0; */
 /*     unsigned char *Y_1, *Y_2, *Cb_1, *Cb_2, *Cr_1, *Cr_2; */
@@ -432,25 +435,25 @@ int transformYUV(TransformData* td, Transform t)
 /*     } */
 
 /*     for (y = 0; y < td->fiDest.height; y++) { */
-/*       int32_t y_d1 = (y - c_d_y);	 */
+/*       int32_t y_d1 = (y - c_d_y);   */
 /*       fp16 sin_y   = zsin_a * y_d1; */
 /*       fp16 cos_y   = zcos_a * y_d1; */
 /*       for (x = 0; x < td->fiDest.width; x++) { */
-/*       	int32_t x_d1 = (xs[x] - c_d_x); */
-/*       	//x_ss[x]  =  zcos_a * x_d1 + zsin_a * y_d1 + c_tx; */
-/* 	y_ss[x]  = -zsin_a * x_d1 + zcos_a * y_d1 + c_ty; */
+/*         int32_t x_d1 = (xs[x] - c_d_x); */
+/*         //x_ss[x]  =  zcos_a * x_d1 + zsin_a * y_d1 + c_tx; */
+/*   y_ss[x]  = -zsin_a * x_d1 + zcos_a * y_d1 + c_ty; */
 /*       } */
 /*       transform_one_line_optimized1 (x_ss, y_ss, xs, y_d1, c_d_x,  */
-/* 				     c_tx, c_ty, zcos_a, zsin_a, sin_y, cos_y,  */
-/* 				     td->fiDest.width); */
+/*              c_tx, c_ty, zcos_a, zsin_a, sin_y, cos_y,  */
+/*              td->fiDest.width); */
 /*       // transform_one_line_optimized (x_ss, y_ss, xs, y_d1, c_d_x,  */
-/*       // 				    c_tx, c_ty, zcos_a, zsin_a, td->fiDest.width); */
+/*       //             c_tx, c_ty, zcos_a, zsin_a, td->fiDest.width); */
 
 /*       for (x = 0; x < td->fiDest.width; x++) { */
-/* 	unsigned char* dest = &Y_2[x + y * td->fiDest.width]; */
-/* 	td->interpolate(dest, x_ss[x], y_ss[x], Y_1,  */
-/* 		    td->fiSrc.width, td->fiSrc.height,  */
-/* 		    td->crop ? 16 : *dest); */
+/*   unsigned char* dest = &Y_2[x + y * td->fiDest.width]; */
+/*   td->interpolate(dest, x_ss[x], y_ss[x], Y_1,  */
+/*         td->fiSrc.width, td->fiSrc.height,  */
+/*         td->crop ? 16 : *dest); */
 /*       } */
 /*     } */
 
@@ -465,15 +468,15 @@ int transformYUV(TransformData* td, Transform t)
 /*     for (y = 0; y < hd2; y++) { */
 /*       int32_t y_d1 = y - (c_d_y)/2; */
 /*       for (x = 0; x < wd2; x++) { */
-/* 	int32_t x_d1 = x - (c_d_x)/2; */
-/* 	fp16 x_s  =  zcos_a * x_d1 + zsin_a * y_d1 + c_tx2; */
-/* 	fp16 y_s  = -zsin_a * x_d1 + zcos_a * y_d1 + c_ty2;  */
-/* 	unsigned char* dest = &Cr_2[x + y * wd2]; */
-/* 	td->interpolate(dest, x_s, y_s, Cr_1, ws2, hs2,  */
-/* 		    td->crop ? 128 : *dest); */
-/* 	dest = &Cb_2[x + y * wd2]; */
-/* 	td->interpolate(dest, x_s, y_s, Cb_1, ws2, hs2,  */
-/* 		    td->crop ? 128 : *dest); */
+/*   int32_t x_d1 = x - (c_d_x)/2; */
+/*   fp16 x_s  =  zcos_a * x_d1 + zsin_a * y_d1 + c_tx2; */
+/*   fp16 y_s  = -zsin_a * x_d1 + zcos_a * y_d1 + c_ty2;  */
+/*   unsigned char* dest = &Cr_2[x + y * wd2]; */
+/*   td->interpolate(dest, x_s, y_s, Cr_1, ws2, hs2,  */
+/*         td->crop ? 128 : *dest); */
+/*   dest = &Cb_2[x + y * wd2]; */
+/*   td->interpolate(dest, x_s, y_s, Cb_1, ws2, hs2,  */
+/*         td->crop ? 128 : *dest); */
 /*       } */
 /*     } */
 
diff --git a/src/transformfixedpoint.h b/src/transformfixedpoint.h
index 7dd3a69..df05859 100644
--- a/src/transformfixedpoint.h
+++ b/src/transformfixedpoint.h
@@ -35,36 +35,20 @@
 #include <stdint.h>
 
 typedef int32_t fp8;
-typedef int32_t fp16;
+typedef int32_t fp16; // also ncot definition of interpolFun in transform.h
 
-struct _TransformData;
+struct _VSTransformData;
 
-/// does the actual transformation in RGB space
-int transformRGB(struct _TransformData* td, Transform t);
-/// does the actual transformation in YUV space
-int transformYUV(struct _TransformData* td, Transform t);
+/// does the actual transformation in Packed space
+int transformPacked(struct _VSTransformData* td, VSTransform t);
 
-// testing
-/// does the actual transformation in YUV space
-int transformYUV_orc(struct _TransformData* td, Transform t);
+/// does the actual transformation in Planar space
+int transformPlanar(struct _VSTransformData* td, VSTransform t);
 
+// testing
+/// does the actual transformation in Planar space
+int transformPlanar_orc(struct _VSTransformData* td, VSTransform t);
 
-/**
- * interpolate: general interpolation function pointer for one channel image data
- *
- * Parameters:
- *             rv: destination pixel (call by reference)
- *            x,y: the source coordinates in the image img. Note this
- *                 are real-value coordinates (in fixed point format 24.8),
- *                 that's why we interpolate
- *            img: source image
- *   width,height: dimension of image
- *            def: default value if coordinates are out of range
- * Return value:  None
- */
-typedef void (*interpolateFun)(unsigned char *rv, fp16 x, fp16 y,
-                               unsigned char* img, int width, int height,
-                               unsigned char def);
 
 /* forward deklarations, please see .c file for documentation*/
 void interpolateBiLinBorder(unsigned char *rv, fp16 x, fp16 y,
diff --git a/src/transformfloat.c b/src/transformfloat.c
index f7092a0..ccb58e1 100644
--- a/src/transformfloat.c
+++ b/src/transformfloat.c
@@ -25,6 +25,7 @@
  */
 #include "transformfloat.h"
 #include "transform.h"
+#include "transformtype_operations.h"
 
 
 /** interpolateBiLinBorder: bi-linear interpolation function that also works at the border.
@@ -180,20 +181,21 @@ void _FLT(interpolateN)(unsigned char *rv, float x, float y,
 
 
 /**
- * transformRGB: applies current transformation to frame
+ * transformPacked: applies current transformation to frame
  * Parameters:
  *         td: private data structure of this filter
  * Return value:
  *         0 for failture, 1 for success
  * Preconditions:
- *  The frame must be in RGB format
+ *  The frame must be in Packed format
  /// TODO Add zoom!
  /// Add bytes per pixel usage
  */
-int _FLT(transformRGB)(TransformData* td, Transform t)
+int _FLT(transformPacked)(VSTransformData* td, VSTransform t)
 {
   int x = 0, y = 0, z = 0;
   unsigned char *D_1, *D_2;
+  char crop = td->conf.crop;
 
   D_1  = td->src.data[0];
   D_2  = td->destbuf.data[0];
@@ -210,7 +212,7 @@ int _FLT(transformRGB)(TransformData* td, Transform t)
    *  t the translation, and M the rotation matrix
    *      p_s = M^{-1}(p_d - c_d - t) + c_s
    */
-	int channels = td->fiSrc.bytesPerPixel;
+  int channels = td->fiSrc.bytesPerPixel;
   /* All channels */
   if (fabs(t.alpha) > td->rotationThreshhold) {
     for (x = 0; x < td->fiDest.width; x++) {
@@ -225,7 +227,7 @@ int _FLT(transformRGB)(TransformData* td, Transform t)
           unsigned char* dest = &D_2[x + y * td->destbuf.linesize[0]+z];
           _FLT(interpolateN)(dest, x_s, y_s, D_1,
                              td->fiSrc.width, td->fiSrc.height,
-                             channels, z, td->crop ? 16 : *dest);
+                             channels, z, crop ? 16 : *dest);
         }
       }
     }
@@ -241,7 +243,7 @@ int _FLT(transformRGB)(TransformData* td, Transform t)
           short p = PIXELN(D_1, x - round_tx, y - round_ty,
                            td->fiSrc.width, td->fiSrc.height, channels, z, -1);
           if (p == -1) {
-            if (td->crop == 1)
+            if (crop == 1)
               D_2[(x + y * td->fiDest.width)*channels+z] = 16;
           } else {
             D_2[(x + y * td->fiDest.width)*channels+z] = (unsigned char)p;
@@ -254,25 +256,26 @@ int _FLT(transformRGB)(TransformData* td, Transform t)
 }
 
 /**
- * transformYUV: applies current transformation to frame
+ * transformPlanar: applies current transformation to frame
  *
  * Parameters:
  *         td: private data structure of this filter
  * Return value:
  *         0 for failture, 1 for success
  * Preconditions:
- *  The frame must be in YUV format
+ *  The frame must be in Planar format
  */
-int _FLT(transformYUV)(TransformData* td, Transform t)
+int _FLT(transformPlanar)(VSTransformData* td, VSTransform t)
 {
   int x = 0, y = 0;
   uint8_t *dat_1, *dat_2;
+  char crop = td->conf.crop;
 
   if (t.alpha==0 && t.x==0 && t.y==0 && t.zoom == 0){
-    if(equalFrames(&td->src,&td->destbuf))
+    if(vsFramesEqual(&td->src,&td->destbuf))
       return VS_OK; // noop
     else {
-      copyFrame(&td->destbuf, &td->src, &td->fiSrc);
+      vsFrameCopy(&td->destbuf, &td->src, &td->fiSrc);
       return VS_OK;
     }
   }
@@ -281,8 +284,8 @@ int _FLT(transformYUV)(TransformData* td, Transform t)
     dat_1  = td->src.data[plane];
     dat_2  = td->destbuf.data[plane];
 
-    int wsub = getPlaneWidthSubS(&td->fiSrc,plane);
-    int hsub = getPlaneHeightSubS(&td->fiSrc,plane);
+    int wsub = vsGetPlaneWidthSubS(&td->fiSrc,plane);
+    int hsub = vsGetPlaneHeightSubS(&td->fiSrc,plane);
     float c_s_x = (td->fiSrc.width  >> wsub)/2.0;
     float c_s_y = (td->fiSrc.height >> hsub)/2.0;
     float c_d_x = (td->fiDest.width >> wsub)/2.0;
@@ -315,7 +318,7 @@ int _FLT(transformYUV)(TransformData* td, Transform t)
         unsigned char* dest = &dat_2[x + y * td->destbuf.linesize[plane]];
         td->_FLT(interpolate)(dest, x_s, y_s, dat_1,
                               td->src.linesize[plane], td->fiSrc.height>>hsub,
-                              td->crop ? 16 : *dest);
+                              crop ? 16 : *dest);
       }
     }
   }
diff --git a/src/transformfloat.h b/src/transformfloat.h
index 9fc99dc..090beb7 100644
--- a/src/transformfloat.h
+++ b/src/transformfloat.h
@@ -40,12 +40,12 @@
 #define _FLT(n) n
 #endif
 
-struct _TransformData;
+struct _VSTransformData;
 
-/// does the actual transformation in RGB space
-int _FLT(transformRGB)(struct _TransformData* td, Transform t);
-/// does the actual transformation in YUV space
-int _FLT(transformYUV)(struct _TransformData* td, Transform t);
+/// does the actual transformation in Packed space
+int _FLT(transformPacked)(struct _VSTransformData* td, VSTransform t);
+/// does the actual transformation in Planar space
+int _FLT(transformPlanar)(struct _VSTransformData* td, VSTransform t);
 
 /**
  * interpolate: general interpolation function pointer for one channel image data
@@ -59,7 +59,7 @@ int _FLT(transformYUV)(struct _TransformData* td, Transform t);
  *            def: default value if coordinates are out of range
  * Return value:  None
  */
-typedef void (*_FLT(interpolateFun))(unsigned char *rv, float x, float y,
+typedef void (*_FLT(vsInterpolateFun))(unsigned char *rv, float x, float y,
                                unsigned char* img, int width, int height,
                                unsigned char def);
 
diff --git a/src/transformtype.c b/src/transformtype.c
index ceecb9d..3de641b 100644
--- a/src/transformtype.c
+++ b/src/transformtype.c
@@ -22,7 +22,9 @@
  */
 #include <stdlib.h>
 #include <math.h>
+#include <string.h>
 #include "transformtype.h"
+#include "transformtype_operations.h"
 #include "vidstabdefines.h"
 
 /***********************************************************************
@@ -31,95 +33,103 @@
  */
 
 /* create an initialized transform*/
-Transform new_transform(double x, double y, double alpha,
-                        double zoom, int extra)
+VSTransform new_transform(double x, double y, double alpha,
+                          double zoom, double barrel, double rshutter, int extra)
 {
-  Transform t;
-  t.x     = x;
-  t.y     = y;
-  t.alpha = alpha;
-  t.zoom  = zoom;
-  t.extra = extra;
+  VSTransform t;
+  t.x        = x;
+  t.y        = y;
+  t.alpha    = alpha;
+  t.zoom     = zoom;
+  t.barrel   = barrel;
+  t.rshutter = rshutter;
+  t.extra    = extra;
   return t;
 }
 
 /* create a zero initialized transform*/
-Transform null_transform(void)
+VSTransform null_transform(void)
 {
-  return new_transform(0, 0, 0, 0, 0);
+  return new_transform(0, 0, 0, 0, 0, 0, 0);
 }
 
 /* adds two transforms */
-Transform add_transforms(const Transform* t1, const Transform* t2)
+VSTransform add_transforms(const VSTransform* t1, const VSTransform* t2)
 {
-  Transform t;
-  t.x     = t1->x + t2->x;
-  t.y     = t1->y + t2->y;
-  t.alpha = t1->alpha + t2->alpha;
-  t.zoom  = t1->zoom + t2->zoom;
-  t.extra = 0;
+  VSTransform t;
+  t.x        = t1->x + t2->x;
+  t.y        = t1->y + t2->y;
+  t.alpha    = t1->alpha + t2->alpha;
+  t.zoom     = t1->zoom + t2->zoom;
+  t.barrel   = t1->barrel + t2->barrel;
+  t.rshutter = t1->rshutter + t2->rshutter;
+  t.extra    = 0;
   return t;
 }
 
 /* like add_transform but with non-pointer signature */
-Transform add_transforms_(const Transform t1, const Transform t2)
+VSTransform add_transforms_(const VSTransform t1, const VSTransform t2)
 {
   return add_transforms(&t1, &t2);
 }
 
 /* subtracts two transforms */
-Transform sub_transforms(const Transform* t1, const Transform* t2)
+VSTransform sub_transforms(const VSTransform* t1, const VSTransform* t2)
 {
-  Transform t;
-  t.x     = t1->x - t2->x;
-  t.y     = t1->y - t2->y;
-  t.alpha = t1->alpha - t2->alpha;
-  t.zoom  = t1->zoom - t2->zoom;
-  t.extra = 0;
+  VSTransform t;
+  t.x        = t1->x - t2->x;
+  t.y        = t1->y - t2->y;
+  t.alpha    = t1->alpha - t2->alpha;
+  t.zoom     = t1->zoom - t2->zoom;
+  t.barrel   = t1->barrel - t2->barrel;
+  t.rshutter = t1->rshutter - t2->rshutter;
+  t.extra    = 0;
   return t;
 }
 
 /* multiplies a transforms with a scalar */
-Transform mult_transform(const Transform* t1, double f)
+VSTransform mult_transform(const VSTransform* t1, double f)
 {
-  Transform t;
-  t.x     = t1->x * f;
-  t.y     = t1->y * f;
-  t.alpha = t1->alpha * f;
-  t.zoom  = t1->zoom * f;
-  t.extra = 0;
+  VSTransform t;
+  t.x        = t1->x        * f;
+  t.y        = t1->y        * f;
+  t.alpha    = t1->alpha    * f;
+  t.zoom     = t1->zoom     * f;
+  t.barrel   = t1->barrel   * f;
+  t.rshutter = t1->rshutter * f;
+  t.extra    = 0;
   return t;
 }
 
 /* like mult_transform but with non-pointer signature */
-Transform mult_transform_(const Transform t1, double f)
+VSTransform mult_transform_(const VSTransform t1, double f)
 {
   return mult_transform(&t1,f);
 }
 
-void storeTransform(FILE* f, const Transform* t){
+void storeVSTransform(FILE* f, const VSTransform* t){
   fprintf(f,"Trans %lf %lf %lf %lf\n", t->x, t->y, t->alpha, t->zoom);
 }
 
 /* compares a transform with respect to x (for sort function) */
 int cmp_trans_x(const void *t1, const void* t2)
 {
-  double a = ((Transform*)t1)->x;
-  double b = ((Transform*)t2)->x;
+  double a = ((VSTransform*)t1)->x;
+  double b = ((VSTransform*)t2)->x;
   return a < b ? -1 : ( a > b ? 1 : 0 );
 }
 
 /* compares a transform with respect to y (for sort function) */
 int cmp_trans_y(const void *t1, const void* t2)
 {
-  double a = ((Transform*)t1)->y;
-  double b = ((Transform*)t2)->y;
+  double a = ((VSTransform*)t1)->y;
+  double b = ((VSTransform*)t2)->y;
   return a < b ? -1 : ( a > b ? 1: 0 );
 }
 
 /* static int cmp_trans_alpha(const void *t1, const void* t2){ */
-/*   double a = ((Transform*)t1)->alpha; */
-/*   double b = ((Transform*)t2)->alpha; */
+/*   double a = ((VSTransform*)t1)->alpha; */
+/*   double b = ((VSTransform*)t2)->alpha; */
 /*   return a < b ? -1 : ( a > b ? 1 : 0 ); */
 /* } */
 
@@ -155,19 +165,16 @@ int cmp_int(const void *t1, const void* t2)
  * Side effects:
  *     None
  */
-Transform median_xy_transform(const Transform* transforms, int len)
+VSTransform median_xy_transform(const VSTransform* transforms, int len)
 {
-  Transform* ts = vs_malloc(sizeof(Transform) * len);
-  Transform t;
-  memcpy(ts,transforms, sizeof(Transform)*len );
+  VSTransform* ts = vs_malloc(sizeof(VSTransform) * len);
+  VSTransform t   = null_transform();
+  memcpy(ts,transforms, sizeof(VSTransform)*len );
   int half = len/2;
-  qsort(ts, len, sizeof(Transform), cmp_trans_x);
+  qsort(ts, len, sizeof(VSTransform), cmp_trans_x);
   t.x = len % 2 == 0 ? ts[half].x : (ts[half].x + ts[half+1].x)/2;
-  qsort(ts, len, sizeof(Transform), cmp_trans_y);
+  qsort(ts, len, sizeof(VSTransform), cmp_trans_y);
   t.y = len % 2 == 0 ? ts[half].y : (ts[half].y + ts[half+1].y)/2;
-  t.alpha = 0;
-  t.zoom = 0;
-  t.extra = 0;
   vs_free(ts);
   return t;
 }
@@ -188,17 +195,17 @@ Transform median_xy_transform(const Transform* transforms, int len)
  * Side effects:
  *     None
  */
-Transform cleanmean_xy_transform(const Transform* transforms, int len)
+VSTransform cleanmean_xy_transform(const VSTransform* transforms, int len)
 {
-  Transform* ts = vs_malloc(sizeof(Transform) * len);
-  Transform t = null_transform();
+  VSTransform* ts = vs_malloc(sizeof(VSTransform) * len);
+  VSTransform t = null_transform();
   int i, cut = len / 5;
-  memcpy(ts, transforms, sizeof(Transform) * len);
-  qsort(ts,len, sizeof(Transform), cmp_trans_x);
+  memcpy(ts, transforms, sizeof(VSTransform) * len);
+  qsort(ts,len, sizeof(VSTransform), cmp_trans_x);
   for (i = cut; i < len - cut; i++){ // all but cutted
     t.x += ts[i].x;
   }
-  qsort(ts, len, sizeof(Transform), cmp_trans_y);
+  qsort(ts, len, sizeof(VSTransform), cmp_trans_y);
   for (i = cut; i < len - cut; i++){ // all but cutted
     t.y += ts[i].y;
   }
@@ -225,16 +232,16 @@ Transform cleanmean_xy_transform(const Transform* transforms, int len)
  * Side effects:
  *     only on min and max
  */
-void cleanmaxmin_xy_transform(const Transform* transforms, int len,
+void cleanmaxmin_xy_transform(const VSTransform* transforms, int len,
                               int percentil,
-                              Transform* min, Transform* max){
-  Transform* ts = vs_malloc(sizeof(Transform) * len);
+                              VSTransform* min, VSTransform* max){
+  VSTransform* ts = vs_malloc(sizeof(VSTransform) * len);
   int cut = len * percentil / 100;
-  memcpy(ts, transforms, sizeof(Transform) * len);
-  qsort(ts,len, sizeof(Transform), cmp_trans_x);
+  memcpy(ts, transforms, sizeof(VSTransform) * len);
+  qsort(ts,len, sizeof(VSTransform), cmp_trans_x);
   min->x = ts[cut].x;
   max->x = ts[len-cut-1].x;
-  qsort(ts, len, sizeof(Transform), cmp_trans_y);
+  qsort(ts, len, sizeof(VSTransform), cmp_trans_y);
   min->y = ts[cut].y;
   max->y = ts[len-cut-1].y;
   vs_free(ts);
diff --git a/src/transformtype.h b/src/transformtype.h
index 84ce8c3..2439bff 100644
--- a/src/transformtype.h
+++ b/src/transformtype.h
@@ -36,9 +36,11 @@ typedef struct _transform {
     double y;
     double alpha;
     double zoom;
+    double barrel;
+    double rshutter;
     int extra;    /* -1: ignore transform (only internal use);
                      0 for normal trans; 1 for inter scene cut (unused) */
-} Transform;
+} VSTransform;
 
 /** stores x y and size of a measurement field */
 typedef struct _field {
@@ -63,105 +65,6 @@ typedef struct _localmotion {
 } LocalMotion;
 
 typedef VSVector LocalMotions;
-/// helper macro to access a localmotion in the VSVector
-#define LMGet(localmotions,index) \
-    ((LocalMotion*)vs_vector_get(localmotions,index))
-
-
-/* helper functions to create and operate with transforms.
- * all functions are non-destructive
- * the "_" version uses non-pointer Transforms. This is slower
- * but useful when cascading calculations like
- * add_transforms_(mult_transform(&t1, 5.0), &t2)
- */
-Transform null_transform(void);
-Transform new_transform(double x, double y, double alpha,
-                        double zoom, int extra);
-Transform add_transforms(const Transform* t1, const Transform* t2);
-Transform add_transforms_(const Transform t1, const Transform t2);
-Transform sub_transforms(const Transform* t1, const Transform* t2);
-Transform mult_transform(const Transform* t1, double f);
-Transform mult_transform_(const Transform t1, double f);
-
-void storeTransform(FILE* f, const Transform* t);
-
-/* compares a transform with respect to x (for sort function) */
-int cmp_trans_x(const void *t1, const void* t2);
-/* compares a transform with respect to y (for sort function) */
-int cmp_trans_y(const void *t1, const void* t2);
-/* static int cmp_trans_alpha(const void *t1, const void* t2); */
-
-/* compares two double values (for sort function)*/
-int cmp_double(const void *t1, const void* t2);
-/* compares two int values (for sort function)*/
-int cmp_int(const void *t1, const void* t2);
-
-
-/* calculates the median of an array of transforms,
- * considering only x and y
- */
-Transform median_xy_transform(const Transform* transforms, int len);
-/* median of a double array */
-double median(double* ds, int len);
-/* mean of a double array */
-double mean(const double* ds, int len);
-/* mean with cutted upper and lower pentile
- * (min and max are optionally returned)
- */
-double cleanmean(double* ds, int len, double* minimum, double* maximum);
-/* calulcates the cleaned mean of an array of transforms,
- * considerung only x and y
- */
-Transform cleanmean_xy_transform(const Transform* transforms, int len);
-
-/* calculates the cleaned (cutting of x-th percentil)
- * maximum and minimum of an array of transforms,
- * considerung only x and y
- */
-void cleanmaxmin_xy_transform(const Transform* transforms, int len,
-                              int percentil,
-                              Transform* min, Transform* max);
-
-
-/* helper function to work with local motions */
-
-LocalMotion null_localmotion(void);
-/// a new array of the v.x values is returned (vs_free has to be called)
-int* localmotions_getx(const LocalMotions* localmotions);
-/// a new array of the v.y values is returned (vs_free has to be called)
-int* localmotions_gety(const LocalMotions* localmotions);
-/// lm1 - lm2 only for the Vec (the remaining values are taken from lm1)
-LocalMotion sub_localmotion(const LocalMotion* lm1, const LocalMotion* lm2);
-
-/* calulcates the cleaned mean of the vector of localmotions
- * considerung only v.x and v.y
- */
-LocalMotion cleanmean_localmotions(const LocalMotions* localmotions);
-
-
-
-/* helper functions */
-
-/* optimized round function */
-inline static int myround(float x) {
-    if(x>0)
-        return x + 0.5;
-    else
-        return x - 0.5;
-}
-
-
-/* optimized floor function
-   This does not give the correct value for negative integer values like -1.0. In this case
-   it will produce -2.0.
-*/
-inline static int myfloor(float x) {
-    if(x<0)
-        return x - 1;
-    else
-        return x;
-}
-
 
 #endif
 
@@ -170,7 +73,8 @@ inline static int myfloor(float x) {
  *   c-file-style: "stroustrup"
  *   c-file-offsets: ((case-label . *) (statement-case-intro . *))
  *   indent-tabs-mode: nil
+ *   c-basic-offset: 2 t
  * End:
  *
- * vim: expandtab shiftwidth=4:
+ * vim: expandtab shiftwidth=2:
  */
diff --git a/src/transformtype_operations.h b/src/transformtype_operations.h
new file mode 100644
index 0000000..b31cd2f
--- /dev/null
+++ b/src/transformtype_operations.h
@@ -0,0 +1,137 @@
+/*
+ *  transformtype_operations.h
+ *
+ *  Copyright (C) Georg Martius - June 2007 - 2013
+ *
+ *  This file is part of transcode, a video stream processing tool
+ *
+ *  transcode is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  transcode is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GNU Make; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+#ifndef __TRANSFORMTYPE_OPERATIONS_H
+#define __TRANSFORMTYPE_OPERATIONS_H
+
+#include "transformtype.h"
+
+/// helper macro to access a localmotion in the VSVector
+#define LMGet(localmotions,index) \
+    ((LocalMotion*)vs_vector_get(localmotions,index))
+
+/* helper functions to create and operate with transforms.
+ * all functions are non-destructive
+ * the "_" version uses non-pointer Transforms. This is slower
+ * but useful when cascading calculations like
+ * add_transforms_(mult_transform(&t1, 5.0), &t2)
+ */
+VSTransform null_transform(void);
+VSTransform new_transform(double x, double y, double alpha,
+                          double zoom, double barrel, double rshutter, int extra);
+VSTransform add_transforms(const VSTransform* t1, const VSTransform* t2);
+VSTransform add_transforms_(const VSTransform t1, const VSTransform t2);
+VSTransform sub_transforms(const VSTransform* t1, const VSTransform* t2);
+VSTransform mult_transform(const VSTransform* t1, double f);
+VSTransform mult_transform_(const VSTransform t1, double f);
+
+void storeTransform(FILE* f, const VSTransform* t);
+
+/* compares a transform with respect to x (for sort function) */
+int cmp_trans_x(const void *t1, const void* t2);
+/* compares a transform with respect to y (for sort function) */
+int cmp_trans_y(const void *t1, const void* t2);
+/* static int cmp_trans_alpha(const void *t1, const void* t2); */
+
+/* compares two double values (for sort function)*/
+int cmp_double(const void *t1, const void* t2);
+/* compares two int values (for sort function)*/
+int cmp_int(const void *t1, const void* t2);
+
+
+/* calculates the median of an array of transforms,
+ * considering only x and y
+ */
+VSTransform median_xy_transform(const VSTransform* transforms, int len);
+/* median of a double array */
+double median(double* ds, int len);
+/* mean of a double array */
+double mean(const double* ds, int len);
+/* mean with cutted upper and lower pentile
+ * (min and max are optionally returned)
+ */
+double cleanmean(double* ds, int len, double* minimum, double* maximum);
+/* calulcates the cleaned mean of an array of transforms,
+ * considerung only x and y
+ */
+VSTransform cleanmean_xy_transform(const VSTransform* transforms, int len);
+
+/* calculates the cleaned (cutting of x-th percentil)
+ * maximum and minimum of an array of transforms,
+ * considerung only x and y
+ */
+void cleanmaxmin_xy_transform(const VSTransform* transforms, int len,
+                              int percentil,
+                              VSTransform* min, VSTransform* max);
+
+
+/* helper function to work with local motions */
+
+LocalMotion null_localmotion(void);
+/// a new array of the v.x values is returned (vs_free has to be called)
+int* localmotions_getx(const LocalMotions* localmotions);
+/// a new array of the v.y values is returned (vs_free has to be called)
+int* localmotions_gety(const LocalMotions* localmotions);
+/// lm1 - lm2 only for the Vec (the remaining values are taken from lm1)
+LocalMotion sub_localmotion(const LocalMotion* lm1, const LocalMotion* lm2);
+
+/* calulcates the cleaned mean of the vector of localmotions
+ * considerung only v.x and v.y
+ */
+LocalMotion cleanmean_localmotions(const LocalMotions* localmotions);
+
+
+
+/* helper functions */
+
+/* optimized round function */
+inline static int myround(float x) {
+    if(x>0)
+        return x + 0.5;
+    else
+        return x - 0.5;
+}
+
+
+/* optimized floor function
+   This does not give the correct value for negative integer values like -1.0. In this case
+   it will produce -2.0.
+*/
+inline static int myfloor(float x) {
+    if(x<0)
+        return x - 1;
+    else
+        return x;
+}
+
+#endif
+
+/*
+ * Local variables:
+ *   c-file-style: "stroustrup"
+ *   c-file-offsets: ((case-label . *) (statement-case-intro . *))
+ *   indent-tabs-mode: nil
+ *   c-basic-offset: 2 t
+ * End:
+ *
+ * vim: expandtab shiftwidth=2:
+ */
diff --git a/src/vidstabdefines.h b/src/vidstabdefines.h
index 695ace8..d29dc3b 100644
--- a/src/vidstabdefines.h
+++ b/src/vidstabdefines.h
@@ -27,16 +27,17 @@
 #define VIDSTABDEFINES_H_
 
 #include <stddef.h>
+#include <stdlib.h>
 
-#define VS_MAX(a, b)		(((a) > (b)) ?(a) :(b))
-#define VS_MIN(a, b)		(((a) < (b)) ?(a) :(b))
+#define VS_MAX(a, b)    (((a) > (b)) ?(a) :(b))
+#define VS_MIN(a, b)    (((a) < (b)) ?(a) :(b))
 /* clamp x between a and b */
-#define VS_CLAMP(x, a, b)	VS_MIN(VS_MAX((a), (x)), (b))
+#define VS_CLAMP(x, a, b)  VS_MIN(VS_MAX((a), (x)), (b))
 
 #define VS_DEBUG 2
 
 /// pixel in single layer image
-#define PIXEL(img, x, y, w, h, def) ((x) < 0 || (y) < 0) ? (def)	\
+#define PIXEL(img, x, y, w, h, def) ((x) < 0 || (y) < 0) ? (def)  \
   : (((x) >= (w) || (y) >= (h)) ? (def) : img[(x) + (y) * (w)])
 /// pixel in single layer image without rangecheck
 #define PIX(img, x, y, w, h) (img[(x) + (y) * (w)])
@@ -46,89 +47,43 @@
 /// pixel in N-channel image without rangecheck. channel in {0..N-1}
 #define PIXN(img, x, y, w, h, N,channel) (img[((x) + (y) * (w))*(N) + (channel)])
 
+/**** Configurable memory and logging functions. Defined in libvidstab.c ****/
 
-// define here the functions to be used in the framework we are in
-// for transcode
-#ifdef TRANSCODE
-#include <transcode.h>
-#define vs_malloc(size) tc_malloc(size)
-#define vs_zalloc(size) tc_zalloc(size)
-#define vs_realloc(ptr, size) tc_realloc(ptr, size)
-#define vs_free(ptr) tc_free(ptr)
+typedef void* (*vs_malloc_t) (size_t size);
+typedef void* (*vs_realloc_t) (void* ptr, size_t size);
+typedef void (*vs_free_t) (void* ptr);
+typedef void* (*vs_zalloc_t) (size_t size);
 
-#define vs_log_error(tag, format, args...) \
-    tc_log(TC_LOG_ERR, tag, format , ## args)
-#define vs_log_info(tag, format, args...) \
-    tc_log(TC_LOG_INFO, tag, format , ## args)
-#define vs_log_warn(tag, format, args...) \
-    tc_log(TC_LOG_WARN, tag, format , ## args)
-#define vs_log_msg(tag, format, args...) \
-    tc_log(TC_LOG_MSG, tag, format , ## args)
+typedef int (*vs_log_t) (int type, const char* tag, const char* format, ...);
 
-#define vs_strdup(s) tc_strdup(s)
-#define vs_strndup(s, n) tc_strndup(s, n)
+typedef char* (*vs_strdup_t) (const char* s);
+typedef char* (*vs_strndup_t) (const char* s, size_t len);
 
-#define VS_ERROR TC_ERROR
-#define VS_OK TC_OK
+extern vs_log_t vs_log;
 
+extern vs_malloc_t vs_malloc;
+extern vs_realloc_t vs_realloc;
+extern vs_free_t vs_free;
+extern vs_zalloc_t vs_zalloc;
 
-#else
-#ifdef LIBAVFILTER // libavfilter library
+extern vs_strdup_t vs_strdup;
+extern vs_strndup_t vs_strndup;
 
-#include <libavutil/log.h>
-#include <libavutil/mem.h>
-extern void* pctx;
+extern int VS_ERROR_TYPE;
+extern int VS_WARN_TYPE;
+extern int VS_INFO_TYPE;
+extern int VS_MSG_TYPE;
 
-#define vs_malloc(size) av_malloc(size)
-#define vs_zalloc(size) av_mallocz(size)
-#define vs_realloc(ptr, size) av_realloc(ptr, size)
-#define vs_free(ptr) av_free(ptr)
+extern int VS_ERROR;
+extern int VS_OK;
 
 #define vs_log_error(tag, format, args...) \
-	av_log(pctx, AV_LOG_ERROR, tag, format , ## args)
-#define vs_log_info(tag, format, args...) \
-	av_log(pctx, AV_LOG_INFO, tag, format , ## args)
+    vs_log(VS_ERROR_TYPE, tag, format , ## args)
 #define vs_log_warn(tag, format, args...) \
-	av_log(pctx, AV_LOG_WARN, tag, format , ## args)
-#define vs_log_msg(tag, format, args...) \
-	av_log(pctx, AV_LOG_VERBOSE, tag, format , ## args)
-
-#define vs_strdup(s) av_strdup(s)
-#define vs_strndup(s, n) av_strndup(s, n)
-
-#define VS_ERROR 0
-#define VS_OK 1
-
-#else
- // standard C framework
-#include <string.h>
-#include <stdio.h>
-#include <stdlib.h>
-#define vs_malloc(size) (void*)malloc(size)
-#define vs_realloc(ptr, size) (void*)realloc(ptr, size)
-#define vs_free(ptr) free(ptr)
-#define vs_zalloc(size) memset(malloc(size),0,size)
-
-#define vs_log(type, tag, format, args...) \
-	{ fprintf(stderr,"%s (%s):", type, tag); fprintf(stderr,format, ## args); \
-	  fprintf(stderr,"\n"); }
-
-#define vs_log_error(tag, format, args...) \
-    vs_log("Error:", tag, format , ## args)
+    vs_log(VS_WARN_TYPE, tag, format , ## args)
 #define vs_log_info(tag, format, args...) \
-    vs_log("Info: ", tag, format , ## args)
-#define vs_log_warn(tag, format, args...) \
-    vs_log("Warn: ", tag, format , ## args)
+    vs_log(VS_INFO_TYPE, tag, format , ## args)
 #define vs_log_msg(tag, format, args...) \
-    vs_log("Msg:  ", tag, format , ## args)
-
-#define vs_strdup(s) strdup(s)
-#define vs_strndup(s, n) strndup(s, n)
-
-#define VS_ERROR -1
-#define VS_OK 0
-#endif // frameworks
-#endif // frameworks
-
+    vs_log(VS_MSG_TYPE, tag, format , ## args)
 
 #endif /* VIDSTABDEFINES_H_ */
diff --git a/src/vsvector.c b/src/vsvector.c
index ee94cc9..08f7481 100644
--- a/src/vsvector.c
+++ b/src/vsvector.c
@@ -23,6 +23,7 @@
 #include "vsvector.h"
 #include "vidstabdefines.h"
 #include <assert.h>
+#include <string.h>
 
 
 /*************************************************************************/
diff --git a/src/vsvector.h b/src/vsvector.h
index 5ae427a..5fecaf5 100644
--- a/src/vsvector.h
+++ b/src/vsvector.h
@@ -29,9 +29,9 @@
 */
 typedef struct vsvector_ VSVector;
 struct vsvector_ {
-  void**	data;
-  int		buffersize;
-  int		nelems;
+  void**  data;
+  int    buffersize;
+  int    nelems;
 };
 
 /**
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index 3f3bebe..10ad3df 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -30,7 +30,7 @@ include_directories (../src)
 add_executable (tests tests.c testutils.c testframework.c ../src/vsvector.c
   ../src/transform.c ../src/transformfloat.c ../src/transformfixedpoint.c
   ../src/libvidstab.c ../src/transformtype.c ../src/frameinfo.c
-	../src/serialize.c ../src/localmotion2transform.c
+  ../src/serialize.c ../src/localmotion2transform.c
   ../src/motiondetect.c ../src/motiondetect_opt.c ../src/orc/motiondetectorc.c ../src/boxblur.c)
 
 target_link_libraries(tests m)
diff --git a/tests/generate.c b/tests/generate.c
index 512a275..89a740e 100644
--- a/tests/generate.c
+++ b/tests/generate.c
@@ -2,44 +2,43 @@
 void generateFrames(TestData* testdata, int num){
   int i;
   for(i=0; i<num; i++){
-		allocateFrame(&testdata->frames[i],&testdata->fi);
+    vsFrameAllocate(&testdata->frames[i],&testdata->fi);
   }
   // first frame noise
   fillArrayWithNoise(testdata->frames[0].data[0],
-										 testdata->fi.width*testdata->fi.height, 10);
+                     testdata->fi.width*testdata->fi.height, 10);
   fillArrayWithNoise(testdata->frames[0].data[1],
-										 testdata->fi.width/2*testdata->fi.height/2, 5);
-	fillArrayWithNoise(testdata->frames[0].data[2],
-										 testdata->fi.width/2*testdata->fi.height/2, 5);
+                     testdata->fi.width/2*testdata->fi.height/2, 5);
+  fillArrayWithNoise(testdata->frames[0].data[2],
+                     testdata->fi.width/2*testdata->fi.height/2, 5);
 
   // add rectangles
   int k;
   for(k=0; k<NUM_RECTANGLES; k++){
     paintRectangle(testdata->frames[0].data[0],&testdata->fi,
-									 randUpTo(testdata->fi.width), randUpTo(testdata->fi.height),
-									 randUpTo((testdata->fi.width>>4)+4),
-									 randUpTo((testdata->fi.height>>4)+4),randPixel());
+                   randUpTo(testdata->fi.width), randUpTo(testdata->fi.height),
+                   randUpTo((testdata->fi.width>>4)+4),
+                   randUpTo((testdata->fi.height>>4)+4),randPixel());
 
   }
 
-  TransformData td;
-  test_bool(initTransformData(&td, &testdata->fi, &testdata->fi, "generate") == VS_OK);
-  td.interpolType=Zero;
-  test_bool(configureTransformData(&td)== VS_OK);
-
+  VSTransformConfig conf = vsTransformGetDefaulfConfig("test_generate");
+  conf.interpolType=VS_Zero;
+  VSTransformData td;
+  test_bool(vsTransformDataInit(&td, &conf, &testdata->fi, &testdata->fi) == VS_OK);
 
   fprintf(stderr, "testframe transforms\n");
 
   for(i=1; i<num; i++){
-    Transform t = getTestFrameTransform(i);
+    VSTransform t = getTestFrameTransform(i);
     fprintf(stderr, "%i, %6.4lf %6.4lf %8.5lf %6.4lf %i\n",
-						i, t.x, t.y, t.alpha, t.zoom, t.extra);
+            i, t.x, t.y, t.alpha, t.zoom, t.extra);
 
-    test_bool(transformPrepare(&td,&testdata->frames[i-1],&testdata->frames[i])== VS_OK);
-    test_bool(transformYUV_float(&td, t)== VS_OK);
-    test_bool(transformFinish(&td)== VS_OK);
+    test_bool(vsTransformPrepare(&td,&testdata->frames[i-1],&testdata->frames[i])== VS_OK);
+    test_bool(transformPlanar_float(&td, t)== VS_OK);
+    test_bool(vsTransformFinish(&td)== VS_OK);
   }
-  cleanupTransformData(&td);
+  vsTransformDataCleanup(&td);
 }
 
 /*
diff --git a/tests/orc_bug/orc_bug.c b/tests/orc_bug/orc_bug.c
index 21eb253..d529fd2 100644
--- a/tests/orc_bug/orc_bug.c
+++ b/tests/orc_bug/orc_bug.c
@@ -16,16 +16,16 @@ int main(){
   int32_t c_ty   = 6;
   int32_t c_d_x  = 256;
   int32_t y_d1 = 100;
-  
+
   int32_t* x_ss = (int32_t*)malloc(sizeof(int32_t)*N);
   int32_t* y_ss = (int32_t*)malloc(sizeof(int32_t)*N);
-  int32_t* xs   = (int32_t*)malloc(sizeof(int32_t)*N);        
-  for (x = 0; x < N; x++) { 
+  int32_t* xs   = (int32_t*)malloc(sizeof(int32_t)*N);
+  for (x = 0; x < N; x++) {
     xs[x]=x;
   }
-  
-  test_orc (x_ss, y_ss, xs, 
-	    y_d1, c_d_x, c_tx, c_ty, zcos_a, zsin_a, N);
-  
+
+  test_orc (x_ss, y_ss, xs,
+      y_d1, c_d_x, c_tx, c_ty, zcos_a, zsin_a, N);
+
   return 0;
 }
diff --git a/tests/test_boxblur.c b/tests/test_boxblur.c
index 7647a3a..5054a32 100644
--- a/tests/test_boxblur.c
+++ b/tests/test_boxblur.c
@@ -1,11 +1,11 @@
 // runs the boxblur routine and returns the time
 int runboxblur( VSFrame frame1, VSFrame dest,
-								VSFrameInfo fi, int numruns){
+                VSFrameInfo fi, int numruns){
   int start = timeOfDayinMS();
   int i;
-  boxblurYUV(&dest, &frame1, 0, &fi, 15, BoxBlurColor);
+  boxblurPlanar(&dest, &frame1, 0, &fi, 15, BoxBlurColor);
   for(i=1; i<numruns; i++){
-    boxblurYUV(&dest, &dest, 0, &fi, 15, BoxBlurColor);
+    boxblurPlanar(&dest, &dest, 0, &fi, 15, BoxBlurColor);
   }
   int end = timeOfDayinMS();
   return end-start;
@@ -13,23 +13,23 @@ int runboxblur( VSFrame frame1, VSFrame dest,
 
 
 void test_boxblur(const TestData* testdata){
-	int time; //, timeref;
-	int numruns=2;
-	VSFrame dest;
-	allocateFrame(&dest,&testdata->fi);
-	//    omp_set_dynamic( 0 );
-	//    omp_set_num_threads( 1 );
-	fprintf(stderr,"********** boxblur speedtest:\n");
-	time = runboxblur(testdata->frames[4], dest, testdata->fi, numruns);
-	fprintf(stderr,"***C    time for %i runs: %i ms\n", numruns, time);
-	storePGMImage("boxblured.pgm", dest.data[0], testdata->fi);
-	storePGMImage("orig4.pgm", testdata->frames[4].data[0], testdata->fi);
-	// timeref=time;
-	/* omp_set_dynamic( 0 ); */
-	/* omp_set_num_threads( 2); */
-	/* time = runboxblur(testdata->frames[4], dest, testdata->fi, numruns); */
-	/* fprintf(stderr,"***C (2)time for %i runs: %i ms, Speedup %f\n", numruns, time, */
-	/* 	    (double)timeref/time); */
-	/* omp_set_dynamic( 1 ); */
-	freeFrame(&dest);
+  int time; //, timeref;
+  int numruns=2;
+  VSFrame dest;
+  vsFrameAllocate(&dest,&testdata->fi);
+  //    omp_set_dynamic( 0 );
+  //    omp_set_num_threads( 1 );
+  fprintf(stderr,"********** boxblur speedtest:\n");
+  time = runboxblur(testdata->frames[4], dest, testdata->fi, numruns);
+  fprintf(stderr,"***C    time for %i runs: %i ms\n", numruns, time);
+  storePGMImage("boxblured.pgm", dest.data[0], testdata->fi);
+  storePGMImage("orig4.pgm", testdata->frames[4].data[0], testdata->fi);
+  // timeref=time;
+  /* omp_set_dynamic( 0 ); */
+  /* omp_set_num_threads( 2); */
+  /* time = runboxblur(testdata->frames[4], dest, testdata->fi, numruns); */
+  /* fprintf(stderr,"***C (2)time for %i runs: %i ms, Speedup %f\n", numruns, time, */
+  /*       (double)timeref/time); */
+  /* omp_set_dynamic( 1 ); */
+  vsFrameFree(&dest);
 }
diff --git a/tests/test_compareImg.c b/tests/test_compareImg.c
deleted file mode 100644
index 4ef955f..0000000
--- a/tests/test_compareImg.c
+++ /dev/null
@@ -1,101 +0,0 @@
-#define NUMCMP 2000
-
-int checkCompareImg(MotionDetect* md, unsigned char* frame){
-  int i;
-  int error;
-  uint8_t *Y_c;
-  Field field;
-  field.x=400;
-  field.y=400;
-  field.size=12;
-
-  Y_c = frame;
-
-  for(i=-10;i<10; i+=2){
-    printf("\nCheck: shiftX = %i\n",i);
-    error = compareSubImg(Y_c, Y_c, &field, md->fi.width, md->fi.height,
-													1, i, 0, INT_MAX);
-    fprintf(stderr,"mismatch %i: %i\n", i, error);
-  }
-  return 1;
-}
-
-void test_checkCompareImg(const TestData* testdata){
-	MotionDetect md;
-
-  test_bool(initMotionDetect(&md, &testdata->fi, "test") == VS_OK);
-  md.shakiness=6;
-  md.accuracy=12;
-  fflush(stdout);
-	test_bool(configureMotionDetect(&md)== VS_OK);
-	test_bool(checkCompareImg(&md,testdata->frames[0]));
-	cleanupMotionDetection(&md);
-}
-
-
-typedef unsigned int (*cmpSubImgFunc)(unsigned char* const I1, unsigned char* const I2,
-																			const Field* field,
-																			int width, int height, int bytesPerPixel,
-																			int d_x, int d_y, unsigned int threshold);
-
-// runs the compareSubImg routine and returns the time and stores the difference.
-//  if diffsRef is given than the results are validated
-int runcompare( cmpSubImgFunc cmpsubfunc,
-								unsigned char* frame1, unsigned char* frame2, Field f,
-								VSFrameInfo fi, int* diffs, int* diffsRef, int numruns){
-  int start = timeOfDayinMS();
-  int i;
-  for(i=0; i<numruns; i++){
-    diffs[i]=cmpsubfunc(frame1, frame2,
-												&f, fi.width, fi.height, 2, i%200, i/200, INT_MAX);
-  }
-  int end = timeOfDayinMS();
-  if(diffsRef)
-    for(i=0; i<numruns; i++){
-      if(diffs[i]!=diffsRef[i]){
-				fprintf(stderr, "ERROR! Ref difference %i, Opt difference %i\n",
-								diffsRef[i], diffs[i]);
-      }
-    }
-  return end-start;
-}
-
-
-
-void test_compareImg_performance(const TestData* testdata){
-	Field f;
-	f.size=128;
-	f.x = 400;
-	f.y = 300;
-	fprintf(stderr,"********** Compare speedtest:\n");
-
-	int numruns = NUMCMP;
-	int diffsC[numruns];
-	int diffsO[numruns];
-	int timeC, timeO;
-	timeC=runcompare(compareSubImg_thr, testdata->frames[0], testdata->frames[1],
-									 f, testdata->fi, diffsC, 0, numruns);
-	fprintf(stderr,"***C        time for %i runs: %i ms ****\n", numruns, timeC);
-#ifdef USE_ORC
-	timeO=runcompare(compareSubImg_orc, testdata->frames[0], testdata->frames[1],
-									 f, testdata->fi, diffsO, diffsC, numruns);
-	fprintf(stderr,"***orc      time for %i runs: %i ms \tSpeedup %3.2f\n",
-					numruns, timeO, (double)timeC/timeO);
-	timeO=runcompare(compareSubImg_thr_orc, testdata->frames[0], testdata->frames[1],
-									 f, testdata->fi, diffsO, diffsC, numruns);
-	fprintf(stderr,"***thr_orc  time for %i runs: %i ms \tSpeedup %3.2f\n",
-					numruns, timeO, (double)timeC/timeO);
-#endif
-#ifdef USE_SSE2
-	timeO=runcompare(compareSubImg_thr_sse2, testdata->frames[0], testdata->frames[1],
-									 f, testdata->fi, diffsO, diffsC, numruns);
-	fprintf(stderr,"***thr_sse2 time for %i runs: %i ms \tSpeedup %3.2f\n",
-					numruns, timeO, (double)timeC/timeO);
-#endif
-#ifdef USE_SSE2_ASM
-	timeO=runcompare(compareSubImg_thr_sse2_asm, testdata->frames[0], testdata->frames[1],
-									 f, testdata->fi, diffsO, diffsC, numruns);
-	fprintf(stderr,"***thr_asm  time for %i runs: %i ms \tSpeedup %3.2f\n",
-					numruns, timeO, (double)timeC/timeO);
-#endif
-}
diff --git a/tests/test_compareimg.c b/tests/test_compareimg.c
index ff7be2d..ee1d3ca 100644
--- a/tests/test_compareimg.c
+++ b/tests/test_compareimg.c
@@ -1,6 +1,6 @@
 #define NUMCMP 2000
 
-int checkCompareImg(MotionDetect* md, const VSFrame* frame){
+int checkCompareImg(VSMotionDetect* md, const VSFrame* frame){
   int i;
   int error;
   uint8_t *Y_c;
@@ -10,54 +10,53 @@ int checkCompareImg(MotionDetect* md, const VSFrame* frame){
   field.size=12;
 
   Y_c = frame->data[0];
-	int linesize = frame->linesize[0];
+  int linesize = frame->linesize[0];
 
   for(i=-10;i<10; i+=2){
     printf("\nCheck: shiftX = %i\n",i);
     error = compareSubImg(Y_c, Y_c, &field,
-													linesize, linesize, md->fi.height,
-													1, i, 0, INT_MAX);
+                          linesize, linesize, md->fi.height,
+                          1, i, 0, INT_MAX);
     fprintf(stderr,"mismatch %i: %i\n", i, error);
   }
   return 1;
 }
 
 void test_checkCompareImg(const TestData* testdata){
-	MotionDetect md;
-
-  test_bool(initMotionDetect(&md, &testdata->fi, "test") == VS_OK);
-  md.shakiness=6;
-  md.accuracy=12;
+  VSMotionDetect md;
+  VSMotionDetectConfig conf = vsMotionDetectGetDefaulfConfig("test_checkCompareImg");
+  conf.shakiness=6;
+  conf.accuracy=12;
+  test_bool(vsMotionDetectInit(&md, &conf, &testdata->fi) == VS_OK);
   fflush(stdout);
-	test_bool(configureMotionDetect(&md)== VS_OK);
-	test_bool(checkCompareImg(&md,&testdata->frames[0]));
-	cleanupMotionDetection(&md);
+  test_bool(checkCompareImg(&md,&testdata->frames[0]));
+  vsMotionDetectionCleanup(&md);
 }
 
 
 typedef unsigned int (*cmpSubImgFunc)(unsigned char* const I1, unsigned char* const I2,
-																			const Field* field,
-																			int width1, int width2, int height, int bytesPerPixel,
-																			int d_x, int d_y, unsigned int threshold);
+                                      const Field* field,
+                                      int width1, int width2, int height, int bytesPerPixel,
+                                      int d_x, int d_y, unsigned int threshold);
 
 // runs the compareSubImg routine and returns the time and stores the difference.
 //  if diffsRef is given than the results are validated
 int runcompare( cmpSubImgFunc cmpsubfunc,
-								VSFrame frame1, VSFrame frame2, Field f,
-								VSFrameInfo fi, int* diffs, int* diffsRef, int numruns){
+                VSFrame frame1, VSFrame frame2, Field f,
+                VSFrameInfo fi, int* diffs, int* diffsRef, int numruns){
   int start = timeOfDayinMS();
   int i;
   for(i=0; i<numruns; i++){
     diffs[i]=cmpsubfunc(frame1.data[0], frame2.data[0],
-												&f, frame1.linesize[0], frame2.linesize[0], fi.height,
-												2, i%200, i/200, INT_MAX);
+                        &f, frame1.linesize[0], frame2.linesize[0], fi.height,
+                        2, i%200, i/200, INT_MAX);
   }
   int end = timeOfDayinMS();
   if(diffsRef)
     for(i=0; i<numruns; i++){
       if(diffs[i]!=diffsRef[i]){
-				fprintf(stderr, "ERROR! Ref difference %i, Opt difference %i\n",
-								diffsRef[i], diffs[i]);
+        fprintf(stderr, "ERROR! Ref difference %i, Opt difference %i\n",
+                diffsRef[i], diffs[i]);
       }
     }
   return end-start;
@@ -66,39 +65,39 @@ int runcompare( cmpSubImgFunc cmpsubfunc,
 
 
 void test_compareImg_performance(const TestData* testdata){
-	Field f;
-	f.size=128;
-	f.x = 400;
-	f.y = 300;
-	fprintf(stderr,"********** Compare speedtest:\n");
+  Field f;
+  f.size=128;
+  f.x = 400;
+  f.y = 300;
+  fprintf(stderr,"********** Compare speedtest:\n");
 
-	int numruns = NUMCMP;
-	int diffsC[numruns];
-	int diffsO[numruns];
-	int timeC, timeO;
-	timeC=runcompare(compareSubImg_thr, testdata->frames[0], testdata->frames[1],
-									 f, testdata->fi, diffsC, 0, numruns);
-	fprintf(stderr,"***C        time for %i runs: %i ms ****\n", numruns, timeC);
+  int numruns = NUMCMP;
+  int diffsC[numruns];
+  int diffsO[numruns];
+  int timeC, timeO;
+  timeC=runcompare(compareSubImg_thr, testdata->frames[0], testdata->frames[1],
+                   f, testdata->fi, diffsC, 0, numruns);
+  fprintf(stderr,"***C        time for %i runs: %i ms ****\n", numruns, timeC);
 #ifdef USE_ORC
-	timeO=runcompare(compareSubImg_orc, testdata->frames[0], testdata->frames[1],
-									 f, testdata->fi, diffsO, diffsC, numruns);
-	fprintf(stderr,"***orc      time for %i runs: %i ms \tSpeedup %3.2f\n",
-					numruns, timeO, (double)timeC/timeO);
-	timeO=runcompare(compareSubImg_thr_orc, testdata->frames[0], testdata->frames[1],
-									 f, testdata->fi, diffsO, diffsC, numruns);
-	fprintf(stderr,"***thr_orc  time for %i runs: %i ms \tSpeedup %3.2f\n",
-					numruns, timeO, (double)timeC/timeO);
+  timeO=runcompare(compareSubImg_orc, testdata->frames[0], testdata->frames[1],
+                   f, testdata->fi, diffsO, diffsC, numruns);
+  fprintf(stderr,"***orc      time for %i runs: %i ms \tSpeedup %3.2f\n",
+          numruns, timeO, (double)timeC/timeO);
+  timeO=runcompare(compareSubImg_thr_orc, testdata->frames[0], testdata->frames[1],
+                   f, testdata->fi, diffsO, diffsC, numruns);
+  fprintf(stderr,"***thr_orc  time for %i runs: %i ms \tSpeedup %3.2f\n",
+          numruns, timeO, (double)timeC/timeO);
 #endif
 #ifdef USE_SSE2
-	timeO=runcompare(compareSubImg_thr_sse2, testdata->frames[0], testdata->frames[1],
-									 f, testdata->fi, diffsO, diffsC, numruns);
-	fprintf(stderr,"***thr_sse2 time for %i runs: %i ms \tSpeedup %3.2f\n",
-					numruns, timeO, (double)timeC/timeO);
+  timeO=runcompare(compareSubImg_thr_sse2, testdata->frames[0], testdata->frames[1],
+                   f, testdata->fi, diffsO, diffsC, numruns);
+  fprintf(stderr,"***thr_sse2 time for %i runs: %i ms \tSpeedup %3.2f\n",
+          numruns, timeO, (double)timeC/timeO);
 #endif
 #ifdef USE_SSE2_ASM
-	timeO=runcompare(compareSubImg_thr_sse2_asm, testdata->frames[0], testdata->frames[1],
-									 f, testdata->fi, diffsO, diffsC, numruns);
-	fprintf(stderr,"***thr_asm  time for %i runs: %i ms \tSpeedup %3.2f\n",
-					numruns, timeO, (double)timeC/timeO);
+  timeO=runcompare(compareSubImg_thr_sse2_asm, testdata->frames[0], testdata->frames[1],
+                   f, testdata->fi, diffsO, diffsC, numruns);
+  fprintf(stderr,"***thr_asm  time for %i runs: %i ms \tSpeedup %3.2f\n",
+          numruns, timeO, (double)timeC/timeO);
 #endif
 }
diff --git a/tests/test_contrast.c b/tests/test_contrast.c
index 678d582..668e759 100644
--- a/tests/test_contrast.c
+++ b/tests/test_contrast.c
@@ -1,76 +1,76 @@
 #define NUMCNTR 2000
 
 void test_contrastImg(const TestData* testdata){
-	int i;
-	Field f;
-	// difference between michelson and absolute differences from mean
-	//  is large for 100x100 at 500,300
-	f.size=128;
-	f.x = 400;
-	f.y = 300;
-	fprintf(stderr,"********** Contrast:\n");
-	int numruns = NUMCNTR;
-	double contrastC[numruns];
-	double contrastOpt[numruns];
-	int timeC, timeOpt;
+  int i;
+  Field f;
+  // difference between michelson and absolute differences from mean
+  //  is large for 100x100 at 500,300
+  f.size=128;
+  f.x = 400;
+  f.y = 300;
+  fprintf(stderr,"********** Contrast:\n");
+  int numruns = NUMCNTR;
+  double contrastC[numruns];
+  double contrastOpt[numruns];
+  int timeC, timeOpt;
 #ifdef USE_ORC
-	fprintf(stderr,"********** Variance - based Contrast (with ORC):\n");
-	{
-		int start = timeOfDayinMS();
-		for(i=0; i<numruns; i++){
-			contrastC[i]=contrastSubImg_variance_C(testdata->frames[0],
-																						 &f, testdata->fi.width, testdata->fi.height);
-		}
-		int end = timeOfDayinMS();
-		timeC=end-start;
-		fprintf(stderr,"***C    time for %i runs: %i ms ****\n", numruns, timeC);
-	}
-	{
-		int start = timeOfDayinMS();
-		for(i=0; i<numruns; i++){
-			contrastOpt[i]=contrastSubImg_variance_orc(testdata->frames[0],
-																								 &f, testdata->fi.width, testdata->fi.height);
-		}
-		int end = timeOfDayinMS();
-		timeOpt=end-start;
-		fprintf(stderr,"***Orc  time for %i runs: %i ms ****\n", numruns, timeOpt);
-	}
-	fprintf(stderr,"***Speedup %3.2f\n", timeC/timeOpt);
-	for(i=0; i<numruns; i++){
-		if(i==0){
-			printf("Orc contrast %3.2f, C contrast %3.2f\n",contrastOpt[i], contrastC[i]);
-		}
-		test_bool(contrastC[i]==contrastOpt[i]);
-	}
+  fprintf(stderr,"********** Variance - based Contrast (with ORC):\n");
+  {
+    int start = timeOfDayinMS();
+    for(i=0; i<numruns; i++){
+      contrastC[i]=contrastSubImg_variance_C(testdata->frames[0],
+                                             &f, testdata->fi.width, testdata->fi.height);
+    }
+    int end = timeOfDayinMS();
+    timeC=end-start;
+    fprintf(stderr,"***C    time for %i runs: %i ms ****\n", numruns, timeC);
+  }
+  {
+    int start = timeOfDayinMS();
+    for(i=0; i<numruns; i++){
+      contrastOpt[i]=contrastSubImg_variance_orc(testdata->frames[0],
+                                                 &f, testdata->fi.width, testdata->fi.height);
+    }
+    int end = timeOfDayinMS();
+    timeOpt=end-start;
+    fprintf(stderr,"***Orc  time for %i runs: %i ms ****\n", numruns, timeOpt);
+  }
+  fprintf(stderr,"***Speedup %3.2f\n", timeC/timeOpt);
+  for(i=0; i<numruns; i++){
+    if(i==0){
+      printf("Orc contrast %3.2f, C contrast %3.2f\n",contrastOpt[i], contrastC[i]);
+    }
+    test_bool(contrastC[i]==contrastOpt[i]);
+  }
 #endif
-	fprintf(stderr,"********** Michelson Contrast (with SSE2):\n");
-	{
-		int start = timeOfDayinMS();
-		for(i=0; i<numruns; i++){
-			contrastC[i]=contrastSubImg(testdata->frames[0].data[0],
-																	&f, testdata->fi.width, testdata->fi.height,1);
-		}
-		int end = timeOfDayinMS();
-		timeC=end-start;
-		fprintf(stderr,"***C    time for %i runs: %i ms ****\n", numruns, timeC);
-	}
+  fprintf(stderr,"********** Michelson Contrast (with SSE2):\n");
+  {
+    int start = timeOfDayinMS();
+    for(i=0; i<numruns; i++){
+      contrastC[i]=contrastSubImg(testdata->frames[0].data[0],
+                                  &f, testdata->fi.width, testdata->fi.height,1);
+    }
+    int end = timeOfDayinMS();
+    timeC=end-start;
+    fprintf(stderr,"***C    time for %i runs: %i ms ****\n", numruns, timeC);
+  }
 #ifdef USE_SSE2
-	{
-		int start = timeOfDayinMS();
-		for(i=0; i<numruns; i++){
-			contrastOpt[i]=contrastSubImg1_SSE(testdata->frames[0].data[0],
-																				 &f, testdata->fi.width, testdata->fi.height);
-		}
-		int end = timeOfDayinMS();
-		timeOpt=end-start;
-		fprintf(stderr,"***SSE2 time for %i runs: %i ms ****\n", numruns, timeOpt);
-	}
-	fprintf(stderr,"***Speedup %3.2f\n", (float)timeC/(float)timeOpt);
-	for(i=0; i<numruns; i++){
-		if(i==0){
-			printf("SSE2 contrast %3.2f, C contrast %3.2f\n",contrastOpt[i], contrastC[i]);
-		}
-		test_bool(contrastC[i]==contrastOpt[i]);
-	}
+  {
+    int start = timeOfDayinMS();
+    for(i=0; i<numruns; i++){
+      contrastOpt[i]=contrastSubImg1_SSE(testdata->frames[0].data[0],
+                                         &f, testdata->fi.width, testdata->fi.height);
+    }
+    int end = timeOfDayinMS();
+    timeOpt=end-start;
+    fprintf(stderr,"***SSE2 time for %i runs: %i ms ****\n", numruns, timeOpt);
+  }
+  fprintf(stderr,"***Speedup %3.2f\n", (float)timeC/(float)timeOpt);
+  for(i=0; i<numruns; i++){
+    if(i==0){
+      printf("SSE2 contrast %3.2f, C contrast %3.2f\n",contrastOpt[i], contrastC[i]);
+    }
+    test_bool(contrastC[i]==contrastOpt[i]);
+  }
 #endif
 }
diff --git a/tests/test_motiondetect.c b/tests/test_motiondetect.c
index b2a7cb9..d1af3a4 100644
--- a/tests/test_motiondetect.c
+++ b/tests/test_motiondetect.c
@@ -1,37 +1,38 @@
 void test_motionDetect(TestData* testdata){
-	MotionDetect md;
-	test_bool(initMotionDetect(&md, &testdata->fi, "test") == VS_OK);
-	test_bool(configureMotionDetect(&md)== VS_OK);
-	TransformData td;
-	test_bool(initTransformData(&td,
-															&testdata->fi, &testdata->fi, "test") == VS_OK);
-	test_bool(configureTransformData(&td)== VS_OK);
-	fprintf(stderr,"MotionDetect:\n");
-	int numruns =5;
-	int i;
-	//int t;
-	//        for(t = 1; t <= 4; t++){
-	int start = timeOfDayinMS();
-	//      omp_set_dynamic( 0 );
-	//      omp_set_num_threads( t );
+  VSMotionDetectConfig mdconf = vsMotionDetectGetDefaulfConfig("test_motionDetect");
+  VSMotionDetect md;
+  test_bool(vsMotionDetectInit(&md, &mdconf, &testdata->fi) == VS_OK);
 
-	for(i=0; i<numruns; i++){
-		LocalMotions localmotions;
-		Transform t;
-		test_bool(motionDetection(&md, &localmotions,&testdata->frames[i])== VS_OK);
-		/* for(k=0; k < vs_vector_size(&localmotions); k++){ */
-		/* 	localmotion_print(LMGet(&localmotions,k),stderr); */
-		/* } */
-		t = simpleMotionsToTransform(&td, &localmotions);
+  VSTransformConfig tdconf = vsTransformGetDefaulfConfig("test_motionDetect-trans");
+  VSTransformData td;
 
-		vs_vector_del(&localmotions);
-		fprintf(stderr, "%i %6.4lf %6.4lf %8.5lf %6.4lf %i\n",
-						i, t.x, t.y, t.alpha, t.zoom, t.extra);
-		// TODO: here we have to compare with actual transforms!
-	}
-	int end = timeOfDayinMS();
+  test_bool(vsTransformDataInit(&td, &tdconf, &testdata->fi, &testdata->fi) == VS_OK);
+  fprintf(stderr,"MotionDetect:\n");
+  int numruns =5;
+  int i;
+  //int t;
+  //        for(t = 1; t <= 4; t++){
+  int start = timeOfDayinMS();
+  //      omp_set_dynamic( 0 );
+  //      omp_set_num_threads( t );
 
-	fprintf(stderr,"\n*** elapsed time for %i runs: %i ms ****\n", numruns, end-start );
+  for(i=0; i<numruns; i++){
+    LocalMotions localmotions;
+    VSTransform t;
+    test_bool(vsMotionDetection(&md, &localmotions,&testdata->frames[i])== VS_OK);
+    /* for(k=0; k < vs_vector_size(&localmotions); k++){ */
+    /*   localmotion_print(LMGet(&localmotions,k),stderr); */
+    /* } */
+    t = vsSimpleMotionsToTransform(&td, &localmotions);
 
-	cleanupMotionDetection(&md);
+    vs_vector_del(&localmotions);
+    fprintf(stderr, "%i %6.4lf %6.4lf %8.5lf %6.4lf %i\n",
+            i, t.x, t.y, t.alpha, t.zoom, t.extra);
+    // TODO: here we have to compare with actual transforms!
+  }
+  int end = timeOfDayinMS();
+
+  fprintf(stderr,"\n*** elapsed time for %i runs: %i ms ****\n", numruns, end-start );
+
+  vsMotionDetectionCleanup(&md);
 }
diff --git a/tests/test_omp.c b/tests/test_omp.c
index fd49bd9..666606e 100644
--- a/tests/test_omp.c
+++ b/tests/test_omp.c
@@ -19,21 +19,21 @@ int openmptest(){
   return end-start;
 }
 int openmp(){
-	fprintf(stderr, "Processors: %i, Max # theads: %i\n", omp_get_num_procs(), omp_get_max_threads());
+  fprintf(stderr, "Processors: %i, Max # theads: %i\n", omp_get_num_procs(), omp_get_max_threads());
 
-	int time, timeref;
-	omp_set_dynamic( 0 );
-	omp_set_num_threads( 1 );
-	fprintf(stderr,"********** omp speedtest:\n");
-	time = openmptest();
-	fprintf(stderr,"***C    time: %i ms\n",  time);
-	timeref=time;
-	omp_set_dynamic( 0 );
-	omp_set_num_threads( 2 );
-	time = openmptest();
-	fprintf(stderr,"***C (2)time: %i ms, Speedup %f\n", time,
-					(double)timeref/time);
-	omp_set_dynamic( 1 );
-	return 1;
+  int time, timeref;
+  omp_set_dynamic( 0 );
+  omp_set_num_threads( 1 );
+  fprintf(stderr,"********** omp speedtest:\n");
+  time = openmptest();
+  fprintf(stderr,"***C    time: %i ms\n",  time);
+  timeref=time;
+  omp_set_dynamic( 0 );
+  omp_set_num_threads( 2 );
+  time = openmptest();
+  fprintf(stderr,"***C (2)time: %i ms, Speedup %f\n", time,
+          (double)timeref/time);
+  omp_set_dynamic( 1 );
+  return 1;
 }
 #endif
diff --git a/tests/test_store_restore.c b/tests/test_store_restore.c
index 4518cae..1096bf0 100644
--- a/tests/test_store_restore.c
+++ b/tests/test_store_restore.c
@@ -1,69 +1,69 @@
 int compare_localmotions(const LocalMotions* lms1, const LocalMotions* lms2){
-	test_bool(vs_vector_size(lms1) == vs_vector_size(lms2));
-	int i;
-	for(i=0; i<vs_vector_size(lms1); i++){
-		test_bool(LMGet(lms1,i)->v.x == LMGet(lms2,i)->v.x);
-		test_bool(LMGet(lms1,i)->v.y == LMGet(lms2,i)->v.y);
-	}
-	return 1;
+  test_bool(vs_vector_size(lms1) == vs_vector_size(lms2));
+  int i;
+  for(i=0; i<vs_vector_size(lms1); i++){
+    test_bool(LMGet(lms1,i)->v.x == LMGet(lms2,i)->v.x);
+    test_bool(LMGet(lms1,i)->v.y == LMGet(lms2,i)->v.y);
+  }
+  return 1;
 }
 
 int test_store_restore(TestData* testdata){
-	MotionDetect md;
-	test_bool(initMotionDetect(&md, &testdata->fi, "test") == VS_OK);
-	test_bool(configureMotionDetect(&md)== VS_OK);
+  VSMotionDetectConfig mdconf = vsMotionDetectGetDefaulfConfig("test_motionDetect");
+  VSMotionDetect md;
+  test_bool(vsMotionDetectInit(&md, &mdconf, &testdata->fi) == VS_OK);
 
-	LocalMotions lms;
-	int i;
-	for(i=0; i<2; i++){
-		test_bool(motionDetection(&md, &lms,&testdata->frames[i])== VS_OK);
-		if (i==0) vs_vector_del(&lms);
-	}
+  LocalMotions lms;
+  int i;
+  for(i=0; i<2; i++){
+    test_bool(vsMotionDetection(&md, &lms,&testdata->frames[i])== VS_OK);
+    if (i==0) vs_vector_del(&lms);
+  }
 
-	FILE* f = fopen("lmtest","w");
-	storeLocalmotions(f,&lms);
-	fclose(f);
-	f = fopen("lmtest","r");
-	LocalMotions test = restoreLocalmotions(f);
-	fclose(f);
-	storeLocalmotions(stderr,&test);
-	compare_localmotions(&lms,&test);
-	fprintf(stderr,"\n** LM and LMS OKAY\n");
+  FILE* f = fopen("lmtest","w");
+  vsStoreLocalmotions(f,&lms);
+  fclose(f);
+  f = fopen("lmtest","r");
+  LocalMotions test = vsRestoreLocalmotions(f);
+  fclose(f);
+  vsStoreLocalmotions(stderr,&test);
+  compare_localmotions(&lms,&test);
+  fprintf(stderr,"\n** LM and LMS OKAY\n");
 
-	f = fopen("lmstest","w");
-	md.frameNum=1;
-	prepareFile(&md,f);
-	writeToFile(&md,f,&lms);
-	md.frameNum=2;
-	writeToFile(&md,f,&test);
-	fclose(f);
+  f = fopen("lmstest","w");
+  md.frameNum=1;
+  vsPrepareFile(&md,f);
+  vsWriteToFile(&md,f,&lms);
+  md.frameNum=2;
+  vsWriteToFile(&md,f,&test);
+  fclose(f);
 
-	f = fopen("lmstest","r");
-	test_bool(readFileVersion(f)==1);
-	LocalMotions read1;
-	test_bool(readFromFile(f,&read1)==1);
-	compare_localmotions(&lms,&read1);
-	LocalMotions read2;
-	test_bool(readFromFile(f,&read2)==2);
-	compare_localmotions(&test,&read2);
-	fclose(f);
-	fprintf(stderr,"** Reading file stepwise OKAY\n");
-	vs_vector_del(&read1);
-	vs_vector_del(&read2);
-	vs_vector_del(&test);
-	vs_vector_del(&lms);
+  f = fopen("lmstest","r");
+  test_bool(vsReadFileVersion(f)==1);
+  LocalMotions read1;
+  test_bool(vsReadFromFile(f,&read1)==1);
+  compare_localmotions(&lms,&read1);
+  LocalMotions read2;
+  test_bool(vsReadFromFile(f,&read2)==2);
+  compare_localmotions(&test,&read2);
+  fclose(f);
+  fprintf(stderr,"** Reading file stepwise OKAY\n");
+  vs_vector_del(&read1);
+  vs_vector_del(&read2);
+  vs_vector_del(&test);
+  vs_vector_del(&lms);
 
-	f = fopen("lmstest","r");
-	ManyLocalMotions mlms;
-	test_bool(readLocalMotionsFile(f,&mlms)==VS_OK);
-	test_bool(vs_vector_size(&mlms)==2);
-	fprintf(stderr,"** Entire file routine OKAY\n\n");
+  f = fopen("lmstest","r");
+  VSManyLocalMotions mlms;
+  test_bool(vsReadLocalMotionsFile(f,&mlms)==VS_OK);
+  test_bool(vs_vector_size(&mlms)==2);
+  fprintf(stderr,"** Entire file routine OKAY\n\n");
 
-	for(i=0; i< vs_vector_size(&mlms); i++){
-		if(MLMGet(&mlms,i))
-			vs_vector_del(MLMGet(&mlms,i));
-	}
-	vs_vector_del(&mlms);
+  for(i=0; i< vs_vector_size(&mlms); i++){
+    if(VSMLMGet(&mlms,i))
+      vs_vector_del(VSMLMGet(&mlms,i));
+  }
+  vs_vector_del(&mlms);
 
-	return 1;
+  return 1;
 }
diff --git a/tests/test_transform.c b/tests/test_transform.c
index b620e17..d053141 100644
--- a/tests/test_transform.c
+++ b/tests/test_transform.c
@@ -1,8 +1,8 @@
 
 void testImageStripeYUV(int size, VSFrameInfo* fi, VSFrame* img){
   int i,j;
-	initFrameInfo(fi, size, 4, PF_YUV420P);
-  allocateFrame(img,fi);
+  vsFrameInfoInit(fi, size, 4, PF_YUV420P);
+  vsFrameAllocate(img,fi);
   memset(img->data[0],100,sizeof(uint8_t)*fi->width*fi->height);
   for(j=0; j<fi->height; j++){
     for(i=0; i<size; i++){
@@ -25,138 +25,135 @@ void test_transform_implementation(const TestData* testdata){
   VSFrameInfo fi;
   VSFrame src;
   testImageStripeYUV(128,&fi,&src);
-	VSFrame dest;
-	allocateFrame(&dest,&fi);
+  VSFrame dest;
+  vsFrameAllocate(&dest,&fi);
   VSFrame cfinal;
-	allocateFrame(&cfinal,&fi);
-  TransformData td;
+  vsFrameAllocate(&cfinal,&fi);
+  VSTransformData td;
+  VSTransformConfig conf = vsTransformGetDefaulfConfig("test_transform_implementation");
+
   fprintf(stderr,"--- Validate Interpolations ----\n");
 
   int it;
   int i;
   int sum;
-  Transform t;
+  VSTransform t;
   t.x = 10;
   t.alpha = 2*M_PI/(180.0);
 
-  for(it=Zero; it<=BiCubic; it++){
-    copyFrame(&dest, &src, &fi);
-    test_bool(initTransformData(&td, &fi, &fi, "test") == VS_OK);
-    td.interpolType=it;
-    test_bool(configureTransformData(&td)== VS_OK);
+  for(it=VS_Zero; it<=VS_BiCubic; it++){
+    vsFrameCopy(&dest, &src, &fi);
+    conf.interpolType=it;
+    test_bool(vsTransformDataInit(&td, &conf, &fi, &fi) == VS_OK);
 
-    fprintf(stderr,"Transform: %s\n", interpolTypes[it]);
-    test_bool(transformPrepare(&td,&dest,&dest)== VS_OK);
-    test_bool(transformYUV_float(&td, t)== VS_OK);
+    fprintf(stderr,"Transform: %s\n", getInterpolationTypeName(it));
+    test_bool(vsTransformPrepare(&td,&dest,&dest)== VS_OK);
+    test_bool(transformPlanar_float(&td, t)== VS_OK);
 
-    copyFrame(&cfinal,&td.dest,&fi);
-		cleanupTransformData(&td);
+    vsFrameCopy(&cfinal,&td.dest,&fi);
+    vsTransformDataCleanup(&td);
 
-    copyFrame(&dest, &src, &fi);
-    test_bool(initTransformData(&td, &fi, &fi, "test") == VS_OK);
-    td.interpolType=it;
-    test_bool(configureTransformData(&td)== VS_OK);
-    test_bool(transformPrepare(&td,&dest,&dest)== VS_OK);
-    test_bool(transformYUV(&td, t)== VS_OK);
+    vsFrameCopy(&dest, &src, &fi);
+    test_bool(vsTransformDataInit(&td, &conf, &fi, &fi) == VS_OK);
+    test_bool(vsTransformPrepare(&td,&dest,&dest)== VS_OK);
+    test_bool(transformPlanar(&td, t)== VS_OK);
 
     // validate
     sum=0;
     for(i=0; i<fi.width*fi.height; i++){
-			int diff = cfinal.data[0][i] - td.dest.data[0][i];
+      int diff = cfinal.data[0][i] - td.dest.data[0][i];
       if(abs(diff)>2){
-				sum+=abs(diff);
-				printf("%i,%i: %i\n", i/fi.width, i%fi.width, diff);
+        sum+=abs(diff);
+        printf("%i,%i: %i\n", i/fi.width, i%fi.width, diff);
       }
     }
-		cleanupTransformData(&td);
+    vsTransformDataCleanup(&td);
     printf("***Difference: %i\n", sum);
-		test_bool(sum==0);
+    test_bool(sum==0);
   }
-	freeFrame(&dest);
-	freeFrame(&cfinal);
-	freeFrame(&src);
+  vsFrameFree(&dest);
+  vsFrameFree(&cfinal);
+  vsFrameFree(&src);
 }
 
 void test_transform_performance(const TestData* testdata){
 
 
-	fprintf(stderr,"--- Performance of Transforms ----\n");
-	VSFrame dest;
-	VSFrame cfinal;
-	int it;
-	int start, numruns;
-	int timeC, timeCFP; //, timeOrc;
-	allocateFrame(&dest, &testdata->fi);
-	allocateFrame(&cfinal, &testdata->fi);
-	numruns = 5;
-	for(it=Zero; it<=BiCubic; it++){
-		TransformData td;
-		int i;
-		//// Float implementation
-		test_bool(initTransformData(&td, &testdata->fi, &testdata->fi, "test") == VS_OK);
-		td.interpolType=it;
-		test_bool(configureTransformData(&td)== VS_OK);
-
-		fprintf(stderr,"Transform: %s", interpolTypes[it]);
-		start = timeOfDayinMS();
-		for(i=0; i<numruns; i++){
-			Transform t = null_transform();
-			t.x = i*10+10;
-			t.alpha = (i+1)*2*M_PI/(180.0);
-			t.zoom = 0;
-			copyFrame(&dest, &testdata->frames[0], &testdata->fi);
-			test_bool(transformPrepare(&td,&dest,&dest)== VS_OK);
-			test_bool(transformYUV_float(&td, t)== VS_OK);
-		}
-		timeC = timeOfDayinMS() - start;
-		fprintf(stderr,"\n***C   elapsed time for %i runs: %i ms ****\n",
-						numruns, timeC );
-
-		if(it==BiLinear){
-			storePGMImage("transformed.pgm", td.dest.data[0], testdata->fi);
-			storePGMImage("transformed_u.pgm", td.dest.data[1], testdata->fi_color);
-			fprintf(stderr,"stored transformed.pgm\n");
-		}
-		copyFrame(&cfinal,&td.dest,&testdata->fi);
-		cleanupTransformData(&td);
-
-		//// fixed point implementation
-		test_bool(initTransformData(&td, &testdata->fi, &testdata->fi, "test") == VS_OK);
-		td.interpolType=it;
-		test_bool(configureTransformData(&td)== VS_OK);
-		start = timeOfDayinMS();
-		for(i=0; i<numruns; i++){
-			Transform t = null_transform();
-			t.x = i*10+10;
-			t.alpha = (i+1)*2*M_PI/(180.0);
-			t.zoom = 0;
-			copyFrame(&dest, &testdata->frames[0], &testdata->fi);
-			test_bool(transformPrepare(&td,&dest,&dest)== VS_OK);
-			test_bool(transformYUV(&td, t)== VS_OK);
-		}
-		timeCFP = timeOfDayinMS() - start;
-		fprintf(stderr,"***FP  elapsed time for %i runs: %i ms ****\n",
-						numruns, timeCFP );
-		if(it==BiLinear){
-			storePGMImage("transformed_FP.pgm", td.dest.data[0], testdata->fi);
-			storePGMImage("transformed_u_FP.pgm", td.dest.data[1], testdata->fi_color);
-			fprintf(stderr,"stored transformed_FP.pgm\n");
-		}
-		fprintf(stderr,"***Speedup %3.2f\n", (double)timeC/timeCFP);
-		// validate
-		int sum=0;
-		for(i=0; i<testdata->fi.width*testdata->fi.height; i++){
-			int diff = cfinal.data[0][i] - td.dest.data[0][i];
+  VSTransformConfig conf = vsTransformGetDefaulfConfig("test_transform_performance");
+  fprintf(stderr,"--- Performance of Transforms ----\n");
+  VSFrame dest;
+  VSFrame cfinal;
+  int it;
+  int start, numruns;
+  int timeC, timeCFP; //, timeOrc;
+  vsFrameAllocate(&dest, &testdata->fi);
+  vsFrameAllocate(&cfinal, &testdata->fi);
+  numruns = 5;
+  for(it=VS_Zero; it<=VS_BiCubic; it++){
+    VSTransformData td;
+    int i;
+    //// Float implementation
+    conf.interpolType=it;
+    test_bool(vsTransformDataInit(&td, &conf, &testdata->fi, &testdata->fi) == VS_OK);
+
+    fprintf(stderr,"Transform: %s", getInterpolationTypeName(it));
+    start = timeOfDayinMS();
+    for(i=0; i<numruns; i++){
+      VSTransform t = null_transform();
+      t.x = i*10+10;
+      t.alpha = (i+1)*2*M_PI/(180.0);
+      t.zoom = 0;
+      vsFrameCopy(&dest, &testdata->frames[0], &testdata->fi);
+      test_bool(vsTransformPrepare(&td,&dest,&dest)== VS_OK);
+      test_bool(transformPlanar_float(&td, t)== VS_OK);
+    }
+    timeC = timeOfDayinMS() - start;
+    fprintf(stderr,"\n***C   elapsed time for %i runs: %i ms ****\n",
+            numruns, timeC );
+
+    if(it==VS_BiLinear){
+      storePGMImage("transformed.pgm", td.dest.data[0], testdata->fi);
+      storePGMImage("transformed_u.pgm", td.dest.data[1], testdata->fi_color);
+      fprintf(stderr,"stored transformed.pgm\n");
+    }
+    vsFrameCopy(&cfinal,&td.dest,&testdata->fi);
+    vsTransformDataCleanup(&td);
+
+    //// fixed point implementation
+    test_bool(vsTransformDataInit(&td, &conf, &testdata->fi, &testdata->fi) == VS_OK);
+    start = timeOfDayinMS();
+    for(i=0; i<numruns; i++){
+      VSTransform t = null_transform();
+      t.x = i*10+10;
+      t.alpha = (i+1)*2*M_PI/(180.0);
+      t.zoom = 0;
+      vsFrameCopy(&dest, &testdata->frames[0], &testdata->fi);
+      test_bool(vsTransformPrepare(&td,&dest,&dest)== VS_OK);
+      test_bool(transformPlanar(&td, t)== VS_OK);
+    }
+    timeCFP = timeOfDayinMS() - start;
+    fprintf(stderr,"***FP  elapsed time for %i runs: %i ms ****\n",
+            numruns, timeCFP );
+    if(it==VS_BiLinear){
+      storePGMImage("transformed_FP.pgm", td.dest.data[0], testdata->fi);
+      storePGMImage("transformed_u_FP.pgm", td.dest.data[1], testdata->fi_color);
+      fprintf(stderr,"stored transformed_FP.pgm\n");
+    }
+    fprintf(stderr,"***Speedup %3.2f\n", (double)timeC/timeCFP);
+    // validate
+    int sum=0;
+    for(i=0; i<testdata->fi.width*testdata->fi.height; i++){
+      int diff = cfinal.data[0][i] - td.dest.data[0][i];
       if(abs(diff)>2){
-				sum+=abs(diff);
-				//printf("%i,%i: %i\n", i/fi.width, i%fi.width, diff);
+        sum+=abs(diff);
+        //printf("%i,%i: %i\n", i/fi.width, i%fi.width, diff);
       }
     }
-		printf("***Difference: %i\n", sum);
-		cleanupTransformData(&td);
-		test_bool(sum==0);
-	}
+    printf("***Difference: %i\n", sum);
+    vsTransformDataCleanup(&td);
+    test_bool(sum==0);
+  }
 
-	freeFrame(&dest);
-	freeFrame(&cfinal);
+  vsFrameFree(&dest);
+  vsFrameFree(&cfinal);
 }
diff --git a/tests/testframework.c b/tests/testframework.c
index ca6da62..a38851c 100644
--- a/tests/testframework.c
+++ b/tests/testframework.c
@@ -6,16 +6,16 @@
 int help_mode=0;
 
 void unittest_help_mode(){
-	help_mode=1;
+  help_mode=1;
 }
 
 // returns 0 of not found and otherwise the index of the next element (possible argument)
 int contains(char **list, int len,  const char *str, const char* descr) {
-	if(help_mode) {
-		printf("\t%s:\t%s\n",str, descr);
-		return 0;
-	}
-	int i;
+  if(help_mode) {
+    printf("\t%s:\t%s\n",str, descr);
+    return 0;
+  }
+  int i;
   for(i=0; i<len; i++) {
     if(strcmp(list[i],str) == 0)
       return i+1;
@@ -27,16 +27,16 @@ int units_success;
 int units_failed;
 
 void unittest_init(){
-	units_success=0;
-	units_failed=0;
+  units_success=0;
+  units_failed=0;
 }
 
 int unittest_summary(){
-	fprintf(stderr, "*********** SUMMARY **************\n");
-	fprintf(stderr, "UNIT TESTs succeeded:\t %s%i/%i\033[0m\n",
-					units_failed>0 ? "\033[1;31m" : "\033[1;32m",
-					units_success, units_success + units_failed);
-	return units_failed==0;
+  fprintf(stderr, "*********** SUMMARY **************\n");
+  fprintf(stderr, "UNIT TESTs succeeded:\t %s%i/%i\033[0m\n",
+          units_failed>0 ? "\033[1;31m" : "\033[1;32m",
+          units_success, units_success + units_failed);
+  return units_failed==0;
 
 }
 
@@ -51,19 +51,19 @@ int tests_success;
 int tests_failed;
 
 void tests_init(){
-	tests_success=0;
-	tests_failed=0;
+  tests_success=0;
+  tests_failed=0;
 }
 
 
 int test_summary(){
-	fprintf(stderr, "Tests checks succeeded: %i/%i",
-					tests_success, tests_success + tests_failed);
-	return tests_failed==0;
+  fprintf(stderr, "Tests checks succeeded: %i/%i",
+          tests_success, tests_success + tests_failed);
+  return tests_failed==0;
 }
 
 void test_fails (__const char *__assertion, __const char *__file,
-								 unsigned int __line, __const char *__function){
-	fprintf(stderr, "%s:%i: Test Failed: %s\n in Function %s", __file,__line,__assertion,__function);
-	tests_failed++;
+                 unsigned int __line, __const char *__function){
+  fprintf(stderr, "%s:%i: Test Failed: %s\n in Function %s", __file,__line,__assertion,__function);
+  tests_failed++;
 }
diff --git a/tests/testframework.h b/tests/testframework.h
index cf48be4..6997f6a 100644
--- a/tests/testframework.h
+++ b/tests/testframework.h
@@ -12,26 +12,26 @@ void unittest_help_mode();
 long timeOfDayinMS();
 
 
-#define test_bool(expr)	 \
-  ((expr)								 \
-   ? tests_success++		 \
+#define test_bool(expr)   \
+  ((expr)                 \
+   ? tests_success++     \
    : test_fails (__STRING(expr), __FILE__, __LINE__, ___FUNCTION))
 
-#define UNIT(func)																															 \
-	if(!help_mode){tests_init();																							\
-	 fprintf(stderr,"\033[1;34m*** UNIT TEST %s ***\033[0m\n",__STRING(func));		 \
-	 (func);																																			 \
-	 fprintf(stderr,"---->\t");																										 \
-	 if(test_summary()){ fprintf(stderr, "\t\t\033[1;32m PASSED\033[0m\n");				 \
-		 units_success++; }																													 \
-	 else { fprintf(stderr, "\t\t\033[1;31m FAILED\033[0m !!!!!\n");							 \
-		 units_failed++;	}																													 \
-	 }
+#define UNIT(func)                                                               \
+  if(!help_mode){tests_init();                                              \
+   fprintf(stderr,"\033[1;34m*** UNIT TEST %s ***\033[0m\n",__STRING(func));     \
+   (func);                                                                       \
+   fprintf(stderr,"---->\t");                                                     \
+   if(test_summary()){ fprintf(stderr, "\t\t\033[1;32m PASSED\033[0m\n");         \
+     units_success++; }                                                           \
+   else { fprintf(stderr, "\t\t\033[1;31m FAILED\033[0m !!!!!\n");               \
+     units_failed++;  }                                                           \
+   }
 
 #if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
-# define ___FUNCTION	__func__
+# define ___FUNCTION  __func__
 #else
-# define ___FUNCTION	((__const char *) 0)
+# define ___FUNCTION  ((__const char *) 0)
 #endif
 
 
@@ -48,7 +48,7 @@ void tests_init();
 int test_summary();
 
 void test_fails (__const char *__assertion, __const char *__file,
-								 unsigned int __line, __const char *__function);
+                 unsigned int __line, __const char *__function);
 
 
 
diff --git a/tests/tests.c b/tests/tests.c
index dd5f6fc..f44c7e5 100644
--- a/tests/tests.c
+++ b/tests/tests.c
@@ -1,4 +1,5 @@
 
+#include <string.h>
 #include <stdio.h>
 #include <limits.h>
 #include <features.h>
@@ -9,7 +10,12 @@
 
 #include "libvidstab.h"
 // load optimized functions
+#include "motiondetect_internal.h"
 #include "motiondetect_opt.h"
+#include "boxblur.h"
+#include "transformfixedpoint.h"
+#include "transformfloat.h"
+#include "transformtype_operations.h"
 
 #ifndef TESTING
 #error TESTING must be defined
@@ -30,81 +36,81 @@
 
 int main(int argc, char** argv){
 
-	if(contains(argv,argc,"-h", "help")!=0){
-		printf("Usage: %s [--store --load] [--all| --testX ...]\n", argv[0]);
-		unittest_help_mode();
-	}
+  if(contains(argv,argc,"-h", "help")!=0){
+    printf("Usage: %s [--store --load] [--all| --testX ...]\n", argv[0]);
+    unittest_help_mode();
+  }
 
-	unittest_init();
+  unittest_init();
 
-	int all = contains(argv,argc,"--all", "Perform all tests")!=0;
+  int all = contains(argv,argc,"--all", "Perform all tests")!=0;
 
-	TestData testdata;
-	initFrameInfo(&testdata.fi,1280, 720, PF_YUV420P);
-	initFrameInfo(&testdata.fi_color, 640, 360, PF_GRAY8);
+  TestData testdata;
+  vsFrameInfoInit(&testdata.fi,1280, 720, PF_YUV420P);
+  vsFrameInfoInit(&testdata.fi_color, 640, 360, PF_GRAY8);
 
   if(contains(argv,argc,"--load",
-							"Load frames from files from frames/frame001.raw (def: generate)")!=0){
+              "Load frames from files from frames/frame001.raw (def: generate)")!=0){
     FILE* file;
     char name[128];
-		int i;
+    int i;
     for(i=0; i<5; i++){
-      allocateFrame(&testdata.frames[i],&testdata.fi);
+      vsFrameAllocate(&testdata.frames[i],&testdata.fi);
       sprintf(name,"../frames/frame%03i.raw",i+4);
       fprintf(stderr, "load file %s\n", name);
       file = fopen(name,"rb");
       test_bool(file!=0);
       fprintf(stderr,"read %li bytes\n",
-							(unsigned long)fread(testdata.frames[i].data[0], 1,
-																	 testdata.fi.width*testdata.fi.height,file));
+              (unsigned long)fread(testdata.frames[i].data[0], 1,
+                                   testdata.fi.width*testdata.fi.height,file));
       fclose(file);
     }
   }else{
-		UNIT(generateFrames(&testdata, 5));
+    UNIT(generateFrames(&testdata, 5));
+  }
+  if(contains(argv,argc,"--store", "Store frames to files")!=0){
+    storePGMImage("test1.pgm", testdata.frames[0].data[0], testdata.fi);
+    storePGMImage("test2.pgm", testdata.frames[1].data[0], testdata.fi);
+    storePGMImage("test3.pgm", testdata.frames[2].data[0], testdata.fi);
+    storePGMImage("test4.pgm", testdata.frames[3].data[0], testdata.fi);
+    storePGMImage("test5.pgm", testdata.frames[4].data[0], testdata.fi);
   }
-	if(contains(argv,argc,"--store", "Store frames to files")!=0){
-		storePGMImage("test1.pgm", testdata.frames[0].data[0], testdata.fi);
-		storePGMImage("test2.pgm", testdata.frames[1].data[0], testdata.fi);
-		storePGMImage("test3.pgm", testdata.frames[2].data[0], testdata.fi);
-		storePGMImage("test4.pgm", testdata.frames[3].data[0], testdata.fi);
-		storePGMImage("test5.pgm", testdata.frames[4].data[0], testdata.fi);
-	}
 
 #ifdef USE_OMP
   openmp();
 #endif
 
   if(all || contains(argv,argc,"--testTI", "transform_implementation")){
-		UNIT(test_transform_implementation(&testdata));
-	}
+    UNIT(test_transform_implementation(&testdata));
+  }
 
   if(all || contains(argv,argc,"--testTP", "transform_performance")){
-		UNIT(test_transform_performance(&testdata));
-	}
+    UNIT(test_transform_performance(&testdata));
+  }
 
   if(all || contains(argv,argc,"--testBB", "boxblur")){
-		UNIT(test_boxblur(&testdata));
-	}
+    UNIT(test_boxblur(&testdata));
+  }
 
   if(all || contains(argv,argc,"--testCCI", "checkCompareImg")){
-		UNIT(test_checkCompareImg(&testdata));
-	}
+    UNIT(test_checkCompareImg(&testdata));
+  }
 
   if(all || contains(argv,argc,"--testCIP", "compareImg_performance")){
-		UNIT(test_compareImg_performance(&testdata));
-	}
+    UNIT(test_compareImg_performance(&testdata));
+  }
 
   if(all || contains(argv,argc,"--testMD", "motionDetect")){
-		UNIT(test_motionDetect(&testdata));
-	}
+    UNIT(test_motionDetect(&testdata));
+  }
 
   if(all || contains(argv,argc,"--testSR", "store_restore")){
-		UNIT(test_store_restore(&testdata));
-	}
+    UNIT(test_store_restore(&testdata));
+  }
 
   if(all || contains(argv,argc,"--testCT", "contrastImg")){
-		UNIT(test_contrastImg(&testdata));
-	}
+    UNIT(test_contrastImg(&testdata));
+  }
 
-	return unittest_summary();
+  return unittest_summary();
 }
diff --git a/tests/testutils.c b/tests/testutils.c
index c60861d..2af4a7d 100644
--- a/tests/testutils.c
+++ b/tests/testutils.c
@@ -2,13 +2,14 @@
 
 #include "testutils.h"
 #include "libvidstab.h"
+#include "transformtype_operations.h"
 
 void paintRectangle(unsigned char* buffer, const VSFrameInfo* fi, int x, int y, int sizex, int sizey, unsigned char color){
   if(x>=0 && x+sizex < fi->width && y>=0 && y+sizey < fi->height){
     int i,j;
     for(j=y; j < y+sizey; j++){
       for(i=x; i<x+sizex; i++){
-	buffer[j*fi->width + i] = color;
+  buffer[j*fi->width + i] = color;
       }
     }
 
@@ -27,8 +28,8 @@ void fillArrayWithNoise(unsigned char* buffer, int length, float corr){
   }
 }
 
-Transform getTestFrameTransform(int i){
-  Transform t = null_transform();
+VSTransform getTestFrameTransform(int i){
+  VSTransform t = null_transform();
   t.x = ( (i%2)==0 ? -1 : 1)  *i*5;
   t.y = ( (i%3)==0 ?  1 : -1) *i*5;
   t.alpha = (i<3 ? 0 : 1) * (i)*1*M_PI/(180.0);
@@ -63,9 +64,9 @@ static void skipWhiteSpace (const char* filename, FILE *f)
     // skip comments
     if (c == '#') {
       do {
-	d = fgetc(f);
-	if (d==EOF)
-	  vs_log_error("TEST", "unexpected end of file in '%s'", filename);
+  d = fgetc(f);
+  if (d==EOF)
+    vs_log_error("TEST", "unexpected end of file in '%s'", filename);
       } while (d != '\n');
       continue;
     }
@@ -117,7 +118,7 @@ int loadPGMImage(const char* filename, VSFrame* frame, VSFrameInfo* fi)
 
 
   // read in rest of data
-	allocateFrame(frame,fi);
+  vsFrameAllocate(frame,fi);
   if (fread( frame->data[0], fi->width*fi->height, 1, f) != 1){
     vs_log_error("TEST", "Can't read data from image file '%s'", filename);
     return 0;
diff --git a/tests/testutils.h b/tests/testutils.h
index 827af65..c7429a1 100644
--- a/tests/testutils.h
+++ b/tests/testutils.h
@@ -10,12 +10,12 @@ typedef struct _test_data {
 } TestData;
 
 
-Transform getTestFrameTransform(int i);
+VSTransform getTestFrameTransform(int i);
 
 void fillArrayWithNoise(unsigned char* buffer, int length, float corr);
 
 void paintRectangle(unsigned char* buffer, const VSFrameInfo* fi, int x, int y,
-										int sizex, int sizey, unsigned char color);
+                    int sizex, int sizey, unsigned char color);
 
 inline static unsigned char randPixel(){
   return rand()%256;
diff --git a/transcode/cmake/install.sh b/transcode/cmake/install.sh
index 3344d1d..1543542 100644
--- a/transcode/cmake/install.sh
+++ b/transcode/cmake/install.sh
@@ -1,15 +1,14 @@
 #!/bin/bash
 
-PATHS=/usr/lib/transcode /usr/local/lib/transcode $HOME/lib/transcode
+PATHS="/usr/lib/transcode /usr/local/lib/transcode $HOME/lib/transcode"
 for D in $PATHS; do
-    if [ -d $D ]; then
+    if [ -d "$D" ]; then
         echo -n "Do you want to install the plugins to $D ? [y/N] ";
         read choice
         if [ "$choice" = "y" ]; then
-            echo  "Checking PATH variable: "	
-            SUDO=
-            if [ ! -w $(PREFIX) ]; then SUDO=sudo; fi
-	    $(SUDO) cp --backup=numbered ./filter_stabilize.so ./filter_transform.so ./filter_deshake.so "$D/"
+            echo  "Checking PATH variable: "
+            if [ ! -w "$D" ]; then SUDO=sudo; fi
+            ${SUDO} cp --backup=numbered ./filter_stabilize.so ./filter_transform.so ./filter_deshake.so "$D/"
         fi
     fi
 done
\ No newline at end of file
diff --git a/transcode/filter_deshake.c b/transcode/filter_deshake.c
index 3b95cf8..f5f060b 100644
--- a/transcode/filter_deshake.c
+++ b/transcode/filter_deshake.c
@@ -39,7 +39,7 @@
 
 #define MOD_FEATURES                                    \
   TC_MODULE_FEATURE_FILTER|TC_MODULE_FEATURE_VIDEO
-#define MOD_FLAGS					\
+#define MOD_FLAGS          \
   TC_MODULE_FLAG_RECONFIGURABLE | TC_MODULE_FLAG_DELAY
 
 #define DEFAULT_TRANS_FILE_NAME     "transforms.dat"
@@ -55,14 +55,15 @@
 #include "libtc/tccodecs.h"
 #include "libtc/tcmodule-plugin.h"
 
-#include "pix_formats.h"
+#include "transcode_specifics.h"
 
 /* private date structure of this filter*/
 typedef struct _deshake_data {
-  MotionDetect md;
-  TransformData td;
-  SlidingAvgTrans avg;
+  VSMotionDetect md;
+  VSTransformData td;
+  VSSlidingAvgTrans avg;
 
+  double sharpen;     // amount of sharpening
   vob_t* vob;  // pointer to information structure
   char* result;
   FILE* f;
@@ -121,6 +122,8 @@ static int deshake_init(TCModuleInstance *self, uint32_t features)
   TC_MODULE_SELF_CHECK(self, "init");
   TC_MODULE_INIT_CHECK(self, MOD_FEATURES, features);
 
+  setLogFunctions();
+
   sd = tc_zalloc(sizeof(DeshakeData)); // allocation with zero values
   if (!sd) {
     if (verbose > TC_INFO)
@@ -163,7 +166,7 @@ static int deshake_fini(TCModuleInstance *self)
  * tcmodule-data.h for function details.
  */
 static int deshake_configure(TCModuleInstance *self,
-			     const char *options, vob_t *vob)
+           const char *options, vob_t *vob)
 {
   DeshakeData *sd = NULL;
   TC_MODULE_SELF_CHECK(self, "configure");
@@ -172,20 +175,19 @@ static int deshake_configure(TCModuleInstance *self,
   sd = self->userdata;
 
   /*    sd->framesize = sd->vob->im_v_width * MAX_PLANES *
-	sizeof(char) * 2 * sd->vob->im_v_height * 2;     */
+  sizeof(char) * 2 * sd->vob->im_v_height * 2;     */
 
-  MotionDetect* md = &(sd->md);
-  TransformData* td = &(sd->td);
+  VSMotionDetect* md = &(sd->md);
+  VSTransformData* td = &(sd->td);
 
-  // init MotionDetect part
+  // init VSMotionDetect part
   VSFrameInfo fi;
-  initFrameInfo(&fi, sd->vob->ex_v_width, sd->vob->ex_v_height,
+  vsFrameInfoInit(&fi, sd->vob->ex_v_width, sd->vob->ex_v_height,
                 transcode2ourPF(sd->vob->im_v_codec));
 
-  if(initMotionDetect(md, &fi, MOD_NAME) != VS_OK){
-    tc_log_error(MOD_NAME, "initialization of Motion Detection failed");
-    return TC_ERROR;
-  }
+  VSMotionDetectConfig  mdconf = vsMotionDetectGetDefaulfConfig(MOD_NAME);
+  VSTransformConfig tdconf     = vsTransformGetDefaulfConfig(MOD_NAME);
+  tdconf.verbose=verbose;
 
   sd->result = tc_malloc(TC_BUF_LINE);
   filenamecopy = tc_strdup(sd->vob->video_in_file);
@@ -194,22 +196,15 @@ static int deshake_configure(TCModuleInstance *self,
     tc_snprintf(sd->result, TC_BUF_LINE, "%s.trf", filebasename);
   } else {
     tc_log_warn(MOD_NAME, "input name too long, using default `%s'",
-		DEFAULT_TRANS_FILE_NAME);
+    DEFAULT_TRANS_FILE_NAME);
     tc_snprintf(sd->result, TC_BUF_LINE, DEFAULT_TRANS_FILE_NAME);
   }
 
   // init trasform part
   VSFrameInfo fi_dest;
-  initFrameInfo(&fi_dest, sd->vob->ex_v_width, sd->vob->ex_v_height,
+  vsFrameInfoInit(&fi_dest, sd->vob->ex_v_width, sd->vob->ex_v_height,
                 transcode2ourPF(sd->vob->im_v_codec));
 
-  if(initTransformData(td, &fi, &fi_dest, MOD_NAME) != VS_OK){
-    tc_log_error(MOD_NAME, "initialization of TransformData failed");
-    return TC_ERROR;
-  }
-  td->verbose=verbose;
-
-
   if (options != NULL) {
     // for some reason this plugin is called in the old fashion
     //  (not with inspect). Anyway we support both ways of getting help.
@@ -219,54 +214,57 @@ static int deshake_configure(TCModuleInstance *self,
     }
 
     optstr_get(options, "result",     "%[^:]", sd->result);
-    optstr_get(options, "shakiness",  "%d", &md->shakiness);
-    optstr_get(options, "accuracy",   "%d", &md->accuracy);
-    optstr_get(options, "stepsize",   "%d", &md->stepSize);
-    optstr_get(options, "algo",       "%d", &md->algo);
-    optstr_get(options, "mincontrast","%lf",&md->contrastThreshold);
-    md->show = 0;
-
-    optstr_get(options, "maxshift",  "%d", &td->maxShift);
-    optstr_get(options, "maxangle",  "%lf", &td->maxAngle);
-    optstr_get(options, "smoothing", "%d", &td->smoothing);
-    optstr_get(options, "crop"     , "%d", (int*)&td->crop);
-    optstr_get(options, "zoom"     , "%lf",&td->zoom);
-    optstr_get(options, "optzoom"  , "%d", &td->optZoom);
-    optstr_get(options, "interpol" , "%d", (int*)(&td->interpolType));
-    optstr_get(options, "sharpen"  , "%lf",&td->sharpen);
-    td->relative=1;
-    td->invert=0;
+    optstr_get(options, "shakiness",  "%d", &mdconf.shakiness);
+    optstr_get(options, "accuracy",   "%d", &mdconf.accuracy);
+    optstr_get(options, "stepsize",   "%d", &mdconf.stepSize);
+    optstr_get(options, "algo",       "%d", &mdconf.algo);
+    optstr_get(options, "mincontrast","%lf",&mdconf.contrastThreshold);
+    mdconf.show = 0;
+
+    optstr_get(options, "maxshift",  "%d", &tdconf.maxShift);
+    optstr_get(options, "maxangle",  "%lf",&tdconf.maxAngle);
+    optstr_get(options, "smoothing", "%d", &tdconf.smoothing);
+    optstr_get(options, "crop"     , "%d", (int*)&tdconf.crop);
+    optstr_get(options, "zoom"     , "%lf",&tdconf.zoom);
+    optstr_get(options, "optzoom"  , "%d", &tdconf.optZoom);
+    optstr_get(options, "interpol" , "%d", (int*)(&tdconf.interpolType));
+    optstr_get(options, "sharpen"  , "%lf",&sd->sharpen);
+    tdconf.relative=1;
+    tdconf.invert=0;
   }
 
-  if(configureMotionDetect(md)!= VS_OK){
-    tc_log_error(MOD_NAME, "configuration of Motion Detection failed");
+  if(vsMotionDetectInit(md, &mdconf, &fi) != VS_OK){
+    tc_log_error(MOD_NAME, "initialization of Motion Detection failed");
     return TC_ERROR;
   }
-  if(configureTransformData(td)!= VS_OK){
-    tc_log_error(MOD_NAME, "configuration of Tranform failed");
+  vsMotionDetectGetConfig(&mdconf,md);
+
+  if(vsTransformDataInit(td, &tdconf, &fi, &fi_dest) != VS_OK){
+    tc_log_error(MOD_NAME, "initialization of VSTransformData failed");
     return TC_ERROR;
   }
+  vsTransformGetConfig(&tdconf, td);
 
   if (verbose) {
     tc_log_info(MOD_NAME, "Video Deshake  Settings:");
-    tc_log_info(MOD_NAME, "    smoothing = %d", td->smoothing);
-    tc_log_info(MOD_NAME, "    shakiness = %d", md->shakiness);
-    tc_log_info(MOD_NAME, "     accuracy = %d", md->accuracy);
-    tc_log_info(MOD_NAME, "     stepsize = %d", md->stepSize);
-    tc_log_info(MOD_NAME, "         algo = %d", md->algo);
-    tc_log_info(MOD_NAME, "  mincontrast = %f", md->contrastThreshold);
-    tc_log_info(MOD_NAME, "         show = %d", md->show);
+    tc_log_info(MOD_NAME, "    smoothing = %d", tdconf.smoothing);
+    tc_log_info(MOD_NAME, "    shakiness = %d", mdconf.shakiness);
+    tc_log_info(MOD_NAME, "     accuracy = %d", mdconf.accuracy);
+    tc_log_info(MOD_NAME, "     stepsize = %d", mdconf.stepSize);
+    tc_log_info(MOD_NAME, "         algo = %d", mdconf.algo);
+    tc_log_info(MOD_NAME, "  mincontrast = %f", mdconf.contrastThreshold);
+    tc_log_info(MOD_NAME, "         show = %d", mdconf.show);
     tc_log_info(MOD_NAME, "       result = %s", sd->result);
-    tc_log_info(MOD_NAME, "    maxshift  = %d", td->maxShift);
-    tc_log_info(MOD_NAME, "    maxangle  = %f", td->maxAngle);
+    tc_log_info(MOD_NAME, "    maxshift  = %d", tdconf.maxShift);
+    tc_log_info(MOD_NAME, "    maxangle  = %f", tdconf.maxAngle);
     tc_log_info(MOD_NAME, "         crop = %s",
-		td->crop ? "Black" : "Keep");
-    tc_log_info(MOD_NAME, "         zoom = %f", td->zoom);
+                tdconf.crop ? "Black" : "Keep");
+    tc_log_info(MOD_NAME, "         zoom = %f", tdconf.zoom);
     tc_log_info(MOD_NAME, "      optzoom = %s",
-		td->optZoom ? "On" : "Off");
+                tdconf.optZoom ? "On" : "Off");
     tc_log_info(MOD_NAME, "     interpol = %s",
-		interpolTypes[td->interpolType]);
-    tc_log_info(MOD_NAME, "      sharpen = %f", td->sharpen);
+                getInterpolationTypeName(tdconf.interpolType));
+    tc_log_info(MOD_NAME, "      sharpen = %f", sd->sharpen);
 
   }
 
@@ -288,7 +286,7 @@ static int deshake_configure(TCModuleInstance *self,
  */
 
 static int deshake_filter_video(TCModuleInstance *self,
-				vframe_list_t *frame)
+                                vframe_list_t *frame)
 {
   DeshakeData *sd = NULL;
 
@@ -296,38 +294,35 @@ static int deshake_filter_video(TCModuleInstance *self,
   TC_MODULE_SELF_CHECK(frame, "filter_video");
 
   sd = self->userdata;
-  MotionDetect* md = &(sd->md);
-  TransformData* td = &(sd->td);
+  VSMotionDetect* md = &(sd->md);
+  VSTransformData* td = &(sd->td);
   LocalMotions localmotions;
-  Transform motion;
+  VSTransform motion;
   VSFrame vsFrame;
-  fillFrameFromBuffer(&vsFrame,frame->video_buf, &td->fiSrc);
+  vsFrameFillFromBuffer(&vsFrame,frame->video_buf, &md->fi);
 
-  if(motionDetection(md, &localmotions, &vsFrame)!= VS_OK){
-    tc_log_error(MOD_NAME, "motion detection failed");
-    return TC_ERROR;
+  if(vsMotionDetection(md, &localmotions, &vsFrame)!= VS_OK){
+      tc_log_error(MOD_NAME, "motion detection failed");
+      return TC_ERROR;
   }
 
-  if(writeToFile(md, sd->f, &localmotions) != VS_OK)
-  motion = simpleMotionsToTransform(td, &localmotions);
+  if(vsWriteToFile(md, sd->f, &localmotions) != VS_OK){
+      tc_log_error(MOD_NAME, "cannot write to file!");
+      return TC_ERROR;
+  }
+  motion = vsSimpleMotionsToTransform(td, &localmotions);
   vs_vector_del(&localmotions);
 
-  transformPrepare(td, &vsFrame, &vsFrame);
+  vsTransformPrepare(td, &vsFrame, &vsFrame);
 
-  Transform t = lowPassTransforms(td, &sd->avg, &motion);
-  /* tc_log_error(MOD_NAME, "Trans: det: %f %f %f \n\t\t act: %f %f %f %f",  */
-  /* 	       motion.x, motion.y, motion.alpha, */
-  /* 	       t.x, t.y, t.alpha, t.zoom); */
+  VSTransform t = vsLowPassTransforms(td, &sd->avg, &motion);
+  /* tc_log_info(MOD_NAME, "Trans: det: %f %f %f \n\t\t act: %f %f %f %f", */
+  /*             motion.x, motion.y, motion.alpha, */
+  /*             t.x, t.y, t.alpha, t.zoom); */
 
-  if (sd->vob->im_v_codec == CODEC_RGB) {
-    transformRGB(td, t);
-  } else if (sd->vob->im_v_codec == CODEC_YUV) {
-    transformYUV(td, t);
-  } else {
-    tc_log_error(MOD_NAME, "unsupported Codec: %i\n", sd->vob->im_v_codec);
-    return TC_ERROR;
-  }
-  transformFinish(td);
+  vsDoTransform(td, t);
+
+  vsTransformFinish(td);
   return TC_OK;
 }
 
@@ -347,23 +342,23 @@ static int deshake_stop(TCModuleInstance *self)
     sd->f = NULL;
   }
 
-  cleanupMotionDetection(&sd->md);
+  vsMotionDetectionCleanup(&sd->md);
   if (sd->result) {
     tc_free(sd->result);
     sd->result = NULL;
   }
 
-  cleanupTransformData(&sd->td);
+  vsTransformDataCleanup(&sd->td);
 
   return TC_OK;
 }
 
 /* checks for parameter in function _inspect */
 #define CHECKPARAM(paramname, formatstring, variable)   \
-  if (optstr_lookup(param, paramname)) {		\
-    tc_snprintf(sd->conf_str, sizeof(sd->conf_str),	\
-		formatstring, variable);		\
-    *value = sd->conf_str;				\
+  if (optstr_lookup(param, paramname)) {    \
+    tc_snprintf(sd->conf_str, sizeof(sd->conf_str),  \
+    formatstring, variable);    \
+    *value = sd->conf_str;        \
   }
 
 /**
@@ -372,7 +367,7 @@ static int deshake_stop(TCModuleInstance *self)
  */
 
 static int deshake_inspect(TCModuleInstance *self,
-			   const char *param, const char **value)
+         const char *param, const char **value)
 {
   DeshakeData *sd = NULL;
 
@@ -380,23 +375,27 @@ static int deshake_inspect(TCModuleInstance *self,
   TC_MODULE_SELF_CHECK(param, "inspect");
   TC_MODULE_SELF_CHECK(value, "inspect");
   sd = self->userdata;
-  MotionDetect* md = &(sd->md);
+
+  VSMotionDetectConfig mdconf;
+  vsMotionDetectGetConfig(&mdconf,&(sd->md));
+  VSTransformConfig tdconf;
+  vsTransformGetConfig(&tdconf,&sd->td);
   if (optstr_lookup(param, "help")) {
     *value = deshake_help;
   }
-  CHECKPARAM("shakiness","shakiness=%d", md->shakiness);
-  CHECKPARAM("accuracy", "accuracy=%d",  md->accuracy);
-  CHECKPARAM("stepsize", "stepsize=%d",  md->stepSize);
-  CHECKPARAM("allowmax", "allowmax=%d",  md->allowMax);
-  CHECKPARAM("algo",     "algo=%d",      md->algo);
+
+  CHECKPARAM("shakiness","shakiness=%d", mdconf.shakiness);
+  CHECKPARAM("accuracy", "accuracy=%d",  mdconf.accuracy);
+  CHECKPARAM("stepsize", "stepsize=%d",  mdconf.stepSize);
+  CHECKPARAM("algo",     "algo=%d",      mdconf.algo);
   CHECKPARAM("result",   "result=%s",    sd->result);
-  CHECKPARAM("maxshift", "maxshift=%d",  sd->td.maxShift);
-  CHECKPARAM("maxangle", "maxangle=%f",  sd->td.maxAngle);
-  CHECKPARAM("smoothing","smoothing=%d", sd->td.smoothing);
-  CHECKPARAM("crop",     "crop=%d",      sd->td.crop);
-  CHECKPARAM("optzoom",  "optzoom=%i",   sd->td.optZoom);
-  CHECKPARAM("zoom",     "zoom=%f",      sd->td.zoom);
-  CHECKPARAM("sharpen",  "sharpen=%f",   sd->td.sharpen);
+  CHECKPARAM("maxshift", "maxshift=%d",  tdconf.maxShift);
+  CHECKPARAM("maxangle", "maxangle=%f",  tdconf.maxAngle);
+  CHECKPARAM("smoothing","smoothing=%d", tdconf.smoothing);
+  CHECKPARAM("crop",     "crop=%d",      tdconf.crop);
+  CHECKPARAM("optzoom",  "optzoom=%i",   tdconf.optZoom);
+  CHECKPARAM("zoom",     "zoom=%f",      tdconf.zoom);
+  CHECKPARAM("sharpen",  "sharpen=%f",   sd->sharpen);
 
   return TC_OK;
 }
@@ -432,7 +431,7 @@ static int deshake_get_config(TCModuleInstance *self, char *options)
   TC_MODULE_SELF_CHECK(self, "get_config");
 
   optstr_filter_desc(options, MOD_NAME, MOD_CAP, MOD_VERSION,
-		     MOD_AUTHOR, "VRY4", "1");
+         MOD_AUTHOR, "VRY4", "1");
 
   return TC_OK;
 }
@@ -459,7 +458,8 @@ TC_FILTER_OLDINTERFACE(deshake)
  *   c-file-style: "stroustrup"
  *   c-file-offsets: ((case-label . *) (statement-case-intro . *))
  *   indent-tabs-mode: nil
+ *   c-basic-offset: 2 t
  * End:
  *
- * vim: expandtab shiftwidth=4:
+ * vim: expandtab shiftwidth=2:
  */
diff --git a/transcode/filter_stabilize.c b/transcode/filter_stabilize.c
index 90ca1bf..abda46b 100644
--- a/transcode/filter_stabilize.c
+++ b/transcode/filter_stabilize.c
@@ -62,11 +62,11 @@
 #include "libtc/tccodecs.h"
 #include "libtc/tcmodule-plugin.h"
 
-#include "pix_formats.h"
+#include "transcode_specifics.h"
 
 /* private date structure of this filter*/
 typedef struct _stab_data {
-    MotionDetect md;
+    VSMotionDetect md;
     vob_t* vob;  // pointer to information structure
 
     char* result;
@@ -92,6 +92,8 @@ static int stabilize_init(TCModuleInstance *self, uint32_t features)
     TC_MODULE_SELF_CHECK(self, "init");
     TC_MODULE_INIT_CHECK(self, MOD_FEATURES, features);
 
+    setLogFunctions();
+
     sd = tc_zalloc(sizeof(StabData)); // allocation with zero values
     if (!sd) {
         if (verbose > TC_INFO)
@@ -145,15 +147,12 @@ static int stabilize_configure(TCModuleInstance *self,
     /*    sd->framesize = sd->vob->im_v_width * MAX_PLANES *
           sizeof(char) * 2 * sd->vob->im_v_height * 2;     */
 
-    MotionDetect* md = &(sd->md);
+    VSMotionDetect* md = &(sd->md);
     VSFrameInfo fi;
-    initFrameInfo(&fi, sd->vob->ex_v_width, sd->vob->ex_v_height,
+    vsFrameInfoInit(&fi, sd->vob->ex_v_width, sd->vob->ex_v_height,
                   transcode2ourPF(vob->im_v_codec));
 
-    if(initMotionDetect(md, &fi, MOD_NAME) != VS_OK){
-        tc_log_error(MOD_NAME, "initialization of Motion Detection failed");
-        return TC_ERROR;
-    }
+    VSMotionDetectConfig conf = vsMotionDetectGetDefaulfConfig(MOD_NAME);
 
     sd->result = tc_malloc(TC_BUF_LINE);
     filenamecopy = tc_strdup(sd->vob->video_in_file);
@@ -170,34 +169,35 @@ static int stabilize_configure(TCModuleInstance *self,
         // for some reason this plugin is called in the old fashion
         //  (not with inspect). Anyway we support both ways of getting help.
         if(optstr_lookup(options, "help")) {
-            tc_log_info(MOD_NAME,motiondetect_help);
+            tc_log_info(MOD_NAME,vs_motiondetect_help);
             return(TC_IMPORT_ERROR);
         }
 
         optstr_get(options, "result",     "%[^:]", sd->result);
-        optstr_get(options, "shakiness",  "%d", &md->shakiness);
-        optstr_get(options, "accuracy",   "%d", &md->accuracy);
-        optstr_get(options, "stepsize",   "%d", &md->stepSize);
-        optstr_get(options, "algo",       "%d", &md->algo);
-        optstr_get(options, "mincontrast","%lf",&md->contrastThreshold);
-        optstr_get(options, "tripod",     "%d", &md->virtualTripod);
-        optstr_get(options, "show",       "%d", &md->show);
+        optstr_get(options, "shakiness",  "%d", &conf.shakiness);
+        optstr_get(options, "accuracy",   "%d", &conf.accuracy);
+        optstr_get(options, "stepsize",   "%d", &conf.stepSize);
+        optstr_get(options, "algo",       "%d", &conf.algo);
+        optstr_get(options, "mincontrast","%lf",&conf.contrastThreshold);
+        optstr_get(options, "tripod",     "%d", &conf.virtualTripod);
+        optstr_get(options, "show",       "%d", &conf.show);
     }
 
-    if(configureMotionDetect(md)!= VS_OK){
-    	tc_log_error(MOD_NAME, "configuration of Motion Detection failed");
+    if(vsMotionDetectInit(md, &conf, &fi) != VS_OK){
+        tc_log_error(MOD_NAME, "initialization of Motion Detection failed");
         return TC_ERROR;
     }
+    vsMotionDetectGetConfig(&conf,md);
 
     if (verbose) {
         tc_log_info(MOD_NAME, "Image Stabilization Settings:");
-        tc_log_info(MOD_NAME, "     shakiness = %d", md->shakiness);
-        tc_log_info(MOD_NAME, "      accuracy = %d", md->accuracy);
-        tc_log_info(MOD_NAME, "      stepsize = %d", md->stepSize);
-        tc_log_info(MOD_NAME, "          algo = %d", md->algo);
-        tc_log_info(MOD_NAME, "   mincontrast = %f", md->contrastThreshold);
-        tc_log_info(MOD_NAME, "        tripod = %d", md->virtualTripod);
-        tc_log_info(MOD_NAME, "          show = %d", md->show);
+        tc_log_info(MOD_NAME, "     shakiness = %d", conf.shakiness);
+        tc_log_info(MOD_NAME, "      accuracy = %d", conf.accuracy);
+        tc_log_info(MOD_NAME, "      stepsize = %d", conf.stepSize);
+        tc_log_info(MOD_NAME, "          algo = %d", conf.algo);
+        tc_log_info(MOD_NAME, "   mincontrast = %f", conf.contrastThreshold);
+        tc_log_info(MOD_NAME, "        tripod = %d", conf.virtualTripod);
+        tc_log_info(MOD_NAME, "          show = %d", conf.show);
         tc_log_info(MOD_NAME, "        result = %s", sd->result);
     }
 
@@ -206,22 +206,12 @@ static int stabilize_configure(TCModuleInstance *self,
         tc_log_error(MOD_NAME, "cannot open result file %s!\n", sd->result);
         return TC_ERROR;
     }else{
-        if(prepareFile(md, sd->f) != VS_OK){
+        if(vsPrepareFile(md, sd->f) != VS_OK){
             tc_log_error(MOD_NAME, "cannot write to result file %s", sd->result);
             return TC_ERROR;
         }
     }
 
-    /***** This is now done by boxblur ****/
-    /* /\* load unsharp filter to smooth the frames. This allows larger stepsize.*\/ */
-    /* char unsharp_param[128]; */
-    /* int masksize = TC_MIN(13,md->stepSize*1.5); // only works up to 13. */
-    /* sprintf(unsharp_param,"luma=-1:luma_matrix=%ix%i:pre=1", */
-    /*         masksize, masksize); */
-    /* if (!tc_filter_add("unsharp", unsharp_param)) { */
-    /*     tc_log_warn(MOD_NAME, "cannot load unsharp filter!"); */
-    /* } */
-
     return TC_OK;
 }
 
@@ -240,16 +230,16 @@ static int stabilize_filter_video(TCModuleInstance *self,
     TC_MODULE_SELF_CHECK(frame, "filter_video");
 
     sd = self->userdata;
-    MotionDetect* md = &(sd->md);
+    VSMotionDetect* md = &(sd->md);
     LocalMotions localmotions;
     VSFrame vsFrame;
-    fillFrameFromBuffer(&vsFrame,frame->video_buf, &md->fi);
+    vsFrameFillFromBuffer(&vsFrame,frame->video_buf, &md->fi);
 
-    if(motionDetection(md, &localmotions, &vsFrame)!= VS_OK){
-    	tc_log_error(MOD_NAME, "motion detection failed");
-    	return TC_ERROR;
+    if(vsMotionDetection(md, &localmotions, &vsFrame)!= VS_OK){
+      tc_log_error(MOD_NAME, "motion detection failed");
+      return TC_ERROR;
     }
-    if(writeToFile(md, sd->f, &localmotions) != VS_OK){
+    if(vsWriteToFile(md, sd->f, &localmotions) != VS_OK){
         vs_vector_del(&localmotions);
         return TC_ERROR;
     } else {
@@ -268,13 +258,13 @@ static int stabilize_stop(TCModuleInstance *self)
     StabData *sd = NULL;
     TC_MODULE_SELF_CHECK(self, "stop");
     sd = self->userdata;
-    MotionDetect* md = &(sd->md);
+    VSMotionDetect* md = &(sd->md);
     if (sd->f) {
         fclose(sd->f);
         sd->f = NULL;
     }
 
-    cleanupMotionDetection(md);
+    vsMotionDetectionCleanup(md);
     if (sd->result) {
         tc_free(sd->result);
         sd->result = NULL;
@@ -296,7 +286,7 @@ static int stabilize_stop(TCModuleInstance *self)
  */
 
 static int stabilize_inspect(TCModuleInstance *self,
-			     const char *param, const char **value)
+           const char *param, const char **value)
 {
     StabData *sd = NULL;
 
@@ -304,17 +294,19 @@ static int stabilize_inspect(TCModuleInstance *self,
     TC_MODULE_SELF_CHECK(param, "inspect");
     TC_MODULE_SELF_CHECK(value, "inspect");
     sd = self->userdata;
-    MotionDetect* md = &(sd->md);
+    VSMotionDetect* md = &(sd->md);
     if (optstr_lookup(param, "help")) {
-        *value = motiondetect_help;
+        *value = vs_motiondetect_help;
     }
-    CHECKPARAM("shakiness","shakiness=%d", md->shakiness);
-    CHECKPARAM("accuracy", "accuracy=%d",  md->accuracy);
-    CHECKPARAM("stepsize", "stepsize=%d",  md->stepSize);
-    CHECKPARAM("allowmax", "allowmax=%d",  md->allowMax);
-    CHECKPARAM("algo",     "algo=%d",      md->algo);
-    CHECKPARAM("tripod",   "tripod=%d",    md->virtualTripod);
-    CHECKPARAM("show",     "show=%d",      md->show);
+    VSMotionDetectConfig conf;
+    vsMotionDetectGetConfig(&conf,md);
+
+    CHECKPARAM("shakiness","shakiness=%d", conf.shakiness);
+    CHECKPARAM("accuracy", "accuracy=%d",  conf.accuracy);
+    CHECKPARAM("stepsize", "stepsize=%d",  conf.stepSize);
+    CHECKPARAM("algo",     "algo=%d",      conf.algo);
+    CHECKPARAM("tripod",   "tripod=%d",    conf.virtualTripod);
+    CHECKPARAM("show",     "show=%d",      conf.show);
     CHECKPARAM("result",   "result=%s",    sd->result);
     return TC_OK;
 }
@@ -377,7 +369,8 @@ TC_FILTER_OLDINTERFACE(stabilize)
  *   c-file-style: "stroustrup"
  *   c-file-offsets: ((case-label . *) (statement-case-intro . *))
  *   indent-tabs-mode: nil
+ *   c-basic-offset: 2 t
  * End:
  *
- * vim: expandtab shiftwidth=4:
+ * vim: expandtab shiftwidth=2:
  */
diff --git a/transcode/filter_transform.c b/transcode/filter_transform.c
index 0e5562b..a717523 100644
--- a/transcode/filter_transform.c
+++ b/transcode/filter_transform.c
@@ -44,16 +44,18 @@
 #include "libtc/tccodecs.h"
 #include "libtc/tcmodule-plugin.h"
 
-#include "pix_formats.h"
+#include "transcode_specifics.h"
 
 #define DEFAULT_TRANS_FILE_NAME     "transforms.dat"
 
 typedef struct {
-    TransformData td;
+    VSTransformData td;
     vob_t* vob;          // pointer to information structure
 
-    Transformations trans; // transformations
+    VSTransformations trans; // transformations
 
+
+    double sharpen;     // amount of sharpening
     char input[TC_BUF_LINE];
     char conf_str[TC_BUF_MIN];
 } FilterData;
@@ -64,11 +66,12 @@ typedef struct {
  */
 static int transform_init(TCModuleInstance *self, uint32_t features)
 {
-
     FilterData* fd = NULL;
     TC_MODULE_SELF_CHECK(self, "init");
     TC_MODULE_INIT_CHECK(self, MOD_FEATURES, features);
 
+    setLogFunctions();
+
     fd = tc_zalloc(sizeof(FilterData));
     if (fd == NULL) {
         tc_log_error(MOD_NAME, "init: out of memory!");
@@ -88,7 +91,7 @@ static int transform_init(TCModuleInstance *self, uint32_t features)
  * tcmodule-data.h for function details.
  */
 static int transform_configure(TCModuleInstance *self,
-			       const char *options, vob_t *vob)
+             const char *options, vob_t *vob)
 {
     FilterData *fd = NULL;
     char* filenamecopy, *filebasename;
@@ -96,7 +99,7 @@ static int transform_configure(TCModuleInstance *self,
     TC_MODULE_SELF_CHECK(self, "configure");
 
     fd = self->userdata;
-    TransformData* td = &(fd->td);
+    VSTransformData* td = &(fd->td);
 
     fd->vob = vob;
     if (!fd->vob)
@@ -106,18 +109,17 @@ static int transform_configure(TCModuleInstance *self,
 
     VSFrameInfo fi_src;
     VSFrameInfo fi_dest;
-    initFrameInfo(&fi_src, fd->vob->ex_v_width, fd->vob->ex_v_height,
+    vsFrameInfoInit(&fi_src, fd->vob->ex_v_width, fd->vob->ex_v_height,
                   transcode2ourPF(fd->vob->im_v_codec));
-    initFrameInfo(&fi_dest, fd->vob->ex_v_width, fd->vob->ex_v_height,
+    vsFrameInfoInit(&fi_dest, fd->vob->ex_v_width, fd->vob->ex_v_height,
                   transcode2ourPF(fd->vob->im_v_codec));
 
-    if(initTransformData(td, &fi_src, &fi_dest, MOD_NAME) != VS_OK){
-        tc_log_error(MOD_NAME, "initialization of TransformData failed");
-        return TC_ERROR;
-    }
-    td->verbose=verbose;
+    VSTransformConfig conf = vsTransformGetDefaulfConfig(MOD_NAME);
+    conf.verbose = verbose;
+    fd->sharpen  = 0.8;
+
 
-    initTransformations(&fd->trans);
+    vsTransformationsInit(&fd->trans);
 
     filenamecopy = tc_strdup(fd->vob->video_in_file);
     filebasename = basename(filenamecopy);
@@ -135,50 +137,51 @@ static int transform_configure(TCModuleInstance *self,
     if (options != NULL) {
         // We support also the help option.
         if(optstr_lookup(options, "help")) {
-            tc_log_info(MOD_NAME,transform_help);
+            tc_log_info(MOD_NAME,vs_transform_help);
             return(TC_IMPORT_ERROR);
         }
-        optstr_get(options, "input", "%[^:]", (char*)&fd->input);
-        optstr_get(options, "maxshift",  "%d", &td->maxShift);
-        optstr_get(options, "maxangle",  "%lf", &td->maxAngle);
-        optstr_get(options, "smoothing", "%d", &td->smoothing);
-        optstr_get(options, "crop"     , "%d", (int*)&td->crop);
-        optstr_get(options, "invert"   , "%d", &td->invert);
-        optstr_get(options, "relative" , "%d", &td->relative);
-        optstr_get(options, "zoom"     , "%lf",&td->zoom);
-        optstr_get(options, "optzoom"  , "%d", &td->optZoom);
-        optstr_get(options, "interpol" , "%d", (int*)(&td->interpolType));
-        optstr_get(options, "sharpen"  , "%lf",&td->sharpen);
+        optstr_get(options, "input",  "%[^:]", (char*)&fd->input);
+        optstr_get(options, "maxshift",  "%d", &conf.maxShift);
+        optstr_get(options, "maxangle", "%lf", &conf.maxAngle);
+        optstr_get(options, "smoothing", "%d", &conf.smoothing);
+        optstr_get(options, "crop"     , "%d", (int*)&conf.crop);
+        optstr_get(options, "invert"   , "%d", &conf.invert);
+        optstr_get(options, "relative" , "%d", &conf.relative);
+        optstr_get(options, "zoom"     ,"%lf", &conf.zoom);
+        optstr_get(options, "optzoom"  , "%d", &conf.optZoom);
+        optstr_get(options, "interpol" , "%d", (int*)(&conf.interpolType));
+        optstr_get(options, "sharpen"  ,"%lf", &fd->sharpen);
         if(optstr_lookup(options, "tripod")){
             tc_log_info(MOD_NAME,"Virtual tripod mode: relative=False, smoothing=0");
-            td->relative=0;
-            td->smoothing=0;
+            conf.relative=0;
+            conf.smoothing=0;
         }
     }
 
-    if(configureTransformData(td)!= VS_OK){
-        tc_log_error(MOD_NAME, "configuration of TransformData failed");
+    if(vsTransformDataInit(td, &conf, &fi_src, &fi_dest) != VS_OK){
+        tc_log_error(MOD_NAME, "initialization of VSTransformData failed");
         return TC_ERROR;
     }
+    vsTransformGetConfig(&conf,td);
 
     if (verbose) {
         tc_log_info(MOD_NAME, "Image Transformation/Stabilization Settings:");
         tc_log_info(MOD_NAME, "    input     = %s", fd->input);
-        tc_log_info(MOD_NAME, "    smoothing = %d", td->smoothing);
-        tc_log_info(MOD_NAME, "    maxshift  = %d", td->maxShift);
-        tc_log_info(MOD_NAME, "    maxangle  = %f", td->maxAngle);
+        tc_log_info(MOD_NAME, "    smoothing = %d", conf.smoothing);
+        tc_log_info(MOD_NAME, "    maxshift  = %d", conf.maxShift);
+        tc_log_info(MOD_NAME, "    maxangle  = %f", conf.maxAngle);
         tc_log_info(MOD_NAME, "    crop      = %s",
-                        td->crop ? "Black" : "Keep");
+                        conf.crop ? "Black" : "Keep");
         tc_log_info(MOD_NAME, "    relative  = %s",
-                    td->relative ? "True": "False");
+                    conf.relative ? "True": "False");
         tc_log_info(MOD_NAME, "    invert    = %s",
-                    td->invert ? "True" : "False");
-        tc_log_info(MOD_NAME, "    zoom      = %f", td->zoom);
+                    conf.invert ? "True" : "False");
+        tc_log_info(MOD_NAME, "    zoom      = %f", conf.zoom);
         tc_log_info(MOD_NAME, "    optzoom   = %s",
-                    td->optZoom ? "On" : "Off");
+                    conf.optZoom ? "On" : "Off");
         tc_log_info(MOD_NAME, "    interpol  = %s",
-                    interpolTypes[td->interpolType]);
-        tc_log_info(MOD_NAME, "    sharpen   = %f", td->sharpen);
+                    getInterpolationTypeName(conf.interpolType));
+        tc_log_info(MOD_NAME, "    sharpen   = %f", fd->sharpen);
     }
 
     f = fopen(fd->input, "r");
@@ -186,32 +189,32 @@ static int transform_configure(TCModuleInstance *self,
         tc_log_error(MOD_NAME, "cannot open input file %s!\n", fd->input);
         /* return (-1); when called using tcmodinfo this will fail */
     } else {
-        ManyLocalMotions mlms;
-        if(readLocalMotionsFile(f,&mlms)==VS_OK){
+        VSManyLocalMotions mlms;
+        if(vsReadLocalMotionsFile(f,&mlms)==VS_OK){
             // calculate the actual transforms from the localmotions
-            if(localmotions2TransformsSimple(td, &mlms,&fd->trans)!=VS_OK)
+            if(vsLocalmotions2TransformsSimple(td, &mlms,&fd->trans)!=VS_OK)
                 tc_log_error(MOD_NAME, "calculating transformations failed!\n");
         }else{ // try to read old format
-            if (!readOldTransforms(td, f, &fd->trans)) { /* read input file */
+            if (!vsReadOldTransforms(td, f, &fd->trans)) { /* read input file */
                 tc_log_error(MOD_NAME, "error parsing input file %s!\n", fd->input);
             }
         }
     }
     fclose(f);
 
-    if (preprocessTransforms(td, &fd->trans)!= VS_OK ) {
+    if (vsPreprocessTransforms(td, &fd->trans)!= VS_OK ) {
         tc_log_error(MOD_NAME, "error while preprocessing transforms!");
         return TC_ERROR;
     }
 
     // sharpen is still in transcode...
     /* Is this the right point to add the filter? Seems to be the case.*/
-    if(td->sharpen>0){
+    if(fd->sharpen>0){
         /* load unsharp filter */
         char unsharp_param[256];
         sprintf(unsharp_param,"luma=%f:%s:chroma=%f:%s",
-                td->sharpen, "luma_matrix=5x5",
-                td->sharpen/2, "chroma_matrix=5x5");
+                fd->sharpen, "luma_matrix=5x5",
+                fd->sharpen/2, "chroma_matrix=5x5");
         if (!tc_filter_add("unsharp", unsharp_param)) {
             tc_log_warn(MOD_NAME, "cannot load unsharp filter!");
         }
@@ -235,20 +238,15 @@ static int transform_filter_video(TCModuleInstance *self,
 
     fd = self->userdata;
     VSFrame vsFrame;
-    fillFrameFromBuffer(&vsFrame,frame->video_buf, &fd->td.fiSrc);
+    vsFrameFillFromBuffer(&vsFrame,frame->video_buf, vsTransformGetSrcFrameInfo(&fd->td));
 
-    transformPrepare(&fd->td, &vsFrame,  &vsFrame);
+    vsTransformPrepare(&fd->td, &vsFrame,  &vsFrame);
 
-    Transform t = getNextTransform(&fd->td, &fd->trans);
-    if (fd->vob->im_v_codec == CODEC_RGB) {
-        transformRGB(&fd->td, t);
-    } else if (fd->vob->im_v_codec == CODEC_YUV) {
-        transformYUV(&fd->td, t);
-    } else {
-        tc_log_error(MOD_NAME, "unsupported Codec: %i\n", fd->vob->im_v_codec);
-        return TC_ERROR;
-    }
-    transformFinish(&fd->td);
+    VSTransform t = vsGetNextTransform(&fd->td, &fd->trans);
+
+    vsDoTransform(&fd->td, t);
+
+    vsTransformFinish(&fd->td);
     return TC_OK;
 }
 
@@ -277,9 +275,9 @@ static int transform_stop(TCModuleInstance *self)
     FilterData *fd = NULL;
     TC_MODULE_SELF_CHECK(self, "stop");
     fd = self->userdata;
-    cleanupTransformData(&fd->td);
+    vsTransformDataCleanup(&fd->td);
 
-    cleanupTransformations(&fd->trans);
+    vsTransformationsCleanup(&fd->trans);
     return TC_OK;
 }
 
@@ -296,7 +294,7 @@ static int transform_stop(TCModuleInstance *self)
  * the module.  See tcmodule-data.h for function details.
  */
 static int transform_inspect(TCModuleInstance *self,
-            			     const char *param, const char **value)
+                       const char *param, const char **value)
 {
     FilterData *fd = NULL;
     TC_MODULE_SELF_CHECK(self,  "inspect");
@@ -306,18 +304,20 @@ static int transform_inspect(TCModuleInstance *self,
     fd = self->userdata;
 
     if (optstr_lookup(param, "help")) {
-        *value = transform_help;
+        *value = vs_transform_help;
     }
-    CHECKPARAM("maxshift", "maxshift=%d",  fd->td.maxShift);
-    CHECKPARAM("maxangle", "maxangle=%f",  fd->td.maxAngle);
-    CHECKPARAM("smoothing","smoothing=%d", fd->td.smoothing);
-    CHECKPARAM("crop",     "crop=%d",      fd->td.crop);
-    CHECKPARAM("relative", "relative=%d",  fd->td.relative);
-    CHECKPARAM("invert",   "invert=%i",    fd->td.invert);
+    VSTransformConfig conf;
+    vsTransformGetConfig(&conf,&fd->td);
+    CHECKPARAM("maxshift", "maxshift=%d",  conf.maxShift);
+    CHECKPARAM("maxangle", "maxangle=%f",  conf.maxAngle);
+    CHECKPARAM("smoothing","smoothing=%d", conf.smoothing);
+    CHECKPARAM("crop",     "crop=%d",      conf.crop);
+    CHECKPARAM("relative", "relative=%d",  conf.relative);
+    CHECKPARAM("invert",   "invert=%i",    conf.invert);
     CHECKPARAM("input",    "input=%s",     fd->input);
-    CHECKPARAM("optzoom",  "optzoom=%i",   fd->td.optZoom);
-    CHECKPARAM("zoom",     "zoom=%f",      fd->td.zoom);
-    CHECKPARAM("sharpen",  "sharpen=%f",   fd->td.sharpen);
+    CHECKPARAM("optzoom",  "optzoom=%i",   conf.optZoom);
+    CHECKPARAM("zoom",     "zoom=%f",      conf.zoom);
+    CHECKPARAM("sharpen",  "sharpen=%f",   fd->sharpen);
 
     return TC_OK;
 };
@@ -374,16 +374,13 @@ static int transform_process(TCModuleInstance *self, frame_list_t *frame)
 TC_FILTER_OLDINTERFACE(transform)
 
 /*************************************************************************/
-/*
-  TODO:
-  - check for optimization, e.g. mmx stuff
-*/
 
 /*
  * Local variables:
  *   c-file-style: "stroustrup"
  *   c-file-offsets: ((case-label . *) (statement-case-intro . *))
  *   indent-tabs-mode: nil
+ *   c-basic-offset: 4 t
  * End:
  *
  * vim: expandtab shiftwidth=4:
diff --git a/transcode/pix_formats.h b/transcode/pix_formats.h
deleted file mode 100644
index f769c37..0000000
--- a/transcode/pix_formats.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- *  pix_formats.h
- *
- *  Copyright (C) Georg Martius - February 2013
- *   georg dot martius at web dot de
- *
- *  This file is part of transcode, a video stream processing tool
- *
- *  transcode is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2, or (at your option)
- *  any later version.
- *
- *  transcode is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with GNU Make; see the file COPYING.  If not, write to
- *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
- *
-*/
-
-#ifndef __PIX_FORMATS_H
-#define __PIX_FORMATS_H
-
-#include "frameinfo.h"
-#include "transcode.h"
-
-static PixelFormat transcode2ourPF(int tc_img_codec){
-	switch(tc_img_codec){
-	case CODEC_RGB:
-		return PF_RGB24;
-	case CODEC_YUV:
-		return PF_YUV420P;
-	case CODEC_YUV422:
-		return PF_YUV422P;
-	default:
-		tc_log_error(MOD_NAME, "cannot deal with img format %i!\n", tc_img_codec);
-		return PF_NONE;
-	}
-}
-
-#endif
diff --git a/transcode/transcode_specifics.h b/transcode/transcode_specifics.h
new file mode 100644
index 0000000..60f0ee3
--- /dev/null
+++ b/transcode/transcode_specifics.h
@@ -0,0 +1,63 @@
+/*
+ *  transcode_specifics.h
+ *
+ *  Copyright (C) Georg Martius - February 2013
+ *   georg dot martius at web dot de
+ *
+ *  This file is part of transcode, a video stream processing tool
+ *
+ *  transcode is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  transcode is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GNU Make; see the file COPYING.  If not, write to
+ *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+*/
+
+#ifndef __TRANSCODE_SPECIFICS_H
+#define __TRANSCODE_SPECIFICS_H
+
+#include "vidstabdefines.h"
+#include "frameinfo.h"
+#include <transcode.h>
+
+static VSPixelFormat transcode2ourPF(int tc_img_codec){
+  switch(tc_img_codec){
+  case CODEC_RGB:
+    return PF_RGB24;
+  case CODEC_YUV:
+    return PF_YUV420P;
+  case CODEC_YUV422:
+    return PF_YUV422P;
+  default:
+    tc_log_error(MOD_NAME, "cannot deal with img format %i!\n", tc_img_codec);
+    return PF_NONE;
+  }
+}
+
+void setLogFunctions(){
+  // we cannot map the memory functions because they are macros
+  //  with FILE and LINE expansion in transcode
+
+  VS_ERROR_TYPE = TC_LOG_ERR;
+  VS_WARN_TYPE  = TC_LOG_WARN;
+  VS_INFO_TYPE  = TC_LOG_INFO;
+  VS_MSG_TYPE   = TC_LOG_MSG;
+
+  // we need the case because tc_log has first argument TCLogLevel
+  //  which is an enum and not an int
+  vs_log   = (vs_log_t)tc_log;
+
+  VS_ERROR = TC_ERROR;
+  VS_OK    = TC_OK;
+}
+
+#endif
